'use client'
import { useRef } from 'react';
import { hasPendingRequirements } from '../../../shared/utils/functions/hasPendingRequirements/hasPendingRequirements.js';
import { createStoreState } from '../../internalImplementation/utils/createStoreState/createStoreState.js';
import { raiseUserProfileEvent } from './raiseUserProfileEvent/raiseUserProfileEvent.js';

const { getUser, setUser: setUserRaw, useUser: useUserRaw, } = createStoreState('user');
const setUser = (user) => {
    const oldUser = getUser();
    setUserRaw(user);
    if (user && oldUser)
        raiseUserProfileEvent({ newUser: user, oldUser });
};
const useUser = () => {
    // after user has fully logged in (user is defined), it should never go back to
    // not being fully logged in (userWithMissingInfo defined instead of user),
    // unless it's logged out (no user or userWithMissingInfo defined)
    const hasFullyLoggedIn = useRef(false);
    const userFromStore = useUserRaw();
    if (!userFromStore) {
        hasFullyLoggedIn.current = false;
        return {};
    }
    // adding userWithMissingInfo to avoid breaking changes for customer who consider that when we have a user,
    // it means that they are already fully authenticated.
    // since we won't have onboarding jwt anymore, the idea is to just store the user in LS and either use the user state
    // or userWithMissingInfo, depending on the value of missing fields or mfa required.
    // this is just following our existing logic of how we handle authToken vs onboardingOnlyToken.
    if (!hasFullyLoggedIn.current && hasPendingRequirements(userFromStore)) {
        return { userWithMissingInfo: userFromStore };
    }
    hasFullyLoggedIn.current = true;
    return { user: userFromStore };
};
const useUserCoalesced = () => {
    var _a;
    const user = useUser();
    return (_a = user.user) !== null && _a !== void 0 ? _a : user.userWithMissingInfo;
};

export { getUser, setUser, useUser, useUserCoalesced };
