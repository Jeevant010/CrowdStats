'use client'
import { __awaiter } from '../../../../../_virtual/_tslib.js';
import { useCallback } from 'react';
import { tracing, StorageService, InvalidEmbeddedWalletSessionKeyError } from '@dynamic-labs/utils';
import { logger } from '@dynamic-labs/wallet-connector-core';
import { SECURE_ENCLAVE_WALLET_SESSION_KEYS, SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS } from '../../constants/localStorage.js';
import { p256Sign, p256Keygen } from '../useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/utils.js';
import '@dynamic-labs/sdk-api-core';
import '../../../config/ApiEndpoint.js';
import '../../../store/state/projectSettings/projectSettings.js';
import '../../constants/values.js';
import '@dynamic-labs/multi-wallet';
import '../../../shared/logger.js';
import '../../constants/colors.js';
import 'react-international-phone';
import '@dynamic-labs/iconic';
import 'react/jsx-runtime';
import '../../../context/ViewContext/ViewContext.js';
import '@dynamic-labs/wallet-book';
import '../../../shared/consts/index.js';
import '../../../store/state/nonce/nonce.js';
import '../../../store/state/dynamicContextProps/dynamicContextProps.js';
import { getPrimaryWalletId } from '../../../store/state/primaryWalletId/primaryWalletId.js';
import { useUser } from '../../../store/state/user/user.js';
import '../../../store/state/connectedWalletsInfo/connectedWalletsInfo.js';
import { registerSessionKey } from '../../../data/api/embeddedWallets/embeddedWallets.js';
import '../../../locale/locale.js';
import { dynamicEvents } from '../../../events/dynamicEvents.js';
import { getPrimaryTurnkeyWalletId } from '../../functions/getPrimaryTurnkeyWalletId/getPrimaryTurnkeyWalletId.js';

const useEmbeddedWalletSessionKeys = ({ environmentId, projectSettings, }) => {
    const { user } = useUser();
    // scenario 1: first time session register on first transaction.
    // Keys will have been previously generated at this point in local storage but marked as not registered
    // scenario 2: 2nd time register after expiration (key refresh)
    // scenario 3: refresh/rerender page - session still active
    // scenario 4: refresh/rerender page - session no longer active
    const registerEmbeddedWalletSessionKey = (...args_1) => __awaiter(void 0, [...args_1], void 0, function* ({ ignoreRestore = false, } = {}) {
        // check if session keys are already stored in session storage
        const sessionKeysSS = StorageService.getItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        const decodedSessionKeys = sessionKeysSS
            ? JSON.parse(Buffer.from(sessionKeysSS, 'base64').toString())
            : undefined;
        tracing.logEvent('session-key', 'registerEmbeddedWalletSessionKey', tracing.formatObject({
            hasDecodedSessionKeys: Boolean(decodedSessionKeys),
            publicKey: decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey,
        }));
        if (!decodedSessionKeys) {
            logger.warn('Could not find session keys. Re-authentication is required to create new session keys.');
            dynamicEvents.emit('triggerLogout');
            throw new Error('Could not find session keys. Re-authentication is required to create new session keys.');
        }
        if (!user) {
            throw new Error('User not found');
        }
        const isSessionKeyValid = decodedSessionKeys.expirationDate &&
            new Date() <= new Date(decodedSessionKeys.expirationDate) &&
            !ignoreRestore;
        tracing.logEvent('session-key', 'isSessionKeyValid', tracing.formatObject({
            isSessionKeyValid: Boolean(isSessionKeyValid),
        }));
        if (isSessionKeyValid) {
            // scenario 3
            return decodedSessionKeys;
        }
        tracing.logEvent('session-key', 'decodedSessionKeys', tracing.formatObject({
            publicKey: decodedSessionKeys.publicKey,
            registered: decodedSessionKeys.registered,
        }));
        let publicKey;
        let privateKey;
        let privateKeyJwk;
        let prevSessionKeySignature = undefined;
        if (!decodedSessionKeys.registered) {
            // scenario 1
            ({ publicKey, privateKey, privateKeyJwk } = decodedSessionKeys);
        }
        else {
            // scenario 2 and 4
            const { publicKey: nextPublicKey, privateKey: nextPrivateKey, privateKeyJwk: nextPrivateKeyJwk, } = yield generateSessionKey();
            publicKey = nextPublicKey;
            privateKey = nextPrivateKey;
            privateKeyJwk = nextPrivateKeyJwk;
            prevSessionKeySignature = yield p256Sign(decodedSessionKeys.privateKeyJwk, user.sessionId);
            tracing.logEvent('session-key', 'Loaded prevSessionKeySignature', tracing.formatObject({ nextPublicKey, prevSessionKeySignature }));
        }
        let resp;
        const primaryWalletId = getPrimaryWalletId();
        if (!primaryWalletId) {
            throw new Error('Primary wallet ID not found');
        }
        const turnkeyWalletId = getPrimaryTurnkeyWalletId(primaryWalletId, user.verifiedCredentials);
        try {
            resp = yield registerSessionKey({
                environmentId,
                prevSessionKeySignature,
                publicKey,
                walletId: turnkeyWalletId,
            });
        }
        catch (error) {
            if (error instanceof InvalidEmbeddedWalletSessionKeyError) {
                // this can happen if the public key passed during initial registration
                // does not match the root session public key that the backend expects
                logger.warn('Invalid embedded wallet session key. Re-authentication is required to create new session keys.');
                dynamicEvents.emit('triggerLogout');
            }
            throw error;
        }
        const expirationDate = new Date(resp.expiresAt * 1000);
        tracing.logEvent('session-key', 'Created new session key', tracing.formatObject({
            expirationDate,
            publicKey,
        }));
        StorageService.setItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, toEncodedFormat(publicKey, privateKey, privateKeyJwk, true, expirationDate), SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        return { expirationDate, privateKey, publicKey };
    });
    const generateSessionKey = () => __awaiter(void 0, void 0, void 0, function* () {
        const { private: privateKey, public: publicKey, privateJwk, } = yield p256Keygen();
        // convert to base64 and store the session keys in session storage
        tracing.logEvent('session-key', 'Generated new session key', tracing.formatObject({
            publicKey,
        }));
        StorageService.setItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, toEncodedFormat(publicKey, privateKey, privateJwk, false), SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        return { privateKey, privateKeyJwk: privateJwk, publicKey };
    });
    const getSessionPublicKey = () => {
        const sessionKeysSS = StorageService.getItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        const decodedSessionKeys = sessionKeysSS
            ? JSON.parse(Buffer.from(sessionKeysSS, 'base64').toString())
            : undefined;
        if (!(decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey)) {
            tracing.logEvent('session-key', 'getSessionPublicKey', 'Could not find session keys.');
            throw new Error('Could not find session keys.');
        }
        tracing.logEvent('session-key', 'getSessionPublicKey', tracing.formatObject({
            publicKey: decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey,
        }));
        return decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey;
    };
    // this is a temporary fix to ensure that session keys are registered on signin for all wallets
    // the user is undefined at this point in the auth flow and we cant check the users wallet version
    // so we just return true for now
    const shouldRegisterSessionKeysOnSignin = () => true;
    const toEncodedFormat = (publicKey, privateKey, privateKeyJwk, registered, expirationDate) => {
        const sessionKeys = {
            expirationDate,
            privateKey,
            privateKeyJwk,
            publicKey,
            registered,
        };
        const sessionKeysString = JSON.stringify(sessionKeys);
        return Buffer.from(sessionKeysString).toString('base64');
    };
    const removeSessionKey = useCallback(() => {
        tracing.logEvent('session-key', 'removeSessionKey');
        StorageService.removeItem(SECURE_ENCLAVE_WALLET_SESSION_KEYS, SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
    }, []);
    return {
        generateSessionKey,
        getSessionPublicKey,
        registerEmbeddedWalletSessionKey,
        removeSessionKey,
        shouldRegisterSessionKeysOnSignin,
    };
};

export { useEmbeddedWalletSessionKeys };
