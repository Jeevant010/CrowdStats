'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../../../_virtual/_tslib.cjs');
var React = require('react');
var utils = require('@dynamic-labs/utils');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var localStorage = require('../../constants/localStorage.cjs');
var utils$1 = require('../useEmbeddedWallet/useSecureEnclaveEmbeddedWallet/utils.cjs');
require('@dynamic-labs/sdk-api-core');
require('../../../config/ApiEndpoint.cjs');
require('../../../store/state/projectSettings/projectSettings.cjs');
require('../../constants/values.cjs');
require('@dynamic-labs/multi-wallet');
require('../../../shared/logger.cjs');
require('../../constants/colors.cjs');
require('react-international-phone');
require('@dynamic-labs/iconic');
require('react/jsx-runtime');
require('../../../context/ViewContext/ViewContext.cjs');
require('@dynamic-labs/wallet-book');
require('../../../shared/consts/index.cjs');
require('../../../store/state/nonce/nonce.cjs');
require('../../../store/state/dynamicContextProps/dynamicContextProps.cjs');
var primaryWalletId = require('../../../store/state/primaryWalletId/primaryWalletId.cjs');
var user = require('../../../store/state/user/user.cjs');
require('../../../store/state/connectedWalletsInfo/connectedWalletsInfo.cjs');
var embeddedWallets = require('../../../data/api/embeddedWallets/embeddedWallets.cjs');
require('../../../locale/locale.cjs');
var dynamicEvents = require('../../../events/dynamicEvents.cjs');
var getPrimaryTurnkeyWalletId = require('../../functions/getPrimaryTurnkeyWalletId/getPrimaryTurnkeyWalletId.cjs');

const useEmbeddedWalletSessionKeys = ({ environmentId, projectSettings, }) => {
    const { user: user$1 } = user.useUser();
    // scenario 1: first time session register on first transaction.
    // Keys will have been previously generated at this point in local storage but marked as not registered
    // scenario 2: 2nd time register after expiration (key refresh)
    // scenario 3: refresh/rerender page - session still active
    // scenario 4: refresh/rerender page - session no longer active
    const registerEmbeddedWalletSessionKey = (...args_1) => _tslib.__awaiter(void 0, [...args_1], void 0, function* ({ ignoreRestore = false, } = {}) {
        // check if session keys are already stored in session storage
        const sessionKeysSS = utils.StorageService.getItem(localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS, localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        const decodedSessionKeys = sessionKeysSS
            ? JSON.parse(Buffer.from(sessionKeysSS, 'base64').toString())
            : undefined;
        utils.tracing.logEvent('session-key', 'registerEmbeddedWalletSessionKey', utils.tracing.formatObject({
            hasDecodedSessionKeys: Boolean(decodedSessionKeys),
            publicKey: decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey,
        }));
        if (!decodedSessionKeys) {
            walletConnectorCore.logger.warn('Could not find session keys. Re-authentication is required to create new session keys.');
            dynamicEvents.dynamicEvents.emit('triggerLogout');
            throw new Error('Could not find session keys. Re-authentication is required to create new session keys.');
        }
        if (!user$1) {
            throw new Error('User not found');
        }
        const isSessionKeyValid = decodedSessionKeys.expirationDate &&
            new Date() <= new Date(decodedSessionKeys.expirationDate) &&
            !ignoreRestore;
        utils.tracing.logEvent('session-key', 'isSessionKeyValid', utils.tracing.formatObject({
            isSessionKeyValid: Boolean(isSessionKeyValid),
        }));
        if (isSessionKeyValid) {
            // scenario 3
            return decodedSessionKeys;
        }
        utils.tracing.logEvent('session-key', 'decodedSessionKeys', utils.tracing.formatObject({
            publicKey: decodedSessionKeys.publicKey,
            registered: decodedSessionKeys.registered,
        }));
        let publicKey;
        let privateKey;
        let privateKeyJwk;
        let prevSessionKeySignature = undefined;
        if (!decodedSessionKeys.registered) {
            // scenario 1
            ({ publicKey, privateKey, privateKeyJwk } = decodedSessionKeys);
        }
        else {
            // scenario 2 and 4
            const { publicKey: nextPublicKey, privateKey: nextPrivateKey, privateKeyJwk: nextPrivateKeyJwk, } = yield generateSessionKey();
            publicKey = nextPublicKey;
            privateKey = nextPrivateKey;
            privateKeyJwk = nextPrivateKeyJwk;
            prevSessionKeySignature = yield utils$1.p256Sign(decodedSessionKeys.privateKeyJwk, user$1.sessionId);
            utils.tracing.logEvent('session-key', 'Loaded prevSessionKeySignature', utils.tracing.formatObject({ nextPublicKey, prevSessionKeySignature }));
        }
        let resp;
        const primaryWalletId$1 = primaryWalletId.getPrimaryWalletId();
        if (!primaryWalletId$1) {
            throw new Error('Primary wallet ID not found');
        }
        const turnkeyWalletId = getPrimaryTurnkeyWalletId.getPrimaryTurnkeyWalletId(primaryWalletId$1, user$1.verifiedCredentials);
        try {
            resp = yield embeddedWallets.registerSessionKey({
                environmentId,
                prevSessionKeySignature,
                publicKey,
                walletId: turnkeyWalletId,
            });
        }
        catch (error) {
            if (error instanceof utils.InvalidEmbeddedWalletSessionKeyError) {
                // this can happen if the public key passed during initial registration
                // does not match the root session public key that the backend expects
                walletConnectorCore.logger.warn('Invalid embedded wallet session key. Re-authentication is required to create new session keys.');
                dynamicEvents.dynamicEvents.emit('triggerLogout');
            }
            throw error;
        }
        const expirationDate = new Date(resp.expiresAt * 1000);
        utils.tracing.logEvent('session-key', 'Created new session key', utils.tracing.formatObject({
            expirationDate,
            publicKey,
        }));
        utils.StorageService.setItem(localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS, toEncodedFormat(publicKey, privateKey, privateKeyJwk, true, expirationDate), localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        return { expirationDate, privateKey, publicKey };
    });
    const generateSessionKey = () => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        const { private: privateKey, public: publicKey, privateJwk, } = yield utils$1.p256Keygen();
        // convert to base64 and store the session keys in session storage
        utils.tracing.logEvent('session-key', 'Generated new session key', utils.tracing.formatObject({
            publicKey,
        }));
        utils.StorageService.setItem(localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS, toEncodedFormat(publicKey, privateKey, privateJwk, false), localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        return { privateKey, privateKeyJwk: privateJwk, publicKey };
    });
    const getSessionPublicKey = () => {
        const sessionKeysSS = utils.StorageService.getItem(localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS, localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
        const decodedSessionKeys = sessionKeysSS
            ? JSON.parse(Buffer.from(sessionKeysSS, 'base64').toString())
            : undefined;
        if (!(decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey)) {
            utils.tracing.logEvent('session-key', 'getSessionPublicKey', 'Could not find session keys.');
            throw new Error('Could not find session keys.');
        }
        utils.tracing.logEvent('session-key', 'getSessionPublicKey', utils.tracing.formatObject({
            publicKey: decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey,
        }));
        return decodedSessionKeys === null || decodedSessionKeys === void 0 ? void 0 : decodedSessionKeys.publicKey;
    };
    // this is a temporary fix to ensure that session keys are registered on signin for all wallets
    // the user is undefined at this point in the auth flow and we cant check the users wallet version
    // so we just return true for now
    const shouldRegisterSessionKeysOnSignin = () => true;
    const toEncodedFormat = (publicKey, privateKey, privateKeyJwk, registered, expirationDate) => {
        const sessionKeys = {
            expirationDate,
            privateKey,
            privateKeyJwk,
            publicKey,
            registered,
        };
        const sessionKeysString = JSON.stringify(sessionKeys);
        return Buffer.from(sessionKeysString).toString('base64');
    };
    const removeSessionKey = React.useCallback(() => {
        utils.tracing.logEvent('session-key', 'removeSessionKey');
        utils.StorageService.removeItem(localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS, localStorage.SECURE_ENCLAVE_WALLET_SESSION_KEYS_STORAGE_OPTIONS);
    }, []);
    return {
        generateSessionKey,
        getSessionPublicKey,
        registerEmbeddedWalletSessionKey,
        removeSessionKey,
        shouldRegisterSessionKeysOnSignin,
    };
};

exports.useEmbeddedWalletSessionKeys = useEmbeddedWalletSessionKeys;
