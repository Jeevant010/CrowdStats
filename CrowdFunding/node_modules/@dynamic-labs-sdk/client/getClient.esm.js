const getCore = (client)=>{
    // @ts-expect-error - this was hidden from the public API
    return client.__core;
};

/**
 * Shallow compare two objects.
 *
 * Source: https://github.com/pmndrs/zustand/blob/main/src/vanilla/shallow.ts
 */ const isEqualShallow = (objA, objB)=>{
    if (Object.is(objA, objB)) return true;
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
        return objA === objB;
    }
    if (objA instanceof Map && objB instanceof Map) {
        if (objA.size !== objB.size) return false;
        for (const [key, value] of objA){
            if (!Object.is(value, objB.get(key))) return false;
        }
        return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
        if (objA.size !== objB.size) return false;
        for (const value of objA){
            if (!objB.has(value)) return false;
        }
        return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) return false;
    for (const keyA of keysA){
        if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
            return false;
        }
    }
    if (objA.constructor !== objB.constructor) return false;
    return true;
};

/**
 * Allows subscribing to a slice of the state.
 * The slice is a computation of the states.
 *
 * The callback will only be called when the slice has changed.
 * Change is determined by shallow comparison.
 *
 * Returns a function to unsubscribe the callback.
 */ const subscribeWithSelector = (observable, selector)=>(callback)=>{
        let lastSlice = selector(observable.get());
        return observable.subscribe((value)=>{
            const nextSlice = selector(value);
            if (isEqualShallow(nextSlice, lastSlice)) return;
            lastSlice = nextSlice;
            callback(nextSlice);
        });
    };

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

var version = "0.0.1-alpha.5";
var dependencies = {
    "@dynamic-labs/sdk-api-core": "0.0.630"};

/**
 * Listen to an event from the client.
 *
 * @returns A function that can be called to remove the listener.
 */ const onEvent = (client, event, listener)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.on(event, listener);
    return ()=>{
        eventEmitter.off(event, listener);
    };
};
/**
 * Remove a listener from an event.
 */ const offEvent = (client, event, listener)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.off(event, listener);
};
/**
 * Listen to an event that will only fire once.
 *
 * @returns A function that can be called to remove the listener.
 */ const onceEvent = (client, event, listener)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.once(event, listener);
    return ()=>{
        eventEmitter.off(event, listener);
    };
};
/**
 * Emit an event.
 */ const emitEvent = (client, event, ...args)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.emit(event, ...args);
};

const getDetails = ({ details, cause })=>{
    if (cause instanceof BaseError) {
        return cause.details;
    }
    if (cause == null ? void 0 : cause.message) {
        return cause.message;
    }
    return details;
};
/**
 * Formats the error message with all available information
 */ const formatMessage = ({ shortMessage, details, docsUrl, metaMessages })=>{
    return [
        shortMessage,
        '',
        ...metaMessages ? [
            ...metaMessages,
            ''
        ] : [],
        ...docsUrl ? [
            `Docs: ${docsUrl}`
        ] : [],
        ...details ? [
            `Details: ${details}`
        ] : [],
        `Version: ${version}`,
        `Timestamp: ${new Date().toISOString()}`
    ].join('\n');
};
/**
 * Base error class that provides structured error handling with detailed information
 */ class BaseError extends Error {
    /**
   * Walks the cause chain of the error and returns the root error
   */ walk() {
        const cause = this.cause;
        if (cause instanceof BaseError) {
            return cause.walk();
        }
        return cause;
    }
    constructor(args){
        const details = getDetails(args);
        super(formatMessage(_extends({}, args, {
            details
        })), args.cause ? {
            cause: args.cause
        } : undefined);
        this.name = 'BaseError';
        this.details = details;
        var _args_name;
        this.name = (_args_name = args.name) != null ? _args_name : this.name;
        var _args_cause;
        this.cause = (_args_cause = args.cause) != null ? _args_cause : this.cause;
    }
}

class CannotTrackError extends BaseError {
    constructor(){
        super({
            cause: null,
            docsUrl: null,
            name: 'CannotTrackError',
            shortMessage: 'All track calls must be performed in the same node tick'
        });
    }
}

class InvalidStorageSet extends BaseError {
    constructor({ key, value }){
        super({
            cause: null,
            docsUrl: null,
            metaMessages: [
                `key: ${key}`,
                value
            ],
            name: 'InvalidStorageSet',
            shortMessage: 'Tried to store a value that does not match the schema'
        });
    }
}

class ClientNotPresentError extends BaseError {
    constructor(){
        super({
            cause: null,
            docsUrl: null,
            name: 'ClientNotPresentError',
            shortMessage: 'The client is not present in the target object.'
        });
    }
}

const getClient = (target)=>{
    if (!Object.prototype.hasOwnProperty.call(target, '__client')) {
        throw new ClientNotPresentError();
    }
    // @ts-expect-error - this was hidden from the public API
    return target.__client;
};

export { BaseError as B, CannotTrackError as C, InvalidStorageSet as I, _extends as _, getClient as a, onceEvent as b, onEvent as c, dependencies as d, emitEvent as e, ClientNotPresentError as f, getCore as g, isEqualShallow as i, offEvent as o, subscribeWithSelector as s, version as v };
