import { isAddress, checksumAddress, encodeFunctionData, decodeEventLog, zeroAddress, getAddress as getAddress$2, toFunctionSelector, keccak256, encodeAbiParameters, toHex, zeroHash, stringToHex, maxUint32, createPublicClient, createWalletClient } from 'viem';
import * as dotenv from 'dotenv';
import { defineChain } from 'viem/utils';

function toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

var iliad = defineChain({
  id: 1513,
  name: "iliad",
  nativeCurrency: {
    name: "IP",
    symbol: "IP",
    decimals: 18
  },
  rpcUrls: {
    "default": {
      http: ["https://testnet.storyrpc.io"],
      webSocket: ["wss://story-network.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    "default": {
      name: "Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    }
  },
  testnet: true
});

function chainStringToViemChain(chainId) {
  switch (chainId) {
    case "1513":
    case "iliad":
      return iliad;
    default:
      throw new Error("chainId ".concat(chainId, " not supported"));
  }
}
var chain = {
  iliad: 1513n,
  1513: 1513n
};
var getAddress$1 = function getAddress(address, name, chainId) {
  if (!isAddress(address, {
    strict: false
  })) {
    throw Error("".concat(name, " address is invalid: ").concat(address, ", Address must be a hex value of 20 bytes (40 hex characters) and match its checksum counterpart."));
  }
  return checksumAddress(address, chainId);
};

function handleError(error, msg) {
  if (error instanceof Error) {
    throw new Error("".concat(msg, ": ").concat(error.message));
  }
  throw new Error("".concat(msg, ": Unknown error type"));
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AccessController
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var accessControllerAbi = [{
  type: "constructor",
  inputs: [{
    name: "ipAccountRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "moduleRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }],
  name: "AccessController__BothCallerAndRecipientAreNotRegisteredModule"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__CallerIsNotIPAccountOrOwner"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessController__IPAccountIsNotValid"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__IPAccountIsZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "AccessController__PermissionDenied"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__PermissionIsNotValid"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__SignerIsZeroAddress"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ToAndFuncAreZeroAddressShouldCallSetAllPermissions"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ZeroIPAccountRegistry"
}, {
  type: "error",
  inputs: [],
  name: "AccessController__ZeroModuleRegistry"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipAccountOwner",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "ipAccount",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "signer",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4",
    indexed: false
  }, {
    name: "permission",
    internalType: "uint8",
    type: "uint8",
    indexed: false
  }],
  name: "PermissionSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MODULE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IModuleRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "checkPermission",
  outputs: [],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "getPermission",
  outputs: [{
    name: "",
    internalType: "uint8",
    type: "uint8"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "permission",
    internalType: "uint8",
    type: "uint8"
  }],
  name: "setAllPermissions",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "permissions",
    internalType: "struct AccessPermission.Permission[]",
    type: "tuple[]",
    components: [{
      name: "ipAccount",
      internalType: "address",
      type: "address"
    }, {
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "to",
      internalType: "address",
      type: "address"
    }, {
      name: "func",
      internalType: "bytes4",
      type: "bytes4"
    }, {
      name: "permission",
      internalType: "uint8",
      type: "uint8"
    }]
  }],
  name: "setBatchPermissions",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "func",
    internalType: "bytes4",
    type: "bytes4"
  }, {
    name: "permission",
    internalType: "uint8",
    type: "uint8"
  }],
  name: "setPermission",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 *
 */
var accessControllerAddress = {
  1513: "0x01d470c28822d3701Db6325333cEE9737524776E"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CoreMetadataModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var coreMetadataModuleAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAccountRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount"
}, {
  type: "error",
  inputs: [],
  name: "AccessControlled__ZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [],
  name: "CoreMetadataModule__MetadataAlreadyFrozen"
}, {
  type: "error",
  inputs: [],
  name: "CoreMetadataModule__ZeroAccessManager"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "MetadataFrozen"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "metadataURI",
    internalType: "string",
    type: "string",
    indexed: false
  }, {
    name: "metadataHash",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }],
  name: "MetadataURISet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "nftTokenURI",
    internalType: "string",
    type: "string",
    indexed: false
  }, {
    name: "nftMetadataHash",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }],
  name: "NFTTokenURISet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "freezeMetadata",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "isMetadataFrozen",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "pure"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "metadataURI",
    internalType: "string",
    type: "string"
  }, {
    name: "metadataHash",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "nftMetadataHash",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "setAll",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "metadataURI",
    internalType: "string",
    type: "string"
  }, {
    name: "metadataHash",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "setMetadataURI",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "nftMetadataHash",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "updateNftTokenURI",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 *
 */
var coreMetadataModuleAddress = {
  1513: "0x290F414EA46b361ECFB6b430F98346CB593D02b9"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DisputeModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var disputeModuleAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAssetRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount"
}, {
  type: "error",
  inputs: [],
  name: "AccessControlled__ZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotAbleToResolve"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotAllowedToWhitelist"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotDerivative"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotDisputeInitiator"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotInDisputeState"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotRegisteredIpId"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotWhitelistedArbitrationPolicy"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotWhitelistedArbitrationRelayer"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__NotWhitelistedDisputeTag"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ParentDisputeNotResolved"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ParentIpIdMismatch"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ParentNotTagged"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroAccessController"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroArbitrationPolicy"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroArbitrationRelayer"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroDisputeTag"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroIPAssetRegistry"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "DisputeModule__ZeroLinkToDisputeEvidence"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [{
    name: "str",
    internalType: "string",
    type: "string"
  }],
  name: "StringTooLong"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "ArbitrationPolicySet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "ArbitrationPolicyWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "arbitrationRelayer",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "ArbitrationRelayerWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "DefaultArbitrationPolicyUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "derivativeIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "parentDisputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "tag",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }],
  name: "DerivativeTaggedOnParentInfringement"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "DisputeCancelled"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "decision",
    internalType: "bool",
    type: "bool",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "DisputeJudgementSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "targetIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "disputeInitiator",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "linkToDisputeEvidence",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }, {
    name: "targetTag",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "DisputeRaised"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "DisputeResolved"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "tag",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "TagWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IN_DISPUTE",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ASSET_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAssetRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "arbitrationPolicies",
  outputs: [{
    name: "policy",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "baseArbitrationPolicy",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "cancelDispute",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "disputeCounter",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "disputes",
  outputs: [{
    name: "targetIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeInitiator",
    internalType: "address",
    type: "address"
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "linkToDisputeEvidence",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "targetTag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "currentTag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "parentDisputeId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "isIpTagged",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedArbitrationPolicy",
  outputs: [{
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "arbitrationRelayer",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedArbitrationRelayer",
  outputs: [{
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tag",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "isWhitelistedDisputeTag",
  outputs: [{
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "data",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  name: "multicall",
  outputs: [{
    name: "results",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "targetIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "linkToDisputeEvidence",
    internalType: "string",
    type: "string"
  }, {
    name: "targetTag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "raiseDispute",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "resolveDispute",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "setArbitrationPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "setBaseArbitrationPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "disputeId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "decision",
    internalType: "bool",
    type: "bool"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "setDisputeJudgement",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "derivativeIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentDisputeId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tagDerivativeIfParentInfringed",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistArbitrationPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "arbitrationPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "arbPolicyRelayer",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistArbitrationRelayer",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "tag",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistDisputeTag",
  outputs: [],
  stateMutability: "nonpayable"
}];

/**
 *
 */
var disputeModuleAddress = {
  1513: "0xDae11663438a0958E7075F604E3a5eEe77FD3878"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IPAccountImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var ipAccountImplAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAssetRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "moduleRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [],
  name: "FnSelectorNotRecognized"
}, {
  type: "error",
  inputs: [],
  name: "IPAccountStorage__InvalidBatchLengths"
}, {
  type: "error",
  inputs: [{
    name: "module",
    internalType: "address",
    type: "address"
  }],
  name: "IPAccountStorage__NotRegisteredModule"
}, {
  type: "error",
  inputs: [],
  name: "IPAccountStorage__ZeroIpAssetRegistry"
}, {
  type: "error",
  inputs: [],
  name: "IPAccountStorage__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "IPAccountStorage__ZeroModuleRegistry"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__ExpiredSignature"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__InvalidCalldata"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__InvalidOperation"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__InvalidSignature"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__InvalidSigner"
}, {
  type: "error",
  inputs: [],
  name: "IPAccount__ZeroAccessController"
}, {
  type: "error",
  inputs: [],
  name: "OperationNotSupported"
}, {
  type: "error",
  inputs: [],
  name: "SelfOwnDetected"
}, {
  type: "error",
  inputs: [],
  name: "Unauthorized"
}, {
  type: "error",
  inputs: [],
  name: "UnauthorizedCallContext"
}, {
  type: "error",
  inputs: [],
  name: "UpgradeFailed"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }, {
    name: "nonce",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }],
  name: "Executed"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }, {
    name: "nonce",
    internalType: "bytes32",
    type: "bytes32",
    indexed: false
  }, {
    name: "deadline",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "signer",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "signature",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "ExecutedWithSig"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "fallback",
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ASSET_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MODULE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "bytes32Data",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "bytesData",
  outputs: [{
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "eip712Domain",
  outputs: [{
    name: "fields",
    internalType: "bytes1",
    type: "bytes1"
  }, {
    name: "name",
    internalType: "string",
    type: "string"
  }, {
    name: "version",
    internalType: "string",
    type: "string"
  }, {
    name: "chainId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "verifyingContract",
    internalType: "address",
    type: "address"
  }, {
    name: "salt",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "extensions",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "operation",
    internalType: "uint8",
    type: "uint8"
  }],
  name: "execute",
  outputs: [{
    name: "result",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "execute",
  outputs: [{
    name: "result",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "calls",
    internalType: "struct ERC6551.Call[]",
    type: "tuple[]",
    components: [{
      name: "target",
      internalType: "address",
      type: "address"
    }, {
      name: "value",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "data",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "operation",
    internalType: "uint8",
    type: "uint8"
  }],
  name: "executeBatch",
  outputs: [{
    name: "results",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "deadline",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "signature",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "executeWithSig",
  outputs: [{
    name: "result",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes",
  outputs: [{
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "namespace",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes",
  outputs: [{
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "namespace",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes32",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "getBytes32",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "namespaces",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }, {
    name: "keys",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }],
  name: "getBytes32Batch",
  outputs: [{
    name: "values",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "namespaces",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }, {
    name: "keys",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }],
  name: "getBytesBatch",
  outputs: [{
    name: "values",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "hash",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "signature",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSignature",
  outputs: [{
    name: "result",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSigner",
  outputs: [{
    name: "result",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "signer",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "isValidSigner",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "owner",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "value",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "setBytes",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "key",
    internalType: "bytes32",
    type: "bytes32"
  }, {
    name: "value",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "setBytes32",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "keys",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }, {
    name: "values",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }],
  name: "setBytes32Batch",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "keys",
    internalType: "bytes32[]",
    type: "bytes32[]"
  }, {
    name: "values",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  name: "setBytesBatch",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "state",
  outputs: [{
    name: "result",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "token",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "receive",
  stateMutability: "payable"
}];

/**
 *
 */
var ipAccountImplAddress = {
  1513: "0x8F763c16753e830a8020c80f9F0131Eb8Ef52879"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IPAssetRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var ipAssetRegistryAbi = [{
  type: "constructor",
  inputs: [{
    name: "erc6551Registry",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAccountImpl",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "IPAccountRegistry_ZeroERC6551Registry"
}, {
  type: "error",
  inputs: [],
  name: "IPAccountRegistry_ZeroIpAccountImpl"
}, {
  type: "error",
  inputs: [],
  name: "IPAssetRegistry__AlreadyRegistered"
}, {
  type: "error",
  inputs: [{
    name: "contractAddress",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "IPAssetRegistry__InvalidToken"
}, {
  type: "error",
  inputs: [{
    name: "contractAddress",
    internalType: "address",
    type: "address"
  }],
  name: "IPAssetRegistry__UnsupportedIERC721"
}, {
  type: "error",
  inputs: [{
    name: "contractAddress",
    internalType: "address",
    type: "address"
  }],
  name: "IPAssetRegistry__UnsupportedIERC721Metadata"
}, {
  type: "error",
  inputs: [],
  name: "IPAssetRegistry__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [{
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "length",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "StringsInsufficientHexLength"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "chainId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "IPAccountRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "chainId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "name",
    internalType: "string",
    type: "string",
    indexed: false
  }, {
    name: "uri",
    internalType: "string",
    type: "string",
    indexed: false
  }, {
    name: "registrationDate",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "IPRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ERC6551_PUBLIC_REGISTRY",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_IMPL",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_SALT",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getIPAccountImpl",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "chainId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ipAccount",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "chainId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ipId",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "id",
    internalType: "address",
    type: "address"
  }],
  name: "isRegistered",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "chainid",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "register",
  outputs: [{
    name: "id",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 *
 */
var ipAssetRegistryAddress = {
  1513: "0xe34A78B3d658aF7ad69Ff1EFF9012ECa025a14Be"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IpRoyaltyVaultImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var ipRoyaltyVaultImplAbi = [{
  type: "constructor",
  inputs: [{
    name: "royaltyPolicyLAP",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__AlreadyClaimed"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__ClaimerNotAnAncestor"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__IpGraphCallFailed"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__IpTagged"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__NotRoyaltyPolicyLAP"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__SnapshotIntervalTooShort"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "IpRoyaltyVault__ZeroRoyaltyPolicyLAP"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "spender",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "Approval"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint8",
    type: "uint8",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "claimer",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "RevenueTokenClaimed"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "royaltyTokensCollected",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "RoyaltyTokensCollected"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "id",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "Snapshot"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "snapshotTimestamp",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "unclaimedTokens",
    internalType: "uint32",
    type: "uint32",
    indexed: false
  }],
  name: "SnapshotCompleted"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "value",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "Transfer"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_GRAPH_CONTRACT",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_POLICY_LAP",
  outputs: [{
    name: "",
    internalType: "contract IRoyaltyPolicyLAP",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "addIpRoyaltyVaultTokens",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "spender",
    internalType: "address",
    type: "address"
  }],
  name: "allowance",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "ancestorsVaultAmount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "spender",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "approve",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }, {
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "balanceOfAt",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimRevenueBySnapshotBatch",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "tokenList",
    internalType: "address[]",
    type: "address[]"
  }],
  name: "claimRevenueByTokenBatch",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimVaultAmount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimableAtSnapshot",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }, {
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "claimableRevenue",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "_tokens",
    internalType: "address[]",
    type: "address[]"
  }],
  name: "collectAccruedTokens",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address"
  }],
  name: "collectRoyaltyTokens",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "collectableAmount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "decimals",
  outputs: [{
    name: "",
    internalType: "uint8",
    type: "uint8"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "spender",
    internalType: "address",
    type: "address"
  }, {
    name: "subtractedValue",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "decreaseAllowance",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "spender",
    internalType: "address",
    type: "address"
  }, {
    name: "addedValue",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "increaseAllowance",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "name",
    internalType: "string",
    type: "string"
  }, {
    name: "symbol",
    internalType: "string",
    type: "string"
  }, {
    name: "supply",
    internalType: "uint32",
    type: "uint32"
  }, {
    name: "unclaimedTokens",
    internalType: "uint32",
    type: "uint32"
  }, {
    name: "ipIdAddress",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "ipId",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "claimer",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "isClaimedAtSnapshot",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ancestorIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isCollectedByAncestor",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "lastSnapshotTimestamp",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "snapshot",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "tokens",
  outputs: [{
    name: "",
    internalType: "address[]",
    type: "address[]"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "totalSupplyAt",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "transfer",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "snapshotId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "unclaimedAtSnapshot",
  outputs: [{
    name: "",
    internalType: "uint32",
    type: "uint32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unclaimedRoyaltyTokens",
  outputs: [{
    name: "",
    internalType: "uint32",
    type: "uint32"
  }],
  stateMutability: "view"
}];

/**
 *
 */
var ipRoyaltyVaultImplAddress = {
  1513: "0xfb5b5B61c9a437E06Ba87367aaBf3766d091E3D1"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LicenseRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var licenseRegistryAbi = [{
  type: "constructor",
  inputs: [{
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }, {
    name: "ipGraphAcl",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }],
  name: "LicenseRegistry__AddParentIpToIPGraphFailed"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__CallerNotLicensingModule"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__DerivativeAlreadyRegistered"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__DerivativeIpAlreadyHasChild"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__DerivativeIpAlreadyHasLicense"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__DerivativeIsParent"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__DuplicateLicense"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "length",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__IndexOutOfBounds"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__IpExpired"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__LicenseTermsAlreadyAttached"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__LicenseTermsNotExists"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__LicensorIpHasNoLicenseTerms"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__NotLicenseTemplate"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__ParentIpExpired"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseRegistry__ParentIpHasNoLicenseTerms"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__ParentIpTagged"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__ParentIpUnmatchedLicenseTemplate"
}, {
  type: "error",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "newLicenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__UnmatchedLicenseTemplate"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseRegistry__UnregisteredLicenseTemplate"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroIPGraphACL"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroLicenseTemplate"
}, {
  type: "error",
  inputs: [],
  name: "LicenseRegistry__ZeroLicensingModule"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__DerivativesCannotAddLicenseTerms"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicensingModule__LicenseTermsNotFound"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "DefaultLicenseTermsSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "expireTime",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "ExpirationTimeSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "LicenseTemplateRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }],
    indexed: false
  }],
  name: "LicensingConfigSetForIP"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "LicensingConfigSetForLicense"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "EXPIRATION_TIME",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_GRAPH_ACL",
  outputs: [{
    name: "",
    internalType: "contract IPGraphACL",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_GRAPH_CONTRACT",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "attachLicenseTermsToIp",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "exists",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getAttachedLicenseTerms",
  outputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "getAttachedLicenseTermsCount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getDefaultLicenseTerms",
  outputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getDerivativeIp",
  outputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }],
  name: "getDerivativeIpCount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "getExpireTime",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicensingConfig",
  outputs: [{
    name: "",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getParentIp",
  outputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "getParentIpCount",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }],
  name: "hasDerivativeIps",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "hasIpAttachedLicenseTerms",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isDerivativeIp",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "isExpiredNow",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isParentIp",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "isRegisteredLicenseTemplate",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "isUsingLicenseToken",
    internalType: "bool",
    type: "bool"
  }],
  name: "registerDerivativeIp",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "registerLicenseTemplate",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newLicenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "newLicenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "setDefaultLicenseTerms",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "setLicensingConfigForIp",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "setLicensingConfigForLicense",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "isMintedByIpOwner",
    internalType: "bool",
    type: "bool"
  }],
  name: "verifyMintLicenseToken",
  outputs: [{
    name: "",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  stateMutability: "view"
}];

/**
 *
 */
var licenseRegistryAddress = {
  1513: "0xF542AF9a5A6E4A85a4f084D38B322516ec336097"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LicenseToken
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var licenseTokenAbi = [{
  type: "constructor",
  inputs: [{
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "ERC721EnumerableForbiddenBatchMint"
}, {
  type: "error",
  inputs: [{
    name: "sender",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721IncorrectOwner"
}, {
  type: "error",
  inputs: [{
    name: "operator",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ERC721InsufficientApproval"
}, {
  type: "error",
  inputs: [{
    name: "approver",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidApprover"
}, {
  type: "error",
  inputs: [{
    name: "operator",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidOperator"
}, {
  type: "error",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidOwner"
}, {
  type: "error",
  inputs: [{
    name: "receiver",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidReceiver"
}, {
  type: "error",
  inputs: [{
    name: "sender",
    internalType: "address",
    type: "address"
  }],
  name: "ERC721InvalidSender"
}, {
  type: "error",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ERC721NonexistentToken"
}, {
  type: "error",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ERC721OutOfBoundsIndex"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "anotherLicenseTemplate",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseToken__AllLicenseTokensMustFromSameLicenseTemplate"
}, {
  type: "error",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "childIpIp",
    internalType: "address",
    type: "address"
  }, {
    name: "actualTokenOwner",
    internalType: "address",
    type: "address"
  }],
  name: "LicenseToken__CallerAndChildIPNotTokenOwner"
}, {
  type: "error",
  inputs: [],
  name: "LicenseToken__CallerNotLicensingModule"
}, {
  type: "error",
  inputs: [],
  name: "LicenseToken__NotTransferable"
}, {
  type: "error",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicenseToken__RevokedLicense"
}, {
  type: "error",
  inputs: [],
  name: "LicenseToken__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [{
    name: "value",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "length",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "StringsInsufficientHexLength"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "approved",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "Approval"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "operator",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "ApprovalForAll"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "_fromTokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "_toTokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "BatchMetadataUpdate"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "minter",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "receiver",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "LicenseTokenMinted"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "to",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }],
  name: "Transfer"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "approve",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "balanceOf",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "holder",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "burnLicenseTokens",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getApproved",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTemplate",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTermsId",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTokenMetadata",
  outputs: [{
    name: "",
    internalType: "struct ILicenseToken.LicenseTokenMetadata",
    type: "tuple",
    components: [{
      name: "licensorIpId",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTemplate",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTermsId",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }]
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicensorIpId",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }, {
    name: "imageUrl",
    internalType: "string",
    type: "string"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "operator",
    internalType: "address",
    type: "address"
  }],
  name: "isApprovedForAll",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "isLicenseTokenRevoked",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "minter",
    internalType: "address",
    type: "address"
  }, {
    name: "receiver",
    internalType: "address",
    type: "address"
  }],
  name: "mintLicenseTokens",
  outputs: [{
    name: "startLicenseTokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "ownerOf",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "safeTransferFrom",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "operator",
    internalType: "address",
    type: "address"
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool"
  }],
  name: "setApprovalForAll",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "url",
    internalType: "string",
    type: "string"
  }],
  name: "setLicensingImageUrl",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "symbol",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tokenByIndex",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "owner",
    internalType: "address",
    type: "address"
  }, {
    name: "index",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tokenOfOwnerByIndex",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "id",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "tokenURI",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalMintedTokens",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalSupply",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "from",
    internalType: "address",
    type: "address"
  }, {
    name: "to",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "transferFrom",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "validateLicenseTokensForDerivative",
  outputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licensorIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  stateMutability: "view"
}];

/**
 *
 */
var licenseTokenAddress = {
  1513: "0xB31FE33De46A1FA5d4Ec669EDB049892E0A1EB4C"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LicensingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var licensingModuleAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAccountRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "moduleRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseToken",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount"
}, {
  type: "error",
  inputs: [],
  name: "AccessControlled__ZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__DisputedIpId"
}, {
  type: "error",
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "anotherRoyaltyPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__IncompatibleRoyaltyPolicy"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicensingModule__InvalidLicenseTermsId"
}, {
  type: "error",
  inputs: [{
    name: "hook",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__InvalidLicensingHook"
}, {
  type: "error",
  inputs: [{
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__LicenseDenyMintLicenseToken"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "LicensingModule__LicenseNotCompatibleForDerivative"
}, {
  type: "error",
  inputs: [{
    name: "ipLength",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licenseTermsLength",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "LicensingModule__LicenseTermsLengthMismatch"
}, {
  type: "error",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "LicensingModule__LicenseTokenNotCompatibleForDerivative"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__LicensorIpNotRegistered"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__MintAmountZero"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__NoLicenseToken"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__NoParentIp"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ReceiverZeroAddress"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroLicenseToken"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroModuleRegistry"
}, {
  type: "error",
  inputs: [],
  name: "LicensingModule__ZeroRoyaltyModule"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]",
    indexed: false
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]",
    indexed: false
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]",
    indexed: false
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "DerivativeRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "LicenseTermsAttached"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licensorIpId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }, {
    name: "receiver",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "startLicenseTokenId",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "LicenseTokensMinted"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_NFT",
  outputs: [{
    name: "",
    internalType: "contract ILicenseToken",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MODULE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IModuleRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_MODULE",
  outputs: [{
    name: "",
    internalType: "contract RoyaltyModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "attachLicenseTerms",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "receiver",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "mintLicenseTokens",
  outputs: [{
    name: "startLicenseTokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "registerDerivative",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "registerDerivativeWithLicenseTokens",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensingConfig",
    internalType: "struct Licensing.LicensingConfig",
    type: "tuple",
    components: [{
      name: "isSet",
      internalType: "bool",
      type: "bool"
    }, {
      name: "mintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "licensingHook",
      internalType: "address",
      type: "address"
    }, {
      name: "hookData",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "setLicensingConfig",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 *
 */
var licensingModuleAddress = {
  1513: "0xf49da534215DA7b48E57A41d41dac25C912FCC60"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PILicenseTemplate
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var piLicenseTemplateAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAccountRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyModule",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "ipAccount",
    internalType: "address",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount"
}, {
  type: "error",
  inputs: [],
  name: "AccessControlled__ZeroAddress"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddAttribution"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddCommercializers"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddDerivativeRevCeiling"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddRevCeiling"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddRevShare"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialDisabled_CantAddRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CommercialEnabled_RoyaltyPolicyRequired"
}, {
  type: "error",
  inputs: [{
    name: "checker",
    internalType: "address",
    type: "address"
  }],
  name: "PILicenseTemplate__CommercializerCheckerDoesNotSupportHook"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__CurrencyTokenNotWhitelisted"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__DerivativesDisabled_CantAddApproval"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__DerivativesDisabled_CantAddAttribution"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__DerivativesDisabled_CantAddDerivativeRevCeiling"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__DerivativesDisabled_CantAddReciprocal"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__RoyaltyPolicyNotWhitelisted"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__RoyaltyPolicyRequiresCurrencyToken"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "PILicenseTemplate__ZeroRoyaltyModule"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "caller",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "DerivativeApproved"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256",
    indexed: true
  }, {
    name: "licenseTemplate",
    internalType: "address",
    type: "address",
    indexed: true
  }, {
    name: "licenseTerms",
    internalType: "bytes",
    type: "bytes",
    indexed: false
  }],
  name: "LicenseTermsRegistered"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ACCOUNT_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAccountRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IRoyaltyModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "TERMS_RENDERER",
  outputs: [{
    name: "",
    internalType: "contract PILTermsRenderer",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "exists",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "start",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getEarlierExpireTime",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "start",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getExpireTime",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "selectedLicenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTerms",
  outputs: [{
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "defaultMintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "defaultMintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "getLicenseTermsId",
  outputs: [{
    name: "selectedLicenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getLicenseTermsURI",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getMetadataURI",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "getRoyaltyPolicy",
  outputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyData",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "mintingFee",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "currency",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }, {
    name: "name",
    internalType: "string",
    type: "string"
  }, {
    name: "metadataURI",
    internalType: "string",
    type: "string"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address"
  }],
  name: "isDerivativeApproved",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "isLicenseTransferable",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "defaultMintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "registerLicenseTerms",
  outputs: [{
    name: "id",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "approved",
    internalType: "bool",
    type: "bool"
  }],
  name: "setApproval",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "toJson",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "totalRegisteredLicenseTerms",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }],
  name: "verifyCompatibleLicenses",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensee",
    internalType: "address",
    type: "address"
  }, {
    name: "licensorIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "verifyMintLicenseToken",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licensee",
    internalType: "address",
    type: "address"
  }],
  name: "verifyRegisterDerivative",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "childIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseTermsIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "childIpOwner",
    internalType: "address",
    type: "address"
  }],
  name: "verifyRegisterDerivativeForAllParents",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "nonpayable"
}];

/**
 *
 */
var piLicenseTemplateAddress = {
  1513: "0x8BB1ADE72E21090Fc891e1d4b88AC5E57b27cB31"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// RoyaltyModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var royaltyModuleAbi = [{
  type: "constructor",
  inputs: [{
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "disputeModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__CanOnlyMintSelectedPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__IncompatibleRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__IpIsExpired"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__IpIsTagged"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NoParentsOnLinking"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NoRoyaltyPolicySet"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NotAllowedCaller"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NotWhitelistedRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__NotWhitelistedRoyaltyToken"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroDisputeModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroLicenseRegistry"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroLicensingModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroRoyaltyPolicy"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyModule__ZeroRoyaltyToken"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "payerAddress",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "LicenseMintingFeePaid"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "payerIpId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "sender",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "RoyaltyPaid"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "RoyaltyPolicyWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool",
    indexed: false
  }],
  name: "RoyaltyTokenWhitelistUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "DISPUTE_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IDisputeModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedRoyaltyPolicy",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "isWhitelistedRoyaltyToken",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "name",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseData",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLicenseMinting",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseData",
    internalType: "bytes[]",
    type: "bytes[]"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLinkToParents",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "payerAddress",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRoyaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "payLicenseMintingFee",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "receiverIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "payerIpId",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "payRoyaltyOnBehalf",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "royaltyPolicies",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "interfaceId",
    internalType: "bytes4",
    type: "bytes4"
  }],
  name: "supportsInterface",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "royaltyPolicy",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistRoyaltyPolicy",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "allowed",
    internalType: "bool",
    type: "bool"
  }],
  name: "whitelistRoyaltyToken",
  outputs: [],
  stateMutability: "nonpayable"
}];

/**
 *
 */
var royaltyModuleAddress = {
  1513: "0x968beb5432c362c12b5Be6967a5d6F1ED5A63F01"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// RoyaltyPolicyLAP
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var royaltyPolicyLapAbi = [{
  type: "constructor",
  inputs: [{
    name: "royaltyModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "ipGraphAcl",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }],
  name: "AddressInsufficientBalance"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "EnforcedPause"
}, {
  type: "error",
  inputs: [],
  name: "ExpectedPause"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [],
  name: "ReentrancyGuardReentrantCall"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveAncestorsLimit"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveParentLimit"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveRoyaltyStackLimit"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__LastPositionNotAbleToMintLicense"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__NotRoyaltyModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__UnlinkableToParents"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroAccessManager"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroIPGraphACL"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroIpRoyaltyVaultBeacon"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroLicensingModule"
}, {
  type: "error",
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroRoyaltyModule"
}, {
  type: "error",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "SafeERC20FailedOperation"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "beacon",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "IpRoyaltyVaultBeaconSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Paused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "ipRoyaltyVault",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "royaltyStack",
    internalType: "uint32",
    type: "uint32",
    indexed: false
  }],
  name: "PolicyInitialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address",
    indexed: false
  }, {
    name: "vault",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "RevenueTokenAddedToVault"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "interval",
    internalType: "uint256",
    type: "uint256",
    indexed: false
  }],
  name: "SnapshotIntervalSet"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "Unpaused"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "IP_GRAPH_ACL",
  outputs: [{
    name: "",
    internalType: "contract IPGraphACL",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_GRAPH_CONTRACT",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MAX_ANCESTORS",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "MAX_PARENTS",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_MODULE",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "TOTAL_RT_SUPPLY",
  outputs: [{
    name: "",
    internalType: "uint32",
    type: "uint32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "__ProtocolPausable_init",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getIpRoyaltyVaultBeacon",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  name: "getRoyaltyData",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint32",
    type: "uint32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "getSnapshotInterval",
  outputs: [{
    name: "",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseData",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLicenseMinting",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "parentIpIds",
    internalType: "address[]",
    type: "address[]"
  }, {
    name: "licenseData",
    internalType: "bytes[]",
    type: "bytes[]"
  }, {
    name: "externalData",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onLinkToParents",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "token",
    internalType: "address",
    type: "address"
  }, {
    name: "amount",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "onRoyaltyPayment",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "pause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "paused",
  outputs: [{
    name: "",
    internalType: "bool",
    type: "bool"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "beacon",
    internalType: "address",
    type: "address"
  }],
  name: "setIpRoyaltyVaultBeacon",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "timestampInterval",
    internalType: "uint256",
    type: "uint256"
  }],
  name: "setSnapshotInterval",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "unpause",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}, {
  type: "function",
  inputs: [{
    name: "newVault",
    internalType: "address",
    type: "address"
  }],
  name: "upgradeVaults",
  outputs: [],
  stateMutability: "nonpayable"
}];

/**
 *
 */
var royaltyPolicyLapAddress = {
  1513: "0x61A5c7570f5bDB118D65053Ba60DE87e050E664e"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SPG
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 */
var spgAbi = [{
  type: "constructor",
  inputs: [{
    name: "accessController",
    internalType: "address",
    type: "address"
  }, {
    name: "ipAssetRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "licensingModule",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseRegistry",
    internalType: "address",
    type: "address"
  }, {
    name: "royaltyModule",
    internalType: "address",
    type: "address"
  }, {
    name: "coreMetadataModule",
    internalType: "address",
    type: "address"
  }, {
    name: "pilTemplate",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseToken",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "error",
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedInvalidAuthority"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "delay",
    internalType: "uint32",
    type: "uint32"
  }],
  name: "AccessManagedRequiredDelay"
}, {
  type: "error",
  inputs: [{
    name: "caller",
    internalType: "address",
    type: "address"
  }],
  name: "AccessManagedUnauthorized"
}, {
  type: "error",
  inputs: [{
    name: "target",
    internalType: "address",
    type: "address"
  }],
  name: "AddressEmptyCode"
}, {
  type: "error",
  inputs: [{
    name: "account",
    internalType: "address",
    type: "address"
  }],
  name: "AddressInsufficientBalance"
}, {
  type: "error",
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address"
  }],
  name: "ERC1967InvalidImplementation"
}, {
  type: "error",
  inputs: [],
  name: "ERC1967NonPayable"
}, {
  type: "error",
  inputs: [],
  name: "FailedInnerCall"
}, {
  type: "error",
  inputs: [],
  name: "InvalidInitialization"
}, {
  type: "error",
  inputs: [],
  name: "NotInitializing"
}, {
  type: "error",
  inputs: [{
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "caller",
    internalType: "address",
    type: "address"
  }, {
    name: "actualTokenOwner",
    internalType: "address",
    type: "address"
  }],
  name: "SPG__CallerAndNotTokenOwner"
}, {
  type: "error",
  inputs: [],
  name: "SPG__CallerNotMinterRole"
}, {
  type: "error",
  inputs: [],
  name: "SPG__EmptyLicenseTokens"
}, {
  type: "error",
  inputs: [],
  name: "SPG__ZeroAddressParam"
}, {
  type: "error",
  inputs: [{
    name: "token",
    internalType: "address",
    type: "address"
  }],
  name: "SafeERC20FailedOperation"
}, {
  type: "error",
  inputs: [],
  name: "UUPSUnauthorizedCallContext"
}, {
  type: "error",
  inputs: [{
    name: "slot",
    internalType: "bytes32",
    type: "bytes32"
  }],
  name: "UUPSUnsupportedProxiableUUID"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "authority",
    internalType: "address",
    type: "address",
    indexed: false
  }],
  name: "AuthorityUpdated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "CollectionCreated"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "version",
    internalType: "uint64",
    type: "uint64",
    indexed: false
  }],
  name: "Initialized"
}, {
  type: "event",
  anonymous: false,
  inputs: [{
    name: "implementation",
    internalType: "address",
    type: "address",
    indexed: true
  }],
  name: "Upgraded"
}, {
  type: "function",
  inputs: [],
  name: "ACCESS_CONTROLLER",
  outputs: [{
    name: "",
    internalType: "contract IAccessController",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "CORE_METADATA_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ICoreMetadataModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "IP_ASSET_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract IIPAssetRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_REGISTRY",
  outputs: [{
    name: "",
    internalType: "contract ILicenseRegistry",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSE_TOKEN",
  outputs: [{
    name: "",
    internalType: "contract ILicenseToken",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "LICENSING_MODULE",
  outputs: [{
    name: "",
    internalType: "contract ILicensingModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "PIL_TEMPLATE",
  outputs: [{
    name: "",
    internalType: "contract IPILicenseTemplate",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "ROYALTY_MODULE",
  outputs: [{
    name: "",
    internalType: "contract IRoyaltyModule",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "UPGRADE_INTERFACE_VERSION",
  outputs: [{
    name: "",
    internalType: "string",
    type: "string"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [],
  name: "authority",
  outputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "name",
    internalType: "string",
    type: "string"
  }, {
    name: "symbol",
    internalType: "string",
    type: "string"
  }, {
    name: "maxSupply",
    internalType: "uint32",
    type: "uint32"
  }, {
    name: "mintFee",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "mintFeeToken",
    internalType: "address",
    type: "address"
  }, {
    name: "owner",
    internalType: "address",
    type: "address"
  }],
  name: "createCollection",
  outputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "accessManager",
    internalType: "address",
    type: "address"
  }],
  name: "initialize",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "isConsumingScheduledOp",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }],
  name: "mintAndRegisterIp",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "defaultMintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "mintAndRegisterIpAndAttachPILTerms",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "derivData",
    internalType: "struct IStoryProtocolGateway.MakeDerivative",
    type: "tuple",
    components: [{
      name: "parentIpIds",
      internalType: "address[]",
      type: "address[]"
    }, {
      name: "licenseTemplate",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTermsIds",
      internalType: "uint256[]",
      type: "uint256[]"
    }, {
      name: "royaltyContext",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }],
  name: "mintAndRegisterIpAndMakeDerivative",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "recipient",
    internalType: "address",
    type: "address"
  }],
  name: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "data",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  name: "multicall",
  outputs: [{
    name: "results",
    internalType: "bytes[]",
    type: "bytes[]"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "address",
    type: "address"
  }, {
    name: "",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "onERC721Received",
  outputs: [{
    name: "",
    internalType: "bytes4",
    type: "bytes4"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [],
  name: "proxiableUUID",
  outputs: [{
    name: "",
    internalType: "bytes32",
    type: "bytes32"
  }],
  stateMutability: "view"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "sigMetadata",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "registerIp",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "defaultMintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }, {
    name: "sigMetadata",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "sigAttach",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "registerIpAndAttachPILTerms",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "derivData",
    internalType: "struct IStoryProtocolGateway.MakeDerivative",
    type: "tuple",
    components: [{
      name: "parentIpIds",
      internalType: "address[]",
      type: "address[]"
    }, {
      name: "licenseTemplate",
      internalType: "address",
      type: "address"
    }, {
      name: "licenseTermsIds",
      internalType: "uint256[]",
      type: "uint256[]"
    }, {
      name: "royaltyContext",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "sigMetadata",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "sigRegister",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "registerIpAndMakeDerivative",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "nftContract",
    internalType: "address",
    type: "address"
  }, {
    name: "tokenId",
    internalType: "uint256",
    type: "uint256"
  }, {
    name: "licenseTokenIds",
    internalType: "uint256[]",
    type: "uint256[]"
  }, {
    name: "royaltyContext",
    internalType: "bytes",
    type: "bytes"
  }, {
    name: "ipMetadata",
    internalType: "struct IStoryProtocolGateway.IPMetadata",
    type: "tuple",
    components: [{
      name: "ipMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "ipMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }, {
      name: "nftMetadataURI",
      internalType: "string",
      type: "string"
    }, {
      name: "nftMetadataHash",
      internalType: "bytes32",
      type: "bytes32"
    }]
  }, {
    name: "sigMetadata",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }, {
    name: "sigRegister",
    internalType: "struct IStoryProtocolGateway.SignatureData",
    type: "tuple",
    components: [{
      name: "signer",
      internalType: "address",
      type: "address"
    }, {
      name: "deadline",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "signature",
      internalType: "bytes",
      type: "bytes"
    }]
  }],
  name: "registerIpAndMakeDerivativeWithLicenseTokens",
  outputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "ipId",
    internalType: "address",
    type: "address"
  }, {
    name: "terms",
    internalType: "struct PILTerms",
    type: "tuple",
    components: [{
      name: "transferable",
      internalType: "bool",
      type: "bool"
    }, {
      name: "royaltyPolicy",
      internalType: "address",
      type: "address"
    }, {
      name: "defaultMintingFee",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "expiration",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "commercialUse",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercialAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "commercializerChecker",
      internalType: "address",
      type: "address"
    }, {
      name: "commercializerCheckerData",
      internalType: "bytes",
      type: "bytes"
    }, {
      name: "commercialRevShare",
      internalType: "uint32",
      type: "uint32"
    }, {
      name: "commercialRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "derivativesAllowed",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesAttribution",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesApproval",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativesReciprocal",
      internalType: "bool",
      type: "bool"
    }, {
      name: "derivativeRevCeiling",
      internalType: "uint256",
      type: "uint256"
    }, {
      name: "currency",
      internalType: "address",
      type: "address"
    }, {
      name: "uri",
      internalType: "string",
      type: "string"
    }]
  }],
  name: "registerPILTermsAndAttach",
  outputs: [{
    name: "licenseTermsId",
    internalType: "uint256",
    type: "uint256"
  }],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newAuthority",
    internalType: "address",
    type: "address"
  }],
  name: "setAuthority",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newNftContractBeacon",
    internalType: "address",
    type: "address"
  }],
  name: "setNftContractBeacon",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newNftContract",
    internalType: "address",
    type: "address"
  }],
  name: "upgradeCollections",
  outputs: [],
  stateMutability: "nonpayable"
}, {
  type: "function",
  inputs: [{
    name: "newImplementation",
    internalType: "address",
    type: "address"
  }, {
    name: "data",
    internalType: "bytes",
    type: "bytes"
  }],
  name: "upgradeToAndCall",
  outputs: [],
  stateMutability: "payable"
}];

/**
 *
 */
var spgAddress = {
  1513: "0x69415CE984A79a3Cfbe3F51024C63b6C107331e3"
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SDK
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// COMMON =============================================================

function getAddress(address, chainId) {
  return address[chainId || 0] || "0x";
}

// Contract AccessController =============================================================

/**
 * AccessControllerPermissionSetEvent
 *
 * @param ipAccountOwner address
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 */

/**
 * AccessControllerSetAllPermissionsRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param permission uint8
 */

/**
 * AccessControllerSetBatchPermissionsRequest
 *
 * @param permissions tuple[]
 */

/**
 * AccessControllerSetPermissionRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 */

/**
 * contract AccessController event
 */
var AccessControllerEventClient = /*#__PURE__*/function () {
  function AccessControllerEventClient(rpcClient, address) {
    var _rpcClient$chain;
    _classCallCheck(this, AccessControllerEventClient);
    this.address = address || getAddress(accessControllerAddress, (_rpcClient$chain = rpcClient.chain) === null || _rpcClient$chain === void 0 ? void 0 : _rpcClient$chain.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event PermissionSet for contract AccessController
   */
  return _createClass(AccessControllerEventClient, [{
    key: "watchPermissionSetEvent",
    value: function watchPermissionSetEvent(_onLogs) {
      return this.rpcClient.watchContractEvent({
        abi: accessControllerAbi,
        address: this.address,
        eventName: "PermissionSet",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event PermissionSet for contract AccessController
     */
  }, {
    key: "parseTxPermissionSetEvent",
    value: function parseTxPermissionSetEvent(txReceipt) {
      var targetLogs = [];
      var _iterator = _createForOfIteratorHelper(txReceipt.logs),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var log = _step.value;
          try {
            var event = decodeEventLog({
              abi: accessControllerAbi,
              eventName: "PermissionSet",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "PermissionSet") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract AccessController write method
 */
var AccessControllerClient = /*#__PURE__*/function (_AccessControllerEven) {
  function AccessControllerClient(rpcClient, wallet, address) {
    var _this;
    _classCallCheck(this, AccessControllerClient);
    _this = _callSuper(this, AccessControllerClient, [rpcClient, address]);
    _this.wallet = wallet;
    return _this;
  }

  /**
   * method setAllPermissions for contract AccessController
   *
   * @param request AccessControllerSetAllPermissionsRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(AccessControllerClient, _AccessControllerEven);
  return _createClass(AccessControllerClient, [{
    key: "setAllPermissions",
    value: (function () {
      var _setAllPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _yield$this$rpcClient, call;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.rpcClient.simulateContract({
                abi: accessControllerAbi,
                address: this.address,
                functionName: "setAllPermissions",
                account: this.wallet.account,
                args: [request.ipAccount, request.signer, request.permission]
              });
            case 2:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context.abrupt("return", _context.sent);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function setAllPermissions(_x) {
        return _setAllPermissions.apply(this, arguments);
      }
      return setAllPermissions;
    }()
    /**
     * method setAllPermissions for contract AccessController with only encode
     *
     * @param request AccessControllerSetAllPermissionsRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setAllPermissionsEncode",
    value: function setAllPermissionsEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: accessControllerAbi,
          functionName: "setAllPermissions",
          args: [request.ipAccount, request.signer, request.permission]
        })
      };
    }

    /**
     * method setBatchPermissions for contract AccessController
     *
     * @param request AccessControllerSetBatchPermissionsRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "setBatchPermissions",
    value: (function () {
      var _setBatchPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _yield$this$rpcClient2, call;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.rpcClient.simulateContract({
                abi: accessControllerAbi,
                address: this.address,
                functionName: "setBatchPermissions",
                account: this.wallet.account,
                args: [request.permissions]
              });
            case 2:
              _yield$this$rpcClient2 = _context2.sent;
              call = _yield$this$rpcClient2.request;
              _context2.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context2.abrupt("return", _context2.sent);
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function setBatchPermissions(_x2) {
        return _setBatchPermissions.apply(this, arguments);
      }
      return setBatchPermissions;
    }()
    /**
     * method setBatchPermissions for contract AccessController with only encode
     *
     * @param request AccessControllerSetBatchPermissionsRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setBatchPermissionsEncode",
    value: function setBatchPermissionsEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: accessControllerAbi,
          functionName: "setBatchPermissions",
          args: [request.permissions]
        })
      };
    }

    /**
     * method setPermission for contract AccessController
     *
     * @param request AccessControllerSetPermissionRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "setPermission",
    value: (function () {
      var _setPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _yield$this$rpcClient3, call;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.rpcClient.simulateContract({
                abi: accessControllerAbi,
                address: this.address,
                functionName: "setPermission",
                account: this.wallet.account,
                args: [request.ipAccount, request.signer, request.to, request.func, request.permission]
              });
            case 2:
              _yield$this$rpcClient3 = _context3.sent;
              call = _yield$this$rpcClient3.request;
              _context3.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context3.abrupt("return", _context3.sent);
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function setPermission(_x3) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }()
    /**
     * method setPermission for contract AccessController with only encode
     *
     * @param request AccessControllerSetPermissionRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setPermissionEncode",
    value: function setPermissionEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: accessControllerAbi,
          functionName: "setPermission",
          args: [request.ipAccount, request.signer, request.to, request.func, request.permission]
        })
      };
    }
  }]);
}(AccessControllerEventClient);

// Contract CoreMetadataModule =============================================================

/**
 * CoreMetadataModuleAuthorityUpdatedEvent
 *
 * @param authority address
 */

/**
 * CoreMetadataModuleInitializedEvent
 *
 * @param version uint64
 */

/**
 * CoreMetadataModuleMetadataFrozenEvent
 *
 * @param ipId address
 */

/**
 * CoreMetadataModuleMetadataUriSetEvent
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 */

/**
 * CoreMetadataModuleNftTokenUriSetEvent
 *
 * @param ipId address
 * @param nftTokenURI string
 * @param nftMetadataHash bytes32
 */

/**
 * CoreMetadataModuleUpgradedEvent
 *
 * @param implementation address
 */

/**
 * CoreMetadataModuleIsMetadataFrozenRequest
 *
 * @param ipId address
 */

/**
 * CoreMetadataModuleSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 */

/**
 * CoreMetadataModuleFreezeMetadataRequest
 *
 * @param ipId address
 */

/**
 * CoreMetadataModuleInitializeRequest
 *
 * @param accessManager address
 */

/**
 * CoreMetadataModuleSetAllRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 * @param nftMetadataHash bytes32
 */

/**
 * CoreMetadataModuleSetAuthorityRequest
 *
 * @param newAuthority address
 */

/**
 * CoreMetadataModuleSetMetadataUriRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 */

/**
 * CoreMetadataModuleUpdateNftTokenUriRequest
 *
 * @param ipId address
 * @param nftMetadataHash bytes32
 */

/**
 * CoreMetadataModuleUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */

/**
 * contract CoreMetadataModule event
 */
var CoreMetadataModuleEventClient = /*#__PURE__*/function () {
  function CoreMetadataModuleEventClient(rpcClient, address) {
    var _rpcClient$chain2;
    _classCallCheck(this, CoreMetadataModuleEventClient);
    this.address = address || getAddress(coreMetadataModuleAddress, (_rpcClient$chain2 = rpcClient.chain) === null || _rpcClient$chain2 === void 0 ? void 0 : _rpcClient$chain2.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event AuthorityUpdated for contract CoreMetadataModule
   */
  return _createClass(CoreMetadataModuleEventClient, [{
    key: "watchAuthorityUpdatedEvent",
    value: function watchAuthorityUpdatedEvent(_onLogs2) {
      return this.rpcClient.watchContractEvent({
        abi: coreMetadataModuleAbi,
        address: this.address,
        eventName: "AuthorityUpdated",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs2(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event AuthorityUpdated for contract CoreMetadataModule
     */
  }, {
    key: "parseTxAuthorityUpdatedEvent",
    value: function parseTxAuthorityUpdatedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator2 = _createForOfIteratorHelper(txReceipt.logs),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var log = _step2.value;
          try {
            var event = decodeEventLog({
              abi: coreMetadataModuleAbi,
              eventName: "AuthorityUpdated",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "AuthorityUpdated") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return targetLogs;
    }

    /**
     * event Initialized for contract CoreMetadataModule
     */
  }, {
    key: "watchInitializedEvent",
    value: function watchInitializedEvent(_onLogs3) {
      return this.rpcClient.watchContractEvent({
        abi: coreMetadataModuleAbi,
        address: this.address,
        eventName: "Initialized",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs3(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Initialized for contract CoreMetadataModule
     */
  }, {
    key: "parseTxInitializedEvent",
    value: function parseTxInitializedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator3 = _createForOfIteratorHelper(txReceipt.logs),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var log = _step3.value;
          try {
            var event = decodeEventLog({
              abi: coreMetadataModuleAbi,
              eventName: "Initialized",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Initialized") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return targetLogs;
    }

    /**
     * event MetadataFrozen for contract CoreMetadataModule
     */
  }, {
    key: "watchMetadataFrozenEvent",
    value: function watchMetadataFrozenEvent(_onLogs4) {
      return this.rpcClient.watchContractEvent({
        abi: coreMetadataModuleAbi,
        address: this.address,
        eventName: "MetadataFrozen",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs4(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event MetadataFrozen for contract CoreMetadataModule
     */
  }, {
    key: "parseTxMetadataFrozenEvent",
    value: function parseTxMetadataFrozenEvent(txReceipt) {
      var targetLogs = [];
      var _iterator4 = _createForOfIteratorHelper(txReceipt.logs),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var log = _step4.value;
          try {
            var event = decodeEventLog({
              abi: coreMetadataModuleAbi,
              eventName: "MetadataFrozen",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "MetadataFrozen") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return targetLogs;
    }

    /**
     * event MetadataURISet for contract CoreMetadataModule
     */
  }, {
    key: "watchMetadataUriSetEvent",
    value: function watchMetadataUriSetEvent(_onLogs5) {
      return this.rpcClient.watchContractEvent({
        abi: coreMetadataModuleAbi,
        address: this.address,
        eventName: "MetadataURISet",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs5(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event MetadataURISet for contract CoreMetadataModule
     */
  }, {
    key: "parseTxMetadataUriSetEvent",
    value: function parseTxMetadataUriSetEvent(txReceipt) {
      var targetLogs = [];
      var _iterator5 = _createForOfIteratorHelper(txReceipt.logs),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var log = _step5.value;
          try {
            var event = decodeEventLog({
              abi: coreMetadataModuleAbi,
              eventName: "MetadataURISet",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "MetadataURISet") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      return targetLogs;
    }

    /**
     * event NFTTokenURISet for contract CoreMetadataModule
     */
  }, {
    key: "watchNftTokenUriSetEvent",
    value: function watchNftTokenUriSetEvent(_onLogs6) {
      return this.rpcClient.watchContractEvent({
        abi: coreMetadataModuleAbi,
        address: this.address,
        eventName: "NFTTokenURISet",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs6(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event NFTTokenURISet for contract CoreMetadataModule
     */
  }, {
    key: "parseTxNftTokenUriSetEvent",
    value: function parseTxNftTokenUriSetEvent(txReceipt) {
      var targetLogs = [];
      var _iterator6 = _createForOfIteratorHelper(txReceipt.logs),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var log = _step6.value;
          try {
            var event = decodeEventLog({
              abi: coreMetadataModuleAbi,
              eventName: "NFTTokenURISet",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "NFTTokenURISet") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return targetLogs;
    }

    /**
     * event Upgraded for contract CoreMetadataModule
     */
  }, {
    key: "watchUpgradedEvent",
    value: function watchUpgradedEvent(_onLogs7) {
      return this.rpcClient.watchContractEvent({
        abi: coreMetadataModuleAbi,
        address: this.address,
        eventName: "Upgraded",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs7(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Upgraded for contract CoreMetadataModule
     */
  }, {
    key: "parseTxUpgradedEvent",
    value: function parseTxUpgradedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator7 = _createForOfIteratorHelper(txReceipt.logs),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var log = _step7.value;
          try {
            var event = decodeEventLog({
              abi: coreMetadataModuleAbi,
              eventName: "Upgraded",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Upgraded") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract CoreMetadataModule readonly method
 */
var CoreMetadataModuleReadOnlyClient = /*#__PURE__*/function (_CoreMetadataModuleEv) {
  function CoreMetadataModuleReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, CoreMetadataModuleReadOnlyClient);
    return _callSuper(this, CoreMetadataModuleReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method ACCESS_CONTROLLER for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleAccessControllerRequest
   * @return Promise<CoreMetadataModuleAccessControllerResponse>
   */
  _inherits(CoreMetadataModuleReadOnlyClient, _CoreMetadataModuleEv);
  return _createClass(CoreMetadataModuleReadOnlyClient, [{
    key: "accessController",
    value: (function () {
      var _accessController = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "ACCESS_CONTROLLER"
              });
            case 2:
              return _context4.abrupt("return", _context4.sent);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function accessController() {
        return _accessController.apply(this, arguments);
      }
      return accessController;
    }()
    /**
     * method IP_ACCOUNT_REGISTRY for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleIpAccountRegistryRequest
     * @return Promise<CoreMetadataModuleIpAccountRegistryResponse>
     */
    )
  }, {
    key: "ipAccountRegistry",
    value: (function () {
      var _ipAccountRegistry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "IP_ACCOUNT_REGISTRY"
              });
            case 2:
              return _context5.abrupt("return", _context5.sent);
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function ipAccountRegistry() {
        return _ipAccountRegistry.apply(this, arguments);
      }
      return ipAccountRegistry;
    }()
    /**
     * method UPGRADE_INTERFACE_VERSION for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleUpgradeInterfaceVersionRequest
     * @return Promise<CoreMetadataModuleUpgradeInterfaceVersionResponse>
     */
    )
  }, {
    key: "upgradeInterfaceVersion",
    value: (function () {
      var _upgradeInterfaceVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "UPGRADE_INTERFACE_VERSION"
              });
            case 2:
              return _context6.abrupt("return", _context6.sent);
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function upgradeInterfaceVersion() {
        return _upgradeInterfaceVersion.apply(this, arguments);
      }
      return upgradeInterfaceVersion;
    }()
    /**
     * method authority for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleAuthorityRequest
     * @return Promise<CoreMetadataModuleAuthorityResponse>
     */
    )
  }, {
    key: "authority",
    value: (function () {
      var _authority = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "authority"
              });
            case 2:
              return _context7.abrupt("return", _context7.sent);
            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function authority() {
        return _authority.apply(this, arguments);
      }
      return authority;
    }()
    /**
     * method isConsumingScheduledOp for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleIsConsumingScheduledOpRequest
     * @return Promise<CoreMetadataModuleIsConsumingScheduledOpResponse>
     */
    )
  }, {
    key: "isConsumingScheduledOp",
    value: (function () {
      var _isConsumingScheduledOp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "isConsumingScheduledOp"
              });
            case 2:
              return _context8.abrupt("return", _context8.sent);
            case 3:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function isConsumingScheduledOp() {
        return _isConsumingScheduledOp.apply(this, arguments);
      }
      return isConsumingScheduledOp;
    }()
    /**
     * method isMetadataFrozen for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleIsMetadataFrozenRequest
     * @return Promise<CoreMetadataModuleIsMetadataFrozenResponse>
     */
    )
  }, {
    key: "isMetadataFrozen",
    value: (function () {
      var _isMetadataFrozen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "isMetadataFrozen",
                args: [request.ipId]
              });
            case 2:
              return _context9.abrupt("return", _context9.sent);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function isMetadataFrozen(_x4) {
        return _isMetadataFrozen.apply(this, arguments);
      }
      return isMetadataFrozen;
    }()
    /**
     * method name for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleNameRequest
     * @return Promise<CoreMetadataModuleNameResponse>
     */
    )
  }, {
    key: "name",
    value: (function () {
      var _name = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "name"
              });
            case 2:
              return _context10.abrupt("return", _context10.sent);
            case 3:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function name() {
        return _name.apply(this, arguments);
      }
      return name;
    }()
    /**
     * method proxiableUUID for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleProxiableUuidRequest
     * @return Promise<CoreMetadataModuleProxiableUuidResponse>
     */
    )
  }, {
    key: "proxiableUuid",
    value: (function () {
      var _proxiableUuid = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "proxiableUUID"
              });
            case 2:
              return _context11.abrupt("return", _context11.sent);
            case 3:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function proxiableUuid() {
        return _proxiableUuid.apply(this, arguments);
      }
      return proxiableUuid;
    }()
    /**
     * method supportsInterface for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleSupportsInterfaceRequest
     * @return Promise<CoreMetadataModuleSupportsInterfaceResponse>
     */
    )
  }, {
    key: "supportsInterface",
    value: (function () {
      var _supportsInterface = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request) {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.rpcClient.readContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "supportsInterface",
                args: [request.interfaceId]
              });
            case 2:
              return _context12.abrupt("return", _context12.sent);
            case 3:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function supportsInterface(_x5) {
        return _supportsInterface.apply(this, arguments);
      }
      return supportsInterface;
    }())
  }]);
}(CoreMetadataModuleEventClient);

/**
 * contract CoreMetadataModule write method
 */
var CoreMetadataModuleClient = /*#__PURE__*/function (_CoreMetadataModuleRe) {
  function CoreMetadataModuleClient(rpcClient, wallet, address) {
    var _this2;
    _classCallCheck(this, CoreMetadataModuleClient);
    _this2 = _callSuper(this, CoreMetadataModuleClient, [rpcClient, address]);
    _this2.wallet = wallet;
    return _this2;
  }

  /**
   * method freezeMetadata for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleFreezeMetadataRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(CoreMetadataModuleClient, _CoreMetadataModuleRe);
  return _createClass(CoreMetadataModuleClient, [{
    key: "freezeMetadata",
    value: (function () {
      var _freezeMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(request) {
        var _yield$this$rpcClient4, call;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return this.rpcClient.simulateContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "freezeMetadata",
                account: this.wallet.account,
                args: [request.ipId]
              });
            case 2:
              _yield$this$rpcClient4 = _context13.sent;
              call = _yield$this$rpcClient4.request;
              _context13.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context13.abrupt("return", _context13.sent);
            case 7:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function freezeMetadata(_x6) {
        return _freezeMetadata.apply(this, arguments);
      }
      return freezeMetadata;
    }()
    /**
     * method freezeMetadata for contract CoreMetadataModule with only encode
     *
     * @param request CoreMetadataModuleFreezeMetadataRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "freezeMetadataEncode",
    value: function freezeMetadataEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: coreMetadataModuleAbi,
          functionName: "freezeMetadata",
          args: [request.ipId]
        })
      };
    }

    /**
     * method initialize for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleInitializeRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "initialize",
    value: (function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(request) {
        var _yield$this$rpcClient5, call;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return this.rpcClient.simulateContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "initialize",
                account: this.wallet.account,
                args: [request.accessManager]
              });
            case 2:
              _yield$this$rpcClient5 = _context14.sent;
              call = _yield$this$rpcClient5.request;
              _context14.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context14.abrupt("return", _context14.sent);
            case 7:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function initialize(_x7) {
        return _initialize.apply(this, arguments);
      }
      return initialize;
    }()
    /**
     * method initialize for contract CoreMetadataModule with only encode
     *
     * @param request CoreMetadataModuleInitializeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "initializeEncode",
    value: function initializeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: coreMetadataModuleAbi,
          functionName: "initialize",
          args: [request.accessManager]
        })
      };
    }

    /**
     * method setAll for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleSetAllRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "setAll",
    value: (function () {
      var _setAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(request) {
        var _yield$this$rpcClient6, call;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return this.rpcClient.simulateContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "setAll",
                account: this.wallet.account,
                args: [request.ipId, request.metadataURI, request.metadataHash, request.nftMetadataHash]
              });
            case 2:
              _yield$this$rpcClient6 = _context15.sent;
              call = _yield$this$rpcClient6.request;
              _context15.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context15.abrupt("return", _context15.sent);
            case 7:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function setAll(_x8) {
        return _setAll.apply(this, arguments);
      }
      return setAll;
    }()
    /**
     * method setAll for contract CoreMetadataModule with only encode
     *
     * @param request CoreMetadataModuleSetAllRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setAllEncode",
    value: function setAllEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: coreMetadataModuleAbi,
          functionName: "setAll",
          args: [request.ipId, request.metadataURI, request.metadataHash, request.nftMetadataHash]
        })
      };
    }

    /**
     * method setAuthority for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleSetAuthorityRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "setAuthority",
    value: (function () {
      var _setAuthority = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request) {
        var _yield$this$rpcClient7, call;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return this.rpcClient.simulateContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "setAuthority",
                account: this.wallet.account,
                args: [request.newAuthority]
              });
            case 2:
              _yield$this$rpcClient7 = _context16.sent;
              call = _yield$this$rpcClient7.request;
              _context16.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context16.abrupt("return", _context16.sent);
            case 7:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function setAuthority(_x9) {
        return _setAuthority.apply(this, arguments);
      }
      return setAuthority;
    }()
    /**
     * method setAuthority for contract CoreMetadataModule with only encode
     *
     * @param request CoreMetadataModuleSetAuthorityRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setAuthorityEncode",
    value: function setAuthorityEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: coreMetadataModuleAbi,
          functionName: "setAuthority",
          args: [request.newAuthority]
        })
      };
    }

    /**
     * method setMetadataURI for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleSetMetadataUriRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "setMetadataUri",
    value: (function () {
      var _setMetadataUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(request) {
        var _yield$this$rpcClient8, call;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return this.rpcClient.simulateContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "setMetadataURI",
                account: this.wallet.account,
                args: [request.ipId, request.metadataURI, request.metadataHash]
              });
            case 2:
              _yield$this$rpcClient8 = _context17.sent;
              call = _yield$this$rpcClient8.request;
              _context17.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context17.abrupt("return", _context17.sent);
            case 7:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function setMetadataUri(_x10) {
        return _setMetadataUri.apply(this, arguments);
      }
      return setMetadataUri;
    }()
    /**
     * method setMetadataURI for contract CoreMetadataModule with only encode
     *
     * @param request CoreMetadataModuleSetMetadataUriRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setMetadataUriEncode",
    value: function setMetadataUriEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: coreMetadataModuleAbi,
          functionName: "setMetadataURI",
          args: [request.ipId, request.metadataURI, request.metadataHash]
        })
      };
    }

    /**
     * method updateNftTokenURI for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleUpdateNftTokenUriRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "updateNftTokenUri",
    value: (function () {
      var _updateNftTokenUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(request) {
        var _yield$this$rpcClient9, call;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return this.rpcClient.simulateContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "updateNftTokenURI",
                account: this.wallet.account,
                args: [request.ipId, request.nftMetadataHash]
              });
            case 2:
              _yield$this$rpcClient9 = _context18.sent;
              call = _yield$this$rpcClient9.request;
              _context18.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context18.abrupt("return", _context18.sent);
            case 7:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function updateNftTokenUri(_x11) {
        return _updateNftTokenUri.apply(this, arguments);
      }
      return updateNftTokenUri;
    }()
    /**
     * method updateNftTokenURI for contract CoreMetadataModule with only encode
     *
     * @param request CoreMetadataModuleUpdateNftTokenUriRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "updateNftTokenUriEncode",
    value: function updateNftTokenUriEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: coreMetadataModuleAbi,
          functionName: "updateNftTokenURI",
          args: [request.ipId, request.nftMetadataHash]
        })
      };
    }

    /**
     * method upgradeToAndCall for contract CoreMetadataModule
     *
     * @param request CoreMetadataModuleUpgradeToAndCallRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "upgradeToAndCall",
    value: (function () {
      var _upgradeToAndCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(request) {
        var _yield$this$rpcClient10, call;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return this.rpcClient.simulateContract({
                abi: coreMetadataModuleAbi,
                address: this.address,
                functionName: "upgradeToAndCall",
                account: this.wallet.account,
                args: [request.newImplementation, request.data]
              });
            case 2:
              _yield$this$rpcClient10 = _context19.sent;
              call = _yield$this$rpcClient10.request;
              _context19.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context19.abrupt("return", _context19.sent);
            case 7:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function upgradeToAndCall(_x12) {
        return _upgradeToAndCall.apply(this, arguments);
      }
      return upgradeToAndCall;
    }()
    /**
     * method upgradeToAndCall for contract CoreMetadataModule with only encode
     *
     * @param request CoreMetadataModuleUpgradeToAndCallRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "upgradeToAndCallEncode",
    value: function upgradeToAndCallEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: coreMetadataModuleAbi,
          functionName: "upgradeToAndCall",
          args: [request.newImplementation, request.data]
        })
      };
    }
  }]);
}(CoreMetadataModuleReadOnlyClient);

// Contract DisputeModule =============================================================

/**
 * DisputeModuleDisputeCancelledEvent
 *
 * @param disputeId uint256
 * @param data bytes
 */

/**
 * DisputeModuleDisputeRaisedEvent
 *
 * @param disputeId uint256
 * @param targetIpId address
 * @param disputeInitiator address
 * @param arbitrationPolicy address
 * @param linkToDisputeEvidence bytes32
 * @param targetTag bytes32
 * @param data bytes
 */

/**
 * DisputeModuleDisputeResolvedEvent
 *
 * @param disputeId uint256
 */

/**
 * DisputeModuleCancelDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 */

/**
 * DisputeModuleRaiseDisputeRequest
 *
 * @param targetIpId address
 * @param linkToDisputeEvidence string
 * @param targetTag bytes32
 * @param data bytes
 */

/**
 * DisputeModuleResolveDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 */

/**
 * contract DisputeModule event
 */
var DisputeModuleEventClient = /*#__PURE__*/function () {
  function DisputeModuleEventClient(rpcClient, address) {
    var _rpcClient$chain3;
    _classCallCheck(this, DisputeModuleEventClient);
    this.address = address || getAddress(disputeModuleAddress, (_rpcClient$chain3 = rpcClient.chain) === null || _rpcClient$chain3 === void 0 ? void 0 : _rpcClient$chain3.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event DisputeCancelled for contract DisputeModule
   */
  return _createClass(DisputeModuleEventClient, [{
    key: "watchDisputeCancelledEvent",
    value: function watchDisputeCancelledEvent(_onLogs8) {
      return this.rpcClient.watchContractEvent({
        abi: disputeModuleAbi,
        address: this.address,
        eventName: "DisputeCancelled",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs8(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DisputeCancelled for contract DisputeModule
     */
  }, {
    key: "parseTxDisputeCancelledEvent",
    value: function parseTxDisputeCancelledEvent(txReceipt) {
      var targetLogs = [];
      var _iterator8 = _createForOfIteratorHelper(txReceipt.logs),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var log = _step8.value;
          try {
            var event = decodeEventLog({
              abi: disputeModuleAbi,
              eventName: "DisputeCancelled",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DisputeCancelled") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      return targetLogs;
    }

    /**
     * event DisputeRaised for contract DisputeModule
     */
  }, {
    key: "watchDisputeRaisedEvent",
    value: function watchDisputeRaisedEvent(_onLogs9) {
      return this.rpcClient.watchContractEvent({
        abi: disputeModuleAbi,
        address: this.address,
        eventName: "DisputeRaised",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs9(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DisputeRaised for contract DisputeModule
     */
  }, {
    key: "parseTxDisputeRaisedEvent",
    value: function parseTxDisputeRaisedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator9 = _createForOfIteratorHelper(txReceipt.logs),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var log = _step9.value;
          try {
            var event = decodeEventLog({
              abi: disputeModuleAbi,
              eventName: "DisputeRaised",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DisputeRaised") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
      return targetLogs;
    }

    /**
     * event DisputeResolved for contract DisputeModule
     */
  }, {
    key: "watchDisputeResolvedEvent",
    value: function watchDisputeResolvedEvent(_onLogs10) {
      return this.rpcClient.watchContractEvent({
        abi: disputeModuleAbi,
        address: this.address,
        eventName: "DisputeResolved",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs10(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DisputeResolved for contract DisputeModule
     */
  }, {
    key: "parseTxDisputeResolvedEvent",
    value: function parseTxDisputeResolvedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator10 = _createForOfIteratorHelper(txReceipt.logs),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var log = _step10.value;
          try {
            var event = decodeEventLog({
              abi: disputeModuleAbi,
              eventName: "DisputeResolved",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DisputeResolved") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract DisputeModule write method
 */
var DisputeModuleClient = /*#__PURE__*/function (_DisputeModuleEventCl) {
  function DisputeModuleClient(rpcClient, wallet, address) {
    var _this3;
    _classCallCheck(this, DisputeModuleClient);
    _this3 = _callSuper(this, DisputeModuleClient, [rpcClient, address]);
    _this3.wallet = wallet;
    return _this3;
  }

  /**
   * method cancelDispute for contract DisputeModule
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(DisputeModuleClient, _DisputeModuleEventCl);
  return _createClass(DisputeModuleClient, [{
    key: "cancelDispute",
    value: (function () {
      var _cancelDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(request) {
        var _yield$this$rpcClient11, call;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.rpcClient.simulateContract({
                abi: disputeModuleAbi,
                address: this.address,
                functionName: "cancelDispute",
                account: this.wallet.account,
                args: [request.disputeId, request.data]
              });
            case 2:
              _yield$this$rpcClient11 = _context20.sent;
              call = _yield$this$rpcClient11.request;
              _context20.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context20.abrupt("return", _context20.sent);
            case 7:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function cancelDispute(_x13) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * method cancelDispute for contract DisputeModule with only encode
     *
     * @param request DisputeModuleCancelDisputeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "cancelDisputeEncode",
    value: function cancelDisputeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: disputeModuleAbi,
          functionName: "cancelDispute",
          args: [request.disputeId, request.data]
        })
      };
    }

    /**
     * method raiseDispute for contract DisputeModule
     *
     * @param request DisputeModuleRaiseDisputeRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "raiseDispute",
    value: (function () {
      var _raiseDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(request) {
        var _yield$this$rpcClient12, call;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return this.rpcClient.simulateContract({
                abi: disputeModuleAbi,
                address: this.address,
                functionName: "raiseDispute",
                account: this.wallet.account,
                args: [request.targetIpId, request.linkToDisputeEvidence, request.targetTag, request.data]
              });
            case 2:
              _yield$this$rpcClient12 = _context21.sent;
              call = _yield$this$rpcClient12.request;
              _context21.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context21.abrupt("return", _context21.sent);
            case 7:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function raiseDispute(_x14) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * method raiseDispute for contract DisputeModule with only encode
     *
     * @param request DisputeModuleRaiseDisputeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "raiseDisputeEncode",
    value: function raiseDisputeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: disputeModuleAbi,
          functionName: "raiseDispute",
          args: [request.targetIpId, request.linkToDisputeEvidence, request.targetTag, request.data]
        })
      };
    }

    /**
     * method resolveDispute for contract DisputeModule
     *
     * @param request DisputeModuleResolveDisputeRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "resolveDispute",
    value: (function () {
      var _resolveDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(request) {
        var _yield$this$rpcClient13, call;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return this.rpcClient.simulateContract({
                abi: disputeModuleAbi,
                address: this.address,
                functionName: "resolveDispute",
                account: this.wallet.account,
                args: [request.disputeId, request.data]
              });
            case 2:
              _yield$this$rpcClient13 = _context22.sent;
              call = _yield$this$rpcClient13.request;
              _context22.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context22.abrupt("return", _context22.sent);
            case 7:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function resolveDispute(_x15) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }()
    /**
     * method resolveDispute for contract DisputeModule with only encode
     *
     * @param request DisputeModuleResolveDisputeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "resolveDisputeEncode",
    value: function resolveDisputeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: disputeModuleAbi,
          functionName: "resolveDispute",
          args: [request.disputeId, request.data]
        })
      };
    }
  }]);
}(DisputeModuleEventClient);

// Contract IPAccountImpl =============================================================

/**
 * IpAccountImplStateResponse
 *
 * @param result bytes32
 */

/**
 * IpAccountImplTokenResponse
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 uint256
 */

/**
 * IpAccountImplExecuteRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param operation uint8
 */

/**
 * IpAccountImplExecute2Request
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 */

/**
 * IpAccountImplExecuteWithSigRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param signer address
 * @param deadline uint256
 * @param signature bytes
 */

/**
 * contract IPAccountImpl readonly method
 */
var IpAccountImplReadOnlyClient = /*#__PURE__*/function () {
  function IpAccountImplReadOnlyClient(rpcClient, address) {
    var _rpcClient$chain4;
    _classCallCheck(this, IpAccountImplReadOnlyClient);
    this.address = address || getAddress(ipAccountImplAddress, (_rpcClient$chain4 = rpcClient.chain) === null || _rpcClient$chain4 === void 0 ? void 0 : _rpcClient$chain4.id);
    this.rpcClient = rpcClient;
  }

  /**
   * method state for contract IPAccountImpl
   *
   * @param request IpAccountImplStateRequest
   * @return Promise<IpAccountImplStateResponse>
   */
  return _createClass(IpAccountImplReadOnlyClient, [{
    key: "state",
    value: (function () {
      var _state = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
        var result;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return this.rpcClient.readContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "state"
              });
            case 2:
              result = _context23.sent;
              return _context23.abrupt("return", {
                result: result
              });
            case 4:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function state() {
        return _state.apply(this, arguments);
      }
      return state;
    }()
    /**
     * method token for contract IPAccountImpl
     *
     * @param request IpAccountImplTokenRequest
     * @return Promise<IpAccountImplTokenResponse>
     */
    )
  }, {
    key: "token",
    value: (function () {
      var _token = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return this.rpcClient.readContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "token"
              });
            case 2:
              return _context24.abrupt("return", _context24.sent);
            case 3:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function token() {
        return _token.apply(this, arguments);
      }
      return token;
    }())
  }]);
}();

/**
 * contract IPAccountImpl write method
 */
var IpAccountImplClient = /*#__PURE__*/function (_IpAccountImplReadOnl) {
  function IpAccountImplClient(rpcClient, wallet, address) {
    var _this4;
    _classCallCheck(this, IpAccountImplClient);
    _this4 = _callSuper(this, IpAccountImplClient, [rpcClient, address]);
    _this4.wallet = wallet;
    return _this4;
  }

  /**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(IpAccountImplClient, _IpAccountImplReadOnl);
  return _createClass(IpAccountImplClient, [{
    key: "execute",
    value: (function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(request) {
        var _yield$this$rpcClient14, call;
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "execute",
                account: this.wallet.account,
                args: [request.to, request.value, request.data, request.operation]
              });
            case 2:
              _yield$this$rpcClient14 = _context25.sent;
              call = _yield$this$rpcClient14.request;
              _context25.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context25.abrupt("return", _context25.sent);
            case 7:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function execute(_x16) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /**
     * method execute for contract IPAccountImpl with only encode
     *
     * @param request IpAccountImplExecuteRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "executeEncode",
    value: function executeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipAccountImplAbi,
          functionName: "execute",
          args: [request.to, request.value, request.data, request.operation]
        })
      };
    }

    /**
     * method execute for contract IPAccountImpl
     *
     * @param request IpAccountImplExecute2Request
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "execute2",
    value: (function () {
      var _execute2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(request) {
        var _yield$this$rpcClient15, call;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "execute",
                account: this.wallet.account,
                args: [request.to, request.value, request.data]
              });
            case 2:
              _yield$this$rpcClient15 = _context26.sent;
              call = _yield$this$rpcClient15.request;
              _context26.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context26.abrupt("return", _context26.sent);
            case 7:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function execute2(_x17) {
        return _execute2.apply(this, arguments);
      }
      return execute2;
    }()
    /**
     * method execute for contract IPAccountImpl with only encode
     *
     * @param request IpAccountImplExecute2Request
     * @return EncodedTxData
     */
    )
  }, {
    key: "execute2Encode",
    value: function execute2Encode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipAccountImplAbi,
          functionName: "execute",
          args: [request.to, request.value, request.data]
        })
      };
    }

    /**
     * method executeWithSig for contract IPAccountImpl
     *
     * @param request IpAccountImplExecuteWithSigRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "executeWithSig",
    value: (function () {
      var _executeWithSig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(request) {
        var _yield$this$rpcClient16, call;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipAccountImplAbi,
                address: this.address,
                functionName: "executeWithSig",
                account: this.wallet.account,
                args: [request.to, request.value, request.data, request.signer, request.deadline, request.signature]
              });
            case 2:
              _yield$this$rpcClient16 = _context27.sent;
              call = _yield$this$rpcClient16.request;
              _context27.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context27.abrupt("return", _context27.sent);
            case 7:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function executeWithSig(_x18) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }()
    /**
     * method executeWithSig for contract IPAccountImpl with only encode
     *
     * @param request IpAccountImplExecuteWithSigRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "executeWithSigEncode",
    value: function executeWithSigEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipAccountImplAbi,
          functionName: "executeWithSig",
          args: [request.to, request.value, request.data, request.signer, request.deadline, request.signature]
        })
      };
    }
  }]);
}(IpAccountImplReadOnlyClient);

// Contract IPAssetRegistry =============================================================

/**
 * IpAssetRegistryIpAccountRegisteredEvent
 *
 * @param account address
 * @param implementation address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 */

/**
 * IpAssetRegistryIpRegisteredEvent
 *
 * @param ipId address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 * @param name string
 * @param uri string
 * @param registrationDate uint256
 */

/**
 * IpAssetRegistryIpIdRequest
 *
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 */

/**
 * IpAssetRegistryIsRegisteredRequest
 *
 * @param id address
 */

/**
 * IpAssetRegistryRegisterRequest
 *
 * @param chainid uint256
 * @param tokenContract address
 * @param tokenId uint256
 */

/**
 * contract IPAssetRegistry event
 */
var IpAssetRegistryEventClient = /*#__PURE__*/function () {
  function IpAssetRegistryEventClient(rpcClient, address) {
    var _rpcClient$chain5;
    _classCallCheck(this, IpAssetRegistryEventClient);
    this.address = address || getAddress(ipAssetRegistryAddress, (_rpcClient$chain5 = rpcClient.chain) === null || _rpcClient$chain5 === void 0 ? void 0 : _rpcClient$chain5.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event IPAccountRegistered for contract IPAssetRegistry
   */
  return _createClass(IpAssetRegistryEventClient, [{
    key: "watchIpAccountRegisteredEvent",
    value: function watchIpAccountRegisteredEvent(_onLogs11) {
      return this.rpcClient.watchContractEvent({
        abi: ipAssetRegistryAbi,
        address: this.address,
        eventName: "IPAccountRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs11(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event IPAccountRegistered for contract IPAssetRegistry
     */
  }, {
    key: "parseTxIpAccountRegisteredEvent",
    value: function parseTxIpAccountRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator11 = _createForOfIteratorHelper(txReceipt.logs),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var log = _step11.value;
          try {
            var event = decodeEventLog({
              abi: ipAssetRegistryAbi,
              eventName: "IPAccountRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "IPAccountRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      return targetLogs;
    }

    /**
     * event IPRegistered for contract IPAssetRegistry
     */
  }, {
    key: "watchIpRegisteredEvent",
    value: function watchIpRegisteredEvent(_onLogs12) {
      return this.rpcClient.watchContractEvent({
        abi: ipAssetRegistryAbi,
        address: this.address,
        eventName: "IPRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs12(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event IPRegistered for contract IPAssetRegistry
     */
  }, {
    key: "parseTxIpRegisteredEvent",
    value: function parseTxIpRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator12 = _createForOfIteratorHelper(txReceipt.logs),
        _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var log = _step12.value;
          try {
            var event = decodeEventLog({
              abi: ipAssetRegistryAbi,
              eventName: "IPRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "IPRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract IPAssetRegistry readonly method
 */
var IpAssetRegistryReadOnlyClient = /*#__PURE__*/function (_IpAssetRegistryEvent) {
  function IpAssetRegistryReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, IpAssetRegistryReadOnlyClient);
    return _callSuper(this, IpAssetRegistryReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method ipId for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIpIdRequest
   * @return Promise<IpAssetRegistryIpIdResponse>
   */
  _inherits(IpAssetRegistryReadOnlyClient, _IpAssetRegistryEvent);
  return _createClass(IpAssetRegistryReadOnlyClient, [{
    key: "ipId",
    value: (function () {
      var _ipId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(request) {
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return this.rpcClient.readContract({
                abi: ipAssetRegistryAbi,
                address: this.address,
                functionName: "ipId",
                args: [request.chainId, request.tokenContract, request.tokenId]
              });
            case 2:
              return _context28.abrupt("return", _context28.sent);
            case 3:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function ipId(_x19) {
        return _ipId.apply(this, arguments);
      }
      return ipId;
    }()
    /**
     * method isRegistered for contract IPAssetRegistry
     *
     * @param request IpAssetRegistryIsRegisteredRequest
     * @return Promise<IpAssetRegistryIsRegisteredResponse>
     */
    )
  }, {
    key: "isRegistered",
    value: (function () {
      var _isRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(request) {
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.rpcClient.readContract({
                abi: ipAssetRegistryAbi,
                address: this.address,
                functionName: "isRegistered",
                args: [request.id]
              });
            case 2:
              return _context29.abrupt("return", _context29.sent);
            case 3:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));
      function isRegistered(_x20) {
        return _isRegistered.apply(this, arguments);
      }
      return isRegistered;
    }())
  }]);
}(IpAssetRegistryEventClient);

/**
 * contract IPAssetRegistry write method
 */
var IpAssetRegistryClient = /*#__PURE__*/function (_IpAssetRegistryReadO) {
  function IpAssetRegistryClient(rpcClient, wallet, address) {
    var _this5;
    _classCallCheck(this, IpAssetRegistryClient);
    _this5 = _callSuper(this, IpAssetRegistryClient, [rpcClient, address]);
    _this5.wallet = wallet;
    return _this5;
  }

  /**
   * method register for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(IpAssetRegistryClient, _IpAssetRegistryReadO);
  return _createClass(IpAssetRegistryClient, [{
    key: "register",
    value: (function () {
      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(request) {
        var _yield$this$rpcClient17, call;
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipAssetRegistryAbi,
                address: this.address,
                functionName: "register",
                account: this.wallet.account,
                args: [request.chainid, request.tokenContract, request.tokenId]
              });
            case 2:
              _yield$this$rpcClient17 = _context30.sent;
              call = _yield$this$rpcClient17.request;
              _context30.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context30.abrupt("return", _context30.sent);
            case 7:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
      function register(_x21) {
        return _register.apply(this, arguments);
      }
      return register;
    }()
    /**
     * method register for contract IPAssetRegistry with only encode
     *
     * @param request IpAssetRegistryRegisterRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerEncode",
    value: function registerEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipAssetRegistryAbi,
          functionName: "register",
          args: [request.chainid, request.tokenContract, request.tokenId]
        })
      };
    }
  }]);
}(IpAssetRegistryReadOnlyClient);

// Contract IpRoyaltyVaultImpl =============================================================

/**
 * IpRoyaltyVaultImplRevenueTokenClaimedEvent
 *
 * @param claimer address
 * @param token address
 * @param amount uint256
 */

/**
 * IpRoyaltyVaultImplRoyaltyTokensCollectedEvent
 *
 * @param ancestorIpId address
 * @param royaltyTokensCollected uint256
 */

/**
 * IpRoyaltyVaultImplSnapshotCompletedEvent
 *
 * @param snapshotId uint256
 * @param snapshotTimestamp uint256
 * @param unclaimedTokens uint32
 */

/**
 * IpRoyaltyVaultImplClaimableRevenueRequest
 *
 * @param account address
 * @param snapshotId uint256
 * @param token address
 */

/**
 * IpRoyaltyVaultImplClaimRevenueBySnapshotBatchRequest
 *
 * @param snapshotIds uint256[]
 * @param token address
 */

/**
 * IpRoyaltyVaultImplClaimRevenueByTokenBatchRequest
 *
 * @param snapshotId uint256
 * @param tokenList address[]
 */

/**
 * IpRoyaltyVaultImplCollectRoyaltyTokensRequest
 *
 * @param ancestorIpId address
 */

/**
 * contract IpRoyaltyVaultImpl event
 */
var IpRoyaltyVaultImplEventClient = /*#__PURE__*/function () {
  function IpRoyaltyVaultImplEventClient(rpcClient, address) {
    var _rpcClient$chain6;
    _classCallCheck(this, IpRoyaltyVaultImplEventClient);
    this.address = address || getAddress(ipRoyaltyVaultImplAddress, (_rpcClient$chain6 = rpcClient.chain) === null || _rpcClient$chain6 === void 0 ? void 0 : _rpcClient$chain6.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */
  return _createClass(IpRoyaltyVaultImplEventClient, [{
    key: "watchRevenueTokenClaimedEvent",
    value: function watchRevenueTokenClaimedEvent(_onLogs13) {
      return this.rpcClient.watchContractEvent({
        abi: ipRoyaltyVaultImplAbi,
        address: this.address,
        eventName: "RevenueTokenClaimed",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs13(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "parseTxRevenueTokenClaimedEvent",
    value: function parseTxRevenueTokenClaimedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator13 = _createForOfIteratorHelper(txReceipt.logs),
        _step13;
      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var log = _step13.value;
          try {
            var event = decodeEventLog({
              abi: ipRoyaltyVaultImplAbi,
              eventName: "RevenueTokenClaimed",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "RevenueTokenClaimed") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
      return targetLogs;
    }

    /**
     * event RoyaltyTokensCollected for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "watchRoyaltyTokensCollectedEvent",
    value: function watchRoyaltyTokensCollectedEvent(_onLogs14) {
      return this.rpcClient.watchContractEvent({
        abi: ipRoyaltyVaultImplAbi,
        address: this.address,
        eventName: "RoyaltyTokensCollected",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs14(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event RoyaltyTokensCollected for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "parseTxRoyaltyTokensCollectedEvent",
    value: function parseTxRoyaltyTokensCollectedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator14 = _createForOfIteratorHelper(txReceipt.logs),
        _step14;
      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var log = _step14.value;
          try {
            var event = decodeEventLog({
              abi: ipRoyaltyVaultImplAbi,
              eventName: "RoyaltyTokensCollected",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "RoyaltyTokensCollected") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
      return targetLogs;
    }

    /**
     * event SnapshotCompleted for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "watchSnapshotCompletedEvent",
    value: function watchSnapshotCompletedEvent(_onLogs15) {
      return this.rpcClient.watchContractEvent({
        abi: ipRoyaltyVaultImplAbi,
        address: this.address,
        eventName: "SnapshotCompleted",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs15(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event SnapshotCompleted for contract IpRoyaltyVaultImpl
     */
  }, {
    key: "parseTxSnapshotCompletedEvent",
    value: function parseTxSnapshotCompletedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator15 = _createForOfIteratorHelper(txReceipt.logs),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var log = _step15.value;
          try {
            var event = decodeEventLog({
              abi: ipRoyaltyVaultImplAbi,
              eventName: "SnapshotCompleted",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "SnapshotCompleted") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract IpRoyaltyVaultImpl readonly method
 */
var IpRoyaltyVaultImplReadOnlyClient = /*#__PURE__*/function (_IpRoyaltyVaultImplEv) {
  function IpRoyaltyVaultImplReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, IpRoyaltyVaultImplReadOnlyClient);
    return _callSuper(this, IpRoyaltyVaultImplReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method claimableRevenue for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplClaimableRevenueRequest
   * @return Promise<IpRoyaltyVaultImplClaimableRevenueResponse>
   */
  _inherits(IpRoyaltyVaultImplReadOnlyClient, _IpRoyaltyVaultImplEv);
  return _createClass(IpRoyaltyVaultImplReadOnlyClient, [{
    key: "claimableRevenue",
    value: (function () {
      var _claimableRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(request) {
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return this.rpcClient.readContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "claimableRevenue",
                args: [request.account, request.snapshotId, request.token]
              });
            case 2:
              return _context31.abrupt("return", _context31.sent);
            case 3:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this);
      }));
      function claimableRevenue(_x22) {
        return _claimableRevenue.apply(this, arguments);
      }
      return claimableRevenue;
    }()
    /**
     * method ipId for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplIpIdRequest
     * @return Promise<IpRoyaltyVaultImplIpIdResponse>
     */
    )
  }, {
    key: "ipId",
    value: (function () {
      var _ipId2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              _context32.next = 2;
              return this.rpcClient.readContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "ipId"
              });
            case 2:
              return _context32.abrupt("return", _context32.sent);
            case 3:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this);
      }));
      function ipId() {
        return _ipId2.apply(this, arguments);
      }
      return ipId;
    }())
  }]);
}(IpRoyaltyVaultImplEventClient);

/**
 * contract IpRoyaltyVaultImpl write method
 */
var IpRoyaltyVaultImplClient = /*#__PURE__*/function (_IpRoyaltyVaultImplRe) {
  function IpRoyaltyVaultImplClient(rpcClient, wallet, address) {
    var _this6;
    _classCallCheck(this, IpRoyaltyVaultImplClient);
    _this6 = _callSuper(this, IpRoyaltyVaultImplClient, [rpcClient, address]);
    _this6.wallet = wallet;
    return _this6;
  }

  /**
   * method claimRevenueBySnapshotBatch for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplClaimRevenueBySnapshotBatchRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(IpRoyaltyVaultImplClient, _IpRoyaltyVaultImplRe);
  return _createClass(IpRoyaltyVaultImplClient, [{
    key: "claimRevenueBySnapshotBatch",
    value: (function () {
      var _claimRevenueBySnapshotBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(request) {
        var _yield$this$rpcClient18, call;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              _context33.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "claimRevenueBySnapshotBatch",
                account: this.wallet.account,
                args: [request.snapshotIds, request.token]
              });
            case 2:
              _yield$this$rpcClient18 = _context33.sent;
              call = _yield$this$rpcClient18.request;
              _context33.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context33.abrupt("return", _context33.sent);
            case 7:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
      function claimRevenueBySnapshotBatch(_x23) {
        return _claimRevenueBySnapshotBatch.apply(this, arguments);
      }
      return claimRevenueBySnapshotBatch;
    }()
    /**
     * method claimRevenueBySnapshotBatch for contract IpRoyaltyVaultImpl with only encode
     *
     * @param request IpRoyaltyVaultImplClaimRevenueBySnapshotBatchRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "claimRevenueBySnapshotBatchEncode",
    value: function claimRevenueBySnapshotBatchEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipRoyaltyVaultImplAbi,
          functionName: "claimRevenueBySnapshotBatch",
          args: [request.snapshotIds, request.token]
        })
      };
    }

    /**
     * method claimRevenueByTokenBatch for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplClaimRevenueByTokenBatchRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "claimRevenueByTokenBatch",
    value: (function () {
      var _claimRevenueByTokenBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(request) {
        var _yield$this$rpcClient19, call;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              _context34.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "claimRevenueByTokenBatch",
                account: this.wallet.account,
                args: [request.snapshotId, request.tokenList]
              });
            case 2:
              _yield$this$rpcClient19 = _context34.sent;
              call = _yield$this$rpcClient19.request;
              _context34.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context34.abrupt("return", _context34.sent);
            case 7:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this);
      }));
      function claimRevenueByTokenBatch(_x24) {
        return _claimRevenueByTokenBatch.apply(this, arguments);
      }
      return claimRevenueByTokenBatch;
    }()
    /**
     * method claimRevenueByTokenBatch for contract IpRoyaltyVaultImpl with only encode
     *
     * @param request IpRoyaltyVaultImplClaimRevenueByTokenBatchRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "claimRevenueByTokenBatchEncode",
    value: function claimRevenueByTokenBatchEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipRoyaltyVaultImplAbi,
          functionName: "claimRevenueByTokenBatch",
          args: [request.snapshotId, request.tokenList]
        })
      };
    }

    /**
     * method collectRoyaltyTokens for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplCollectRoyaltyTokensRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "collectRoyaltyTokens",
    value: (function () {
      var _collectRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(request) {
        var _yield$this$rpcClient20, call;
        return _regeneratorRuntime().wrap(function _callee35$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              _context35.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "collectRoyaltyTokens",
                account: this.wallet.account,
                args: [request.ancestorIpId]
              });
            case 2:
              _yield$this$rpcClient20 = _context35.sent;
              call = _yield$this$rpcClient20.request;
              _context35.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context35.abrupt("return", _context35.sent);
            case 7:
            case "end":
              return _context35.stop();
          }
        }, _callee35, this);
      }));
      function collectRoyaltyTokens(_x25) {
        return _collectRoyaltyTokens.apply(this, arguments);
      }
      return collectRoyaltyTokens;
    }()
    /**
     * method collectRoyaltyTokens for contract IpRoyaltyVaultImpl with only encode
     *
     * @param request IpRoyaltyVaultImplCollectRoyaltyTokensRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "collectRoyaltyTokensEncode",
    value: function collectRoyaltyTokensEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipRoyaltyVaultImplAbi,
          functionName: "collectRoyaltyTokens",
          args: [request.ancestorIpId]
        })
      };
    }

    /**
     * method snapshot for contract IpRoyaltyVaultImpl
     *
     * @param request IpRoyaltyVaultImplSnapshotRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "snapshot",
    value: (function () {
      var _snapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {
        var _yield$this$rpcClient21, call;
        return _regeneratorRuntime().wrap(function _callee36$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              _context36.next = 2;
              return this.rpcClient.simulateContract({
                abi: ipRoyaltyVaultImplAbi,
                address: this.address,
                functionName: "snapshot",
                account: this.wallet.account
              });
            case 2:
              _yield$this$rpcClient21 = _context36.sent;
              call = _yield$this$rpcClient21.request;
              _context36.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context36.abrupt("return", _context36.sent);
            case 7:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this);
      }));
      function snapshot() {
        return _snapshot.apply(this, arguments);
      }
      return snapshot;
    }()
    /**
     * method snapshot for contract IpRoyaltyVaultImpl with only encode
     *
     * @param request IpRoyaltyVaultImplSnapshotRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "snapshotEncode",
    value: function snapshotEncode() {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: ipRoyaltyVaultImplAbi,
          functionName: "snapshot"
        })
      };
    }
  }]);
}(IpRoyaltyVaultImplReadOnlyClient);

// Contract LicenseRegistry =============================================================

/**
 * LicenseRegistryAuthorityUpdatedEvent
 *
 * @param authority address
 */

/**
 * LicenseRegistryDefaultLicenseTermsSetEvent
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryExpirationTimeSetEvent
 *
 * @param ipId address
 * @param expireTime uint256
 */

/**
 * LicenseRegistryInitializedEvent
 *
 * @param version uint64
 */

/**
 * LicenseRegistryLicenseTemplateRegisteredEvent
 *
 * @param licenseTemplate address
 */

/**
 * LicenseRegistryLicensingConfigSetForIpEvent
 *
 * @param ipId address
 * @param licensingConfig tuple
 */

/**
 * LicenseRegistryLicensingConfigSetForLicenseEvent
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryUpgradedEvent
 *
 * @param implementation address
 */

/**
 * LicenseRegistryExistsRequest
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param index uint256
 */

/**
 * LicenseRegistryGetAttachedLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetAttachedLicenseTermsCountRequest
 *
 * @param ipId address
 */

/**
 * LicenseRegistryGetDefaultLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetDerivativeIpRequest
 *
 * @param parentIpId address
 * @param index uint256
 */

/**
 * LicenseRegistryGetDerivativeIpResponse
 *
 * @param childIpId address
 */

/**
 * LicenseRegistryGetDerivativeIpCountRequest
 *
 * @param parentIpId address
 */

/**
 * LicenseRegistryGetExpireTimeRequest
 *
 * @param ipId address
 */

/**
 * LicenseRegistryGetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryGetParentIpRequest
 *
 * @param childIpId address
 * @param index uint256
 */

/**
 * LicenseRegistryGetParentIpResponse
 *
 * @param parentIpId address
 */

/**
 * LicenseRegistryGetParentIpCountRequest
 *
 * @param childIpId address
 */

/**
 * LicenseRegistryHasDerivativeIpsRequest
 *
 * @param parentIpId address
 */

/**
 * LicenseRegistryHasIpAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryIsDerivativeIpRequest
 *
 * @param childIpId address
 */

/**
 * LicenseRegistryIsExpiredNowRequest
 *
 * @param ipId address
 */

/**
 * LicenseRegistryIsParentIpRequest
 *
 * @param parentIpId address
 * @param childIpId address
 */

/**
 * LicenseRegistryIsRegisteredLicenseTemplateRequest
 *
 * @param licenseTemplate address
 */

/**
 * LicenseRegistryVerifyMintLicenseTokenRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param isMintedByIpOwner bool
 */

/**
 * LicenseRegistryAttachLicenseTermsToIpRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicenseRegistryInitializeRequest
 *
 * @param accessManager address
 */

/**
 * LicenseRegistryRegisterDerivativeIpRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTemplate address
 * @param licenseTermsIds uint256[]
 * @param isUsingLicenseToken bool
 */

/**
 * LicenseRegistryRegisterLicenseTemplateRequest
 *
 * @param licenseTemplate address
 */

/**
 * LicenseRegistrySetAuthorityRequest
 *
 * @param newAuthority address
 */

/**
 * LicenseRegistrySetDefaultLicenseTermsRequest
 *
 * @param newLicenseTemplate address
 * @param newLicenseTermsId uint256
 */

/**
 * LicenseRegistrySetLicensingConfigForIpRequest
 *
 * @param ipId address
 * @param licensingConfig tuple
 */

/**
 * LicenseRegistrySetLicensingConfigForLicenseRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param licensingConfig tuple
 */

/**
 * LicenseRegistryUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */

/**
 * contract LicenseRegistry event
 */
var LicenseRegistryEventClient = /*#__PURE__*/function () {
  function LicenseRegistryEventClient(rpcClient, address) {
    var _rpcClient$chain7;
    _classCallCheck(this, LicenseRegistryEventClient);
    this.address = address || getAddress(licenseRegistryAddress, (_rpcClient$chain7 = rpcClient.chain) === null || _rpcClient$chain7 === void 0 ? void 0 : _rpcClient$chain7.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event AuthorityUpdated for contract LicenseRegistry
   */
  return _createClass(LicenseRegistryEventClient, [{
    key: "watchAuthorityUpdatedEvent",
    value: function watchAuthorityUpdatedEvent(_onLogs16) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "AuthorityUpdated",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs16(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event AuthorityUpdated for contract LicenseRegistry
     */
  }, {
    key: "parseTxAuthorityUpdatedEvent",
    value: function parseTxAuthorityUpdatedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator16 = _createForOfIteratorHelper(txReceipt.logs),
        _step16;
      try {
        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
          var log = _step16.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "AuthorityUpdated",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "AuthorityUpdated") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator16.e(err);
      } finally {
        _iterator16.f();
      }
      return targetLogs;
    }

    /**
     * event DefaultLicenseTermsSet for contract LicenseRegistry
     */
  }, {
    key: "watchDefaultLicenseTermsSetEvent",
    value: function watchDefaultLicenseTermsSetEvent(_onLogs17) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "DefaultLicenseTermsSet",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs17(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DefaultLicenseTermsSet for contract LicenseRegistry
     */
  }, {
    key: "parseTxDefaultLicenseTermsSetEvent",
    value: function parseTxDefaultLicenseTermsSetEvent(txReceipt) {
      var targetLogs = [];
      var _iterator17 = _createForOfIteratorHelper(txReceipt.logs),
        _step17;
      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var log = _step17.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "DefaultLicenseTermsSet",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DefaultLicenseTermsSet") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }
      return targetLogs;
    }

    /**
     * event ExpirationTimeSet for contract LicenseRegistry
     */
  }, {
    key: "watchExpirationTimeSetEvent",
    value: function watchExpirationTimeSetEvent(_onLogs18) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "ExpirationTimeSet",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs18(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event ExpirationTimeSet for contract LicenseRegistry
     */
  }, {
    key: "parseTxExpirationTimeSetEvent",
    value: function parseTxExpirationTimeSetEvent(txReceipt) {
      var targetLogs = [];
      var _iterator18 = _createForOfIteratorHelper(txReceipt.logs),
        _step18;
      try {
        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
          var log = _step18.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "ExpirationTimeSet",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "ExpirationTimeSet") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator18.e(err);
      } finally {
        _iterator18.f();
      }
      return targetLogs;
    }

    /**
     * event Initialized for contract LicenseRegistry
     */
  }, {
    key: "watchInitializedEvent",
    value: function watchInitializedEvent(_onLogs19) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "Initialized",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs19(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Initialized for contract LicenseRegistry
     */
  }, {
    key: "parseTxInitializedEvent",
    value: function parseTxInitializedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator19 = _createForOfIteratorHelper(txReceipt.logs),
        _step19;
      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var log = _step19.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "Initialized",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Initialized") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }
      return targetLogs;
    }

    /**
     * event LicenseTemplateRegistered for contract LicenseRegistry
     */
  }, {
    key: "watchLicenseTemplateRegisteredEvent",
    value: function watchLicenseTemplateRegisteredEvent(_onLogs20) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "LicenseTemplateRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs20(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTemplateRegistered for contract LicenseRegistry
     */
  }, {
    key: "parseTxLicenseTemplateRegisteredEvent",
    value: function parseTxLicenseTemplateRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator20 = _createForOfIteratorHelper(txReceipt.logs),
        _step20;
      try {
        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
          var log = _step20.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "LicenseTemplateRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTemplateRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator20.e(err);
      } finally {
        _iterator20.f();
      }
      return targetLogs;
    }

    /**
     * event LicensingConfigSetForIP for contract LicenseRegistry
     */
  }, {
    key: "watchLicensingConfigSetForIpEvent",
    value: function watchLicensingConfigSetForIpEvent(_onLogs21) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "LicensingConfigSetForIP",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs21(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicensingConfigSetForIP for contract LicenseRegistry
     */
  }, {
    key: "parseTxLicensingConfigSetForIpEvent",
    value: function parseTxLicensingConfigSetForIpEvent(txReceipt) {
      var targetLogs = [];
      var _iterator21 = _createForOfIteratorHelper(txReceipt.logs),
        _step21;
      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var log = _step21.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "LicensingConfigSetForIP",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicensingConfigSetForIP") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }
      return targetLogs;
    }

    /**
     * event LicensingConfigSetForLicense for contract LicenseRegistry
     */
  }, {
    key: "watchLicensingConfigSetForLicenseEvent",
    value: function watchLicensingConfigSetForLicenseEvent(_onLogs22) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "LicensingConfigSetForLicense",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs22(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicensingConfigSetForLicense for contract LicenseRegistry
     */
  }, {
    key: "parseTxLicensingConfigSetForLicenseEvent",
    value: function parseTxLicensingConfigSetForLicenseEvent(txReceipt) {
      var targetLogs = [];
      var _iterator22 = _createForOfIteratorHelper(txReceipt.logs),
        _step22;
      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var log = _step22.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "LicensingConfigSetForLicense",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicensingConfigSetForLicense") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
      return targetLogs;
    }

    /**
     * event Upgraded for contract LicenseRegistry
     */
  }, {
    key: "watchUpgradedEvent",
    value: function watchUpgradedEvent(_onLogs23) {
      return this.rpcClient.watchContractEvent({
        abi: licenseRegistryAbi,
        address: this.address,
        eventName: "Upgraded",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs23(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Upgraded for contract LicenseRegistry
     */
  }, {
    key: "parseTxUpgradedEvent",
    value: function parseTxUpgradedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator23 = _createForOfIteratorHelper(txReceipt.logs),
        _step23;
      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var log = _step23.value;
          try {
            var event = decodeEventLog({
              abi: licenseRegistryAbi,
              eventName: "Upgraded",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Upgraded") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract LicenseRegistry readonly method
 */
var LicenseRegistryReadOnlyClient = /*#__PURE__*/function (_LicenseRegistryEvent) {
  function LicenseRegistryReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, LicenseRegistryReadOnlyClient);
    return _callSuper(this, LicenseRegistryReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method DISPUTE_MODULE for contract LicenseRegistry
   *
   * @param request LicenseRegistryDisputeModuleRequest
   * @return Promise<LicenseRegistryDisputeModuleResponse>
   */
  _inherits(LicenseRegistryReadOnlyClient, _LicenseRegistryEvent);
  return _createClass(LicenseRegistryReadOnlyClient, [{
    key: "disputeModule",
    value: (function () {
      var _disputeModule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              _context37.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "DISPUTE_MODULE"
              });
            case 2:
              return _context37.abrupt("return", _context37.sent);
            case 3:
            case "end":
              return _context37.stop();
          }
        }, _callee37, this);
      }));
      function disputeModule() {
        return _disputeModule.apply(this, arguments);
      }
      return disputeModule;
    }()
    /**
     * method EXPIRATION_TIME for contract LicenseRegistry
     *
     * @param request LicenseRegistryExpirationTimeRequest
     * @return Promise<LicenseRegistryExpirationTimeResponse>
     */
    )
  }, {
    key: "expirationTime",
    value: (function () {
      var _expirationTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {
        return _regeneratorRuntime().wrap(function _callee38$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              _context38.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "EXPIRATION_TIME"
              });
            case 2:
              return _context38.abrupt("return", _context38.sent);
            case 3:
            case "end":
              return _context38.stop();
          }
        }, _callee38, this);
      }));
      function expirationTime() {
        return _expirationTime.apply(this, arguments);
      }
      return expirationTime;
    }()
    /**
     * method IP_GRAPH_ACL for contract LicenseRegistry
     *
     * @param request LicenseRegistryIpGraphAclRequest
     * @return Promise<LicenseRegistryIpGraphAclResponse>
     */
    )
  }, {
    key: "ipGraphAcl",
    value: (function () {
      var _ipGraphAcl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {
        return _regeneratorRuntime().wrap(function _callee39$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              _context39.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "IP_GRAPH_ACL"
              });
            case 2:
              return _context39.abrupt("return", _context39.sent);
            case 3:
            case "end":
              return _context39.stop();
          }
        }, _callee39, this);
      }));
      function ipGraphAcl() {
        return _ipGraphAcl.apply(this, arguments);
      }
      return ipGraphAcl;
    }()
    /**
     * method IP_GRAPH_CONTRACT for contract LicenseRegistry
     *
     * @param request LicenseRegistryIpGraphContractRequest
     * @return Promise<LicenseRegistryIpGraphContractResponse>
     */
    )
  }, {
    key: "ipGraphContract",
    value: (function () {
      var _ipGraphContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              _context40.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "IP_GRAPH_CONTRACT"
              });
            case 2:
              return _context40.abrupt("return", _context40.sent);
            case 3:
            case "end":
              return _context40.stop();
          }
        }, _callee40, this);
      }));
      function ipGraphContract() {
        return _ipGraphContract.apply(this, arguments);
      }
      return ipGraphContract;
    }()
    /**
     * method LICENSING_MODULE for contract LicenseRegistry
     *
     * @param request LicenseRegistryLicensingModuleRequest
     * @return Promise<LicenseRegistryLicensingModuleResponse>
     */
    )
  }, {
    key: "licensingModule",
    value: (function () {
      var _licensingModule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              _context41.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "LICENSING_MODULE"
              });
            case 2:
              return _context41.abrupt("return", _context41.sent);
            case 3:
            case "end":
              return _context41.stop();
          }
        }, _callee41, this);
      }));
      function licensingModule() {
        return _licensingModule.apply(this, arguments);
      }
      return licensingModule;
    }()
    /**
     * method UPGRADE_INTERFACE_VERSION for contract LicenseRegistry
     *
     * @param request LicenseRegistryUpgradeInterfaceVersionRequest
     * @return Promise<LicenseRegistryUpgradeInterfaceVersionResponse>
     */
    )
  }, {
    key: "upgradeInterfaceVersion",
    value: (function () {
      var _upgradeInterfaceVersion2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
        return _regeneratorRuntime().wrap(function _callee42$(_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              _context42.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "UPGRADE_INTERFACE_VERSION"
              });
            case 2:
              return _context42.abrupt("return", _context42.sent);
            case 3:
            case "end":
              return _context42.stop();
          }
        }, _callee42, this);
      }));
      function upgradeInterfaceVersion() {
        return _upgradeInterfaceVersion2.apply(this, arguments);
      }
      return upgradeInterfaceVersion;
    }()
    /**
     * method authority for contract LicenseRegistry
     *
     * @param request LicenseRegistryAuthorityRequest
     * @return Promise<LicenseRegistryAuthorityResponse>
     */
    )
  }, {
    key: "authority",
    value: (function () {
      var _authority2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {
        return _regeneratorRuntime().wrap(function _callee43$(_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              _context43.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "authority"
              });
            case 2:
              return _context43.abrupt("return", _context43.sent);
            case 3:
            case "end":
              return _context43.stop();
          }
        }, _callee43, this);
      }));
      function authority() {
        return _authority2.apply(this, arguments);
      }
      return authority;
    }()
    /**
     * method exists for contract LicenseRegistry
     *
     * @param request LicenseRegistryExistsRequest
     * @return Promise<LicenseRegistryExistsResponse>
     */
    )
  }, {
    key: "exists",
    value: (function () {
      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(request) {
        return _regeneratorRuntime().wrap(function _callee44$(_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              _context44.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "exists",
                args: [request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              return _context44.abrupt("return", _context44.sent);
            case 3:
            case "end":
              return _context44.stop();
          }
        }, _callee44, this);
      }));
      function exists(_x26) {
        return _exists.apply(this, arguments);
      }
      return exists;
    }()
    /**
     * method getAttachedLicenseTerms for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetAttachedLicenseTermsRequest
     * @return Promise<LicenseRegistryGetAttachedLicenseTermsResponse>
     */
    )
  }, {
    key: "getAttachedLicenseTerms",
    value: (function () {
      var _getAttachedLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee45$(_context45) {
          while (1) switch (_context45.prev = _context45.next) {
            case 0:
              _context45.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getAttachedLicenseTerms",
                args: [request.ipId, request.index]
              });
            case 2:
              result = _context45.sent;
              return _context45.abrupt("return", {
                licenseTemplate: result[0],
                licenseTermsId: result[1]
              });
            case 4:
            case "end":
              return _context45.stop();
          }
        }, _callee45, this);
      }));
      function getAttachedLicenseTerms(_x27) {
        return _getAttachedLicenseTerms.apply(this, arguments);
      }
      return getAttachedLicenseTerms;
    }()
    /**
     * method getAttachedLicenseTermsCount for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetAttachedLicenseTermsCountRequest
     * @return Promise<LicenseRegistryGetAttachedLicenseTermsCountResponse>
     */
    )
  }, {
    key: "getAttachedLicenseTermsCount",
    value: (function () {
      var _getAttachedLicenseTermsCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(request) {
        return _regeneratorRuntime().wrap(function _callee46$(_context46) {
          while (1) switch (_context46.prev = _context46.next) {
            case 0:
              _context46.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getAttachedLicenseTermsCount",
                args: [request.ipId]
              });
            case 2:
              return _context46.abrupt("return", _context46.sent);
            case 3:
            case "end":
              return _context46.stop();
          }
        }, _callee46, this);
      }));
      function getAttachedLicenseTermsCount(_x28) {
        return _getAttachedLicenseTermsCount.apply(this, arguments);
      }
      return getAttachedLicenseTermsCount;
    }()
    /**
     * method getDefaultLicenseTerms for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetDefaultLicenseTermsRequest
     * @return Promise<LicenseRegistryGetDefaultLicenseTermsResponse>
     */
    )
  }, {
    key: "getDefaultLicenseTerms",
    value: (function () {
      var _getDefaultLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47() {
        var result;
        return _regeneratorRuntime().wrap(function _callee47$(_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              _context47.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getDefaultLicenseTerms"
              });
            case 2:
              result = _context47.sent;
              return _context47.abrupt("return", {
                licenseTemplate: result[0],
                licenseTermsId: result[1]
              });
            case 4:
            case "end":
              return _context47.stop();
          }
        }, _callee47, this);
      }));
      function getDefaultLicenseTerms() {
        return _getDefaultLicenseTerms.apply(this, arguments);
      }
      return getDefaultLicenseTerms;
    }()
    /**
     * method getDerivativeIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetDerivativeIpRequest
     * @return Promise<LicenseRegistryGetDerivativeIpResponse>
     */
    )
  }, {
    key: "getDerivativeIp",
    value: (function () {
      var _getDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee48$(_context48) {
          while (1) switch (_context48.prev = _context48.next) {
            case 0:
              _context48.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getDerivativeIp",
                args: [request.parentIpId, request.index]
              });
            case 2:
              result = _context48.sent;
              return _context48.abrupt("return", {
                childIpId: result
              });
            case 4:
            case "end":
              return _context48.stop();
          }
        }, _callee48, this);
      }));
      function getDerivativeIp(_x29) {
        return _getDerivativeIp.apply(this, arguments);
      }
      return getDerivativeIp;
    }()
    /**
     * method getDerivativeIpCount for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetDerivativeIpCountRequest
     * @return Promise<LicenseRegistryGetDerivativeIpCountResponse>
     */
    )
  }, {
    key: "getDerivativeIpCount",
    value: (function () {
      var _getDerivativeIpCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49(request) {
        return _regeneratorRuntime().wrap(function _callee49$(_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              _context49.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getDerivativeIpCount",
                args: [request.parentIpId]
              });
            case 2:
              return _context49.abrupt("return", _context49.sent);
            case 3:
            case "end":
              return _context49.stop();
          }
        }, _callee49, this);
      }));
      function getDerivativeIpCount(_x30) {
        return _getDerivativeIpCount.apply(this, arguments);
      }
      return getDerivativeIpCount;
    }()
    /**
     * method getExpireTime for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetExpireTimeRequest
     * @return Promise<LicenseRegistryGetExpireTimeResponse>
     */
    )
  }, {
    key: "getExpireTime",
    value: (function () {
      var _getExpireTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50(request) {
        return _regeneratorRuntime().wrap(function _callee50$(_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              _context50.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getExpireTime",
                args: [request.ipId]
              });
            case 2:
              return _context50.abrupt("return", _context50.sent);
            case 3:
            case "end":
              return _context50.stop();
          }
        }, _callee50, this);
      }));
      function getExpireTime(_x31) {
        return _getExpireTime.apply(this, arguments);
      }
      return getExpireTime;
    }()
    /**
     * method getLicensingConfig for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetLicensingConfigRequest
     * @return Promise<LicenseRegistryGetLicensingConfigResponse>
     */
    )
  }, {
    key: "getLicensingConfig",
    value: (function () {
      var _getLicensingConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee51(request) {
        return _regeneratorRuntime().wrap(function _callee51$(_context51) {
          while (1) switch (_context51.prev = _context51.next) {
            case 0:
              _context51.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getLicensingConfig",
                args: [request.ipId, request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              return _context51.abrupt("return", _context51.sent);
            case 3:
            case "end":
              return _context51.stop();
          }
        }, _callee51, this);
      }));
      function getLicensingConfig(_x32) {
        return _getLicensingConfig.apply(this, arguments);
      }
      return getLicensingConfig;
    }()
    /**
     * method getParentIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetParentIpRequest
     * @return Promise<LicenseRegistryGetParentIpResponse>
     */
    )
  }, {
    key: "getParentIp",
    value: (function () {
      var _getParentIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee52$(_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              _context52.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getParentIp",
                args: [request.childIpId, request.index]
              });
            case 2:
              result = _context52.sent;
              return _context52.abrupt("return", {
                parentIpId: result
              });
            case 4:
            case "end":
              return _context52.stop();
          }
        }, _callee52, this);
      }));
      function getParentIp(_x33) {
        return _getParentIp.apply(this, arguments);
      }
      return getParentIp;
    }()
    /**
     * method getParentIpCount for contract LicenseRegistry
     *
     * @param request LicenseRegistryGetParentIpCountRequest
     * @return Promise<LicenseRegistryGetParentIpCountResponse>
     */
    )
  }, {
    key: "getParentIpCount",
    value: (function () {
      var _getParentIpCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53(request) {
        return _regeneratorRuntime().wrap(function _callee53$(_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              _context53.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "getParentIpCount",
                args: [request.childIpId]
              });
            case 2:
              return _context53.abrupt("return", _context53.sent);
            case 3:
            case "end":
              return _context53.stop();
          }
        }, _callee53, this);
      }));
      function getParentIpCount(_x34) {
        return _getParentIpCount.apply(this, arguments);
      }
      return getParentIpCount;
    }()
    /**
     * method hasDerivativeIps for contract LicenseRegistry
     *
     * @param request LicenseRegistryHasDerivativeIpsRequest
     * @return Promise<LicenseRegistryHasDerivativeIpsResponse>
     */
    )
  }, {
    key: "hasDerivativeIps",
    value: (function () {
      var _hasDerivativeIps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54(request) {
        return _regeneratorRuntime().wrap(function _callee54$(_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              _context54.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "hasDerivativeIps",
                args: [request.parentIpId]
              });
            case 2:
              return _context54.abrupt("return", _context54.sent);
            case 3:
            case "end":
              return _context54.stop();
          }
        }, _callee54, this);
      }));
      function hasDerivativeIps(_x35) {
        return _hasDerivativeIps.apply(this, arguments);
      }
      return hasDerivativeIps;
    }()
    /**
     * method hasIpAttachedLicenseTerms for contract LicenseRegistry
     *
     * @param request LicenseRegistryHasIpAttachedLicenseTermsRequest
     * @return Promise<LicenseRegistryHasIpAttachedLicenseTermsResponse>
     */
    )
  }, {
    key: "hasIpAttachedLicenseTerms",
    value: (function () {
      var _hasIpAttachedLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(request) {
        return _regeneratorRuntime().wrap(function _callee55$(_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              _context55.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "hasIpAttachedLicenseTerms",
                args: [request.ipId, request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              return _context55.abrupt("return", _context55.sent);
            case 3:
            case "end":
              return _context55.stop();
          }
        }, _callee55, this);
      }));
      function hasIpAttachedLicenseTerms(_x36) {
        return _hasIpAttachedLicenseTerms.apply(this, arguments);
      }
      return hasIpAttachedLicenseTerms;
    }()
    /**
     * method isConsumingScheduledOp for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsConsumingScheduledOpRequest
     * @return Promise<LicenseRegistryIsConsumingScheduledOpResponse>
     */
    )
  }, {
    key: "isConsumingScheduledOp",
    value: (function () {
      var _isConsumingScheduledOp2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56() {
        return _regeneratorRuntime().wrap(function _callee56$(_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              _context56.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isConsumingScheduledOp"
              });
            case 2:
              return _context56.abrupt("return", _context56.sent);
            case 3:
            case "end":
              return _context56.stop();
          }
        }, _callee56, this);
      }));
      function isConsumingScheduledOp() {
        return _isConsumingScheduledOp2.apply(this, arguments);
      }
      return isConsumingScheduledOp;
    }()
    /**
     * method isDerivativeIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsDerivativeIpRequest
     * @return Promise<LicenseRegistryIsDerivativeIpResponse>
     */
    )
  }, {
    key: "isDerivativeIp",
    value: (function () {
      var _isDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee57(request) {
        return _regeneratorRuntime().wrap(function _callee57$(_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              _context57.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isDerivativeIp",
                args: [request.childIpId]
              });
            case 2:
              return _context57.abrupt("return", _context57.sent);
            case 3:
            case "end":
              return _context57.stop();
          }
        }, _callee57, this);
      }));
      function isDerivativeIp(_x37) {
        return _isDerivativeIp.apply(this, arguments);
      }
      return isDerivativeIp;
    }()
    /**
     * method isExpiredNow for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsExpiredNowRequest
     * @return Promise<LicenseRegistryIsExpiredNowResponse>
     */
    )
  }, {
    key: "isExpiredNow",
    value: (function () {
      var _isExpiredNow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee58(request) {
        return _regeneratorRuntime().wrap(function _callee58$(_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              _context58.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isExpiredNow",
                args: [request.ipId]
              });
            case 2:
              return _context58.abrupt("return", _context58.sent);
            case 3:
            case "end":
              return _context58.stop();
          }
        }, _callee58, this);
      }));
      function isExpiredNow(_x38) {
        return _isExpiredNow.apply(this, arguments);
      }
      return isExpiredNow;
    }()
    /**
     * method isParentIp for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsParentIpRequest
     * @return Promise<LicenseRegistryIsParentIpResponse>
     */
    )
  }, {
    key: "isParentIp",
    value: (function () {
      var _isParentIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee59(request) {
        return _regeneratorRuntime().wrap(function _callee59$(_context59) {
          while (1) switch (_context59.prev = _context59.next) {
            case 0:
              _context59.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isParentIp",
                args: [request.parentIpId, request.childIpId]
              });
            case 2:
              return _context59.abrupt("return", _context59.sent);
            case 3:
            case "end":
              return _context59.stop();
          }
        }, _callee59, this);
      }));
      function isParentIp(_x39) {
        return _isParentIp.apply(this, arguments);
      }
      return isParentIp;
    }()
    /**
     * method isRegisteredLicenseTemplate for contract LicenseRegistry
     *
     * @param request LicenseRegistryIsRegisteredLicenseTemplateRequest
     * @return Promise<LicenseRegistryIsRegisteredLicenseTemplateResponse>
     */
    )
  }, {
    key: "isRegisteredLicenseTemplate",
    value: (function () {
      var _isRegisteredLicenseTemplate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee60(request) {
        return _regeneratorRuntime().wrap(function _callee60$(_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              _context60.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "isRegisteredLicenseTemplate",
                args: [request.licenseTemplate]
              });
            case 2:
              return _context60.abrupt("return", _context60.sent);
            case 3:
            case "end":
              return _context60.stop();
          }
        }, _callee60, this);
      }));
      function isRegisteredLicenseTemplate(_x40) {
        return _isRegisteredLicenseTemplate.apply(this, arguments);
      }
      return isRegisteredLicenseTemplate;
    }()
    /**
     * method proxiableUUID for contract LicenseRegistry
     *
     * @param request LicenseRegistryProxiableUuidRequest
     * @return Promise<LicenseRegistryProxiableUuidResponse>
     */
    )
  }, {
    key: "proxiableUuid",
    value: (function () {
      var _proxiableUuid2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee61() {
        return _regeneratorRuntime().wrap(function _callee61$(_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              _context61.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "proxiableUUID"
              });
            case 2:
              return _context61.abrupt("return", _context61.sent);
            case 3:
            case "end":
              return _context61.stop();
          }
        }, _callee61, this);
      }));
      function proxiableUuid() {
        return _proxiableUuid2.apply(this, arguments);
      }
      return proxiableUuid;
    }()
    /**
     * method verifyMintLicenseToken for contract LicenseRegistry
     *
     * @param request LicenseRegistryVerifyMintLicenseTokenRequest
     * @return Promise<LicenseRegistryVerifyMintLicenseTokenResponse>
     */
    )
  }, {
    key: "verifyMintLicenseToken",
    value: (function () {
      var _verifyMintLicenseToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee62(request) {
        return _regeneratorRuntime().wrap(function _callee62$(_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              _context62.next = 2;
              return this.rpcClient.readContract({
                abi: licenseRegistryAbi,
                address: this.address,
                functionName: "verifyMintLicenseToken",
                args: [request.licensorIpId, request.licenseTemplate, request.licenseTermsId, request.isMintedByIpOwner]
              });
            case 2:
              return _context62.abrupt("return", _context62.sent);
            case 3:
            case "end":
              return _context62.stop();
          }
        }, _callee62, this);
      }));
      function verifyMintLicenseToken(_x41) {
        return _verifyMintLicenseToken.apply(this, arguments);
      }
      return verifyMintLicenseToken;
    }())
  }]);
}(LicenseRegistryEventClient);

// Contract LicenseToken =============================================================

/**
 * LicenseTokenOwnerOfRequest
 *
 * @param tokenId uint256
 */

/**
 * contract LicenseToken readonly method
 */
var LicenseTokenReadOnlyClient = /*#__PURE__*/function () {
  function LicenseTokenReadOnlyClient(rpcClient, address) {
    var _rpcClient$chain8;
    _classCallCheck(this, LicenseTokenReadOnlyClient);
    this.address = address || getAddress(licenseTokenAddress, (_rpcClient$chain8 = rpcClient.chain) === null || _rpcClient$chain8 === void 0 ? void 0 : _rpcClient$chain8.id);
    this.rpcClient = rpcClient;
  }

  /**
   * method ownerOf for contract LicenseToken
   *
   * @param request LicenseTokenOwnerOfRequest
   * @return Promise<LicenseTokenOwnerOfResponse>
   */
  return _createClass(LicenseTokenReadOnlyClient, [{
    key: "ownerOf",
    value: (function () {
      var _ownerOf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee72(request) {
        return _regeneratorRuntime().wrap(function _callee72$(_context72) {
          while (1) switch (_context72.prev = _context72.next) {
            case 0:
              _context72.next = 2;
              return this.rpcClient.readContract({
                abi: licenseTokenAbi,
                address: this.address,
                functionName: "ownerOf",
                args: [request.tokenId]
              });
            case 2:
              return _context72.abrupt("return", _context72.sent);
            case 3:
            case "end":
              return _context72.stop();
          }
        }, _callee72, this);
      }));
      function ownerOf(_x51) {
        return _ownerOf.apply(this, arguments);
      }
      return ownerOf;
    }())
  }]);
}();

// Contract LicensingModule =============================================================

/**
 * LicensingModuleLicenseTermsAttachedEvent
 *
 * @param caller address
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicensingModuleLicenseTokensMintedEvent
 *
 * @param caller address
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param startLicenseTokenId uint256
 */

/**
 * LicensingModuleAttachLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 */

/**
 * LicensingModuleMintLicenseTokensRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 */

/**
 * LicensingModuleRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param licenseTemplate address
 * @param royaltyContext bytes
 */

/**
 * LicensingModuleRegisterDerivativeWithLicenseTokensRequest
 *
 * @param childIpId address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 */

/**
 * contract LicensingModule event
 */
var LicensingModuleEventClient = /*#__PURE__*/function () {
  function LicensingModuleEventClient(rpcClient, address) {
    var _rpcClient$chain9;
    _classCallCheck(this, LicensingModuleEventClient);
    this.address = address || getAddress(licensingModuleAddress, (_rpcClient$chain9 = rpcClient.chain) === null || _rpcClient$chain9 === void 0 ? void 0 : _rpcClient$chain9.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event LicenseTermsAttached for contract LicensingModule
   */
  return _createClass(LicensingModuleEventClient, [{
    key: "watchLicenseTermsAttachedEvent",
    value: function watchLicenseTermsAttachedEvent(_onLogs24) {
      return this.rpcClient.watchContractEvent({
        abi: licensingModuleAbi,
        address: this.address,
        eventName: "LicenseTermsAttached",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs24(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTermsAttached for contract LicensingModule
     */
  }, {
    key: "parseTxLicenseTermsAttachedEvent",
    value: function parseTxLicenseTermsAttachedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator24 = _createForOfIteratorHelper(txReceipt.logs),
        _step24;
      try {
        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
          var log = _step24.value;
          try {
            var event = decodeEventLog({
              abi: licensingModuleAbi,
              eventName: "LicenseTermsAttached",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTermsAttached") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }
      return targetLogs;
    }

    /**
     * event LicenseTokensMinted for contract LicensingModule
     */
  }, {
    key: "watchLicenseTokensMintedEvent",
    value: function watchLicenseTokensMintedEvent(_onLogs25) {
      return this.rpcClient.watchContractEvent({
        abi: licensingModuleAbi,
        address: this.address,
        eventName: "LicenseTokensMinted",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs25(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTokensMinted for contract LicensingModule
     */
  }, {
    key: "parseTxLicenseTokensMintedEvent",
    value: function parseTxLicenseTokensMintedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator25 = _createForOfIteratorHelper(txReceipt.logs),
        _step25;
      try {
        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
          var log = _step25.value;
          try {
            var event = decodeEventLog({
              abi: licensingModuleAbi,
              eventName: "LicenseTokensMinted",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTokensMinted") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator25.e(err);
      } finally {
        _iterator25.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract LicensingModule write method
 */
var LicensingModuleClient = /*#__PURE__*/function (_LicensingModuleEvent) {
  function LicensingModuleClient(rpcClient, wallet, address) {
    var _this8;
    _classCallCheck(this, LicensingModuleClient);
    _this8 = _callSuper(this, LicensingModuleClient, [rpcClient, address]);
    _this8.wallet = wallet;
    return _this8;
  }

  /**
   * method attachLicenseTerms for contract LicensingModule
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(LicensingModuleClient, _LicensingModuleEvent);
  return _createClass(LicensingModuleClient, [{
    key: "attachLicenseTerms",
    value: (function () {
      var _attachLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee73(request) {
        var _yield$this$rpcClient31, call;
        return _regeneratorRuntime().wrap(function _callee73$(_context73) {
          while (1) switch (_context73.prev = _context73.next) {
            case 0:
              _context73.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "attachLicenseTerms",
                account: this.wallet.account,
                args: [request.ipId, request.licenseTemplate, request.licenseTermsId]
              });
            case 2:
              _yield$this$rpcClient31 = _context73.sent;
              call = _yield$this$rpcClient31.request;
              _context73.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context73.abrupt("return", _context73.sent);
            case 7:
            case "end":
              return _context73.stop();
          }
        }, _callee73, this);
      }));
      function attachLicenseTerms(_x52) {
        return _attachLicenseTerms.apply(this, arguments);
      }
      return attachLicenseTerms;
    }()
    /**
     * method attachLicenseTerms for contract LicensingModule with only encode
     *
     * @param request LicensingModuleAttachLicenseTermsRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "attachLicenseTermsEncode",
    value: function attachLicenseTermsEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: licensingModuleAbi,
          functionName: "attachLicenseTerms",
          args: [request.ipId, request.licenseTemplate, request.licenseTermsId]
        })
      };
    }

    /**
     * method mintLicenseTokens for contract LicensingModule
     *
     * @param request LicensingModuleMintLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "mintLicenseTokens",
    value: (function () {
      var _mintLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee74(request) {
        var _yield$this$rpcClient32, call;
        return _regeneratorRuntime().wrap(function _callee74$(_context74) {
          while (1) switch (_context74.prev = _context74.next) {
            case 0:
              _context74.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "mintLicenseTokens",
                account: this.wallet.account,
                args: [request.licensorIpId, request.licenseTemplate, request.licenseTermsId, request.amount, request.receiver, request.royaltyContext]
              });
            case 2:
              _yield$this$rpcClient32 = _context74.sent;
              call = _yield$this$rpcClient32.request;
              _context74.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context74.abrupt("return", _context74.sent);
            case 7:
            case "end":
              return _context74.stop();
          }
        }, _callee74, this);
      }));
      function mintLicenseTokens(_x53) {
        return _mintLicenseTokens.apply(this, arguments);
      }
      return mintLicenseTokens;
    }()
    /**
     * method mintLicenseTokens for contract LicensingModule with only encode
     *
     * @param request LicensingModuleMintLicenseTokensRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "mintLicenseTokensEncode",
    value: function mintLicenseTokensEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: licensingModuleAbi,
          functionName: "mintLicenseTokens",
          args: [request.licensorIpId, request.licenseTemplate, request.licenseTermsId, request.amount, request.receiver, request.royaltyContext]
        })
      };
    }

    /**
     * method registerDerivative for contract LicensingModule
     *
     * @param request LicensingModuleRegisterDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerDerivative",
    value: (function () {
      var _registerDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee75(request) {
        var _yield$this$rpcClient33, call;
        return _regeneratorRuntime().wrap(function _callee75$(_context75) {
          while (1) switch (_context75.prev = _context75.next) {
            case 0:
              _context75.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "registerDerivative",
                account: this.wallet.account,
                args: [request.childIpId, request.parentIpIds, request.licenseTermsIds, request.licenseTemplate, request.royaltyContext]
              });
            case 2:
              _yield$this$rpcClient33 = _context75.sent;
              call = _yield$this$rpcClient33.request;
              _context75.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context75.abrupt("return", _context75.sent);
            case 7:
            case "end":
              return _context75.stop();
          }
        }, _callee75, this);
      }));
      function registerDerivative(_x54) {
        return _registerDerivative.apply(this, arguments);
      }
      return registerDerivative;
    }()
    /**
     * method registerDerivative for contract LicensingModule with only encode
     *
     * @param request LicensingModuleRegisterDerivativeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerDerivativeEncode",
    value: function registerDerivativeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: licensingModuleAbi,
          functionName: "registerDerivative",
          args: [request.childIpId, request.parentIpIds, request.licenseTermsIds, request.licenseTemplate, request.royaltyContext]
        })
      };
    }

    /**
     * method registerDerivativeWithLicenseTokens for contract LicensingModule
     *
     * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerDerivativeWithLicenseTokens",
    value: (function () {
      var _registerDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee76(request) {
        var _yield$this$rpcClient34, call;
        return _regeneratorRuntime().wrap(function _callee76$(_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              _context76.next = 2;
              return this.rpcClient.simulateContract({
                abi: licensingModuleAbi,
                address: this.address,
                functionName: "registerDerivativeWithLicenseTokens",
                account: this.wallet.account,
                args: [request.childIpId, request.licenseTokenIds, request.royaltyContext]
              });
            case 2:
              _yield$this$rpcClient34 = _context76.sent;
              call = _yield$this$rpcClient34.request;
              _context76.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context76.abrupt("return", _context76.sent);
            case 7:
            case "end":
              return _context76.stop();
          }
        }, _callee76, this);
      }));
      function registerDerivativeWithLicenseTokens(_x55) {
        return _registerDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerDerivativeWithLicenseTokens;
    }()
    /**
     * method registerDerivativeWithLicenseTokens for contract LicensingModule with only encode
     *
     * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerDerivativeWithLicenseTokensEncode",
    value: function registerDerivativeWithLicenseTokensEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: licensingModuleAbi,
          functionName: "registerDerivativeWithLicenseTokens",
          args: [request.childIpId, request.licenseTokenIds, request.royaltyContext]
        })
      };
    }
  }]);
}(LicensingModuleEventClient);

// Contract PILicenseTemplate =============================================================

/**
 * PiLicenseTemplateAuthorityUpdatedEvent
 *
 * @param authority address
 */

/**
 * PiLicenseTemplateDerivativeApprovedEvent
 *
 * @param licenseTermsId uint256
 * @param ipId address
 * @param caller address
 * @param approved bool
 */

/**
 * PiLicenseTemplateInitializedEvent
 *
 * @param version uint64
 */

/**
 * PiLicenseTemplateLicenseTermsRegisteredEvent
 *
 * @param licenseTermsId uint256
 * @param licenseTemplate address
 * @param licenseTerms bytes
 */

/**
 * PiLicenseTemplateUpgradedEvent
 *
 * @param implementation address
 */

/**
 * PiLicenseTemplateExistsRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetEarlierExpireTimeRequest
 *
 * @param licenseTermsIds uint256[]
 * @param start uint256
 */

/**
 * PiLicenseTemplateGetExpireTimeRequest
 *
 * @param licenseTermsId uint256
 * @param start uint256
 */

/**
 * PiLicenseTemplateGetLicenseTermsRequest
 *
 * @param selectedLicenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetLicenseTermsResponse
 *
 * @param terms tuple
 */

/**
 * PiLicenseTemplateGetLicenseTermsIdRequest
 *
 * @param terms tuple
 */

/**
 * PiLicenseTemplateGetLicenseTermsIdResponse
 *
 * @param selectedLicenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetLicenseTermsUriRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetRoyaltyPolicyRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateGetRoyaltyPolicyResponse
 *
 * @param royaltyPolicy address
 * @param royaltyData bytes
 * @param mintingFee uint256
 * @param currency address
 */

/**
 * PiLicenseTemplateIsDerivativeApprovedRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 */

/**
 * PiLicenseTemplateIsLicenseTransferableRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 */

/**
 * PiLicenseTemplateToJsonRequest
 *
 * @param licenseTermsId uint256
 */

/**
 * PiLicenseTemplateVerifyCompatibleLicensesRequest
 *
 * @param licenseTermsIds uint256[]
 */

/**
 * PiLicenseTemplateInitializeRequest
 *
 * @param accessManager address
 * @param name string
 * @param metadataURI string
 */

/**
 * PiLicenseTemplateRegisterLicenseTermsRequest
 *
 * @param terms tuple
 */

/**
 * PiLicenseTemplateSetApprovalRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 * @param approved bool
 */

/**
 * PiLicenseTemplateSetAuthorityRequest
 *
 * @param newAuthority address
 */

/**
 * PiLicenseTemplateUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 */

/**
 * PiLicenseTemplateVerifyMintLicenseTokenRequest
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 address
 * @param 3 uint256
 */

/**
 * PiLicenseTemplateVerifyRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param licensee address
 */

/**
 * PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param childIpOwner address
 */

/**
 * contract PILicenseTemplate event
 */
var PiLicenseTemplateEventClient = /*#__PURE__*/function () {
  function PiLicenseTemplateEventClient(rpcClient, address) {
    var _rpcClient$chain11;
    _classCallCheck(this, PiLicenseTemplateEventClient);
    this.address = address || getAddress(piLicenseTemplateAddress, (_rpcClient$chain11 = rpcClient.chain) === null || _rpcClient$chain11 === void 0 ? void 0 : _rpcClient$chain11.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event AuthorityUpdated for contract PILicenseTemplate
   */
  return _createClass(PiLicenseTemplateEventClient, [{
    key: "watchAuthorityUpdatedEvent",
    value: function watchAuthorityUpdatedEvent(_onLogs26) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "AuthorityUpdated",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs26(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event AuthorityUpdated for contract PILicenseTemplate
     */
  }, {
    key: "parseTxAuthorityUpdatedEvent",
    value: function parseTxAuthorityUpdatedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator26 = _createForOfIteratorHelper(txReceipt.logs),
        _step26;
      try {
        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
          var log = _step26.value;
          try {
            var event = decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "AuthorityUpdated",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "AuthorityUpdated") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator26.e(err);
      } finally {
        _iterator26.f();
      }
      return targetLogs;
    }

    /**
     * event DerivativeApproved for contract PILicenseTemplate
     */
  }, {
    key: "watchDerivativeApprovedEvent",
    value: function watchDerivativeApprovedEvent(_onLogs27) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "DerivativeApproved",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs27(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event DerivativeApproved for contract PILicenseTemplate
     */
  }, {
    key: "parseTxDerivativeApprovedEvent",
    value: function parseTxDerivativeApprovedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator27 = _createForOfIteratorHelper(txReceipt.logs),
        _step27;
      try {
        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
          var log = _step27.value;
          try {
            var event = decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "DerivativeApproved",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "DerivativeApproved") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator27.e(err);
      } finally {
        _iterator27.f();
      }
      return targetLogs;
    }

    /**
     * event Initialized for contract PILicenseTemplate
     */
  }, {
    key: "watchInitializedEvent",
    value: function watchInitializedEvent(_onLogs28) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "Initialized",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs28(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Initialized for contract PILicenseTemplate
     */
  }, {
    key: "parseTxInitializedEvent",
    value: function parseTxInitializedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator28 = _createForOfIteratorHelper(txReceipt.logs),
        _step28;
      try {
        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
          var log = _step28.value;
          try {
            var event = decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "Initialized",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Initialized") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator28.e(err);
      } finally {
        _iterator28.f();
      }
      return targetLogs;
    }

    /**
     * event LicenseTermsRegistered for contract PILicenseTemplate
     */
  }, {
    key: "watchLicenseTermsRegisteredEvent",
    value: function watchLicenseTermsRegisteredEvent(_onLogs29) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "LicenseTermsRegistered",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs29(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event LicenseTermsRegistered for contract PILicenseTemplate
     */
  }, {
    key: "parseTxLicenseTermsRegisteredEvent",
    value: function parseTxLicenseTermsRegisteredEvent(txReceipt) {
      var targetLogs = [];
      var _iterator29 = _createForOfIteratorHelper(txReceipt.logs),
        _step29;
      try {
        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
          var log = _step29.value;
          try {
            var event = decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "LicenseTermsRegistered",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "LicenseTermsRegistered") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator29.e(err);
      } finally {
        _iterator29.f();
      }
      return targetLogs;
    }

    /**
     * event Upgraded for contract PILicenseTemplate
     */
  }, {
    key: "watchUpgradedEvent",
    value: function watchUpgradedEvent(_onLogs30) {
      return this.rpcClient.watchContractEvent({
        abi: piLicenseTemplateAbi,
        address: this.address,
        eventName: "Upgraded",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs30(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event Upgraded for contract PILicenseTemplate
     */
  }, {
    key: "parseTxUpgradedEvent",
    value: function parseTxUpgradedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator30 = _createForOfIteratorHelper(txReceipt.logs),
        _step30;
      try {
        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
          var log = _step30.value;
          try {
            var event = decodeEventLog({
              abi: piLicenseTemplateAbi,
              eventName: "Upgraded",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "Upgraded") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator30.e(err);
      } finally {
        _iterator30.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract PILicenseTemplate readonly method
 */
var PiLicenseTemplateReadOnlyClient = /*#__PURE__*/function (_PiLicenseTemplateEve) {
  function PiLicenseTemplateReadOnlyClient(rpcClient, address) {
    _classCallCheck(this, PiLicenseTemplateReadOnlyClient);
    return _callSuper(this, PiLicenseTemplateReadOnlyClient, [rpcClient, address]);
  }

  /**
   * method ACCESS_CONTROLLER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAccessControllerRequest
   * @return Promise<PiLicenseTemplateAccessControllerResponse>
   */
  _inherits(PiLicenseTemplateReadOnlyClient, _PiLicenseTemplateEve);
  return _createClass(PiLicenseTemplateReadOnlyClient, [{
    key: "accessController",
    value: (function () {
      var _accessController2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee78() {
        return _regeneratorRuntime().wrap(function _callee78$(_context78) {
          while (1) switch (_context78.prev = _context78.next) {
            case 0:
              _context78.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "ACCESS_CONTROLLER"
              });
            case 2:
              return _context78.abrupt("return", _context78.sent);
            case 3:
            case "end":
              return _context78.stop();
          }
        }, _callee78, this);
      }));
      function accessController() {
        return _accessController2.apply(this, arguments);
      }
      return accessController;
    }()
    /**
     * method IP_ACCOUNT_REGISTRY for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIpAccountRegistryRequest
     * @return Promise<PiLicenseTemplateIpAccountRegistryResponse>
     */
    )
  }, {
    key: "ipAccountRegistry",
    value: (function () {
      var _ipAccountRegistry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee79() {
        return _regeneratorRuntime().wrap(function _callee79$(_context79) {
          while (1) switch (_context79.prev = _context79.next) {
            case 0:
              _context79.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "IP_ACCOUNT_REGISTRY"
              });
            case 2:
              return _context79.abrupt("return", _context79.sent);
            case 3:
            case "end":
              return _context79.stop();
          }
        }, _callee79, this);
      }));
      function ipAccountRegistry() {
        return _ipAccountRegistry2.apply(this, arguments);
      }
      return ipAccountRegistry;
    }()
    /**
     * method LICENSE_REGISTRY for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateLicenseRegistryRequest
     * @return Promise<PiLicenseTemplateLicenseRegistryResponse>
     */
    )
  }, {
    key: "licenseRegistry",
    value: (function () {
      var _licenseRegistry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee80() {
        return _regeneratorRuntime().wrap(function _callee80$(_context80) {
          while (1) switch (_context80.prev = _context80.next) {
            case 0:
              _context80.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "LICENSE_REGISTRY"
              });
            case 2:
              return _context80.abrupt("return", _context80.sent);
            case 3:
            case "end":
              return _context80.stop();
          }
        }, _callee80, this);
      }));
      function licenseRegistry() {
        return _licenseRegistry.apply(this, arguments);
      }
      return licenseRegistry;
    }()
    /**
     * method ROYALTY_MODULE for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateRoyaltyModuleRequest
     * @return Promise<PiLicenseTemplateRoyaltyModuleResponse>
     */
    )
  }, {
    key: "royaltyModule",
    value: (function () {
      var _royaltyModule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee81() {
        return _regeneratorRuntime().wrap(function _callee81$(_context81) {
          while (1) switch (_context81.prev = _context81.next) {
            case 0:
              _context81.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "ROYALTY_MODULE"
              });
            case 2:
              return _context81.abrupt("return", _context81.sent);
            case 3:
            case "end":
              return _context81.stop();
          }
        }, _callee81, this);
      }));
      function royaltyModule() {
        return _royaltyModule.apply(this, arguments);
      }
      return royaltyModule;
    }()
    /**
     * method TERMS_RENDERER for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateTermsRendererRequest
     * @return Promise<PiLicenseTemplateTermsRendererResponse>
     */
    )
  }, {
    key: "termsRenderer",
    value: (function () {
      var _termsRenderer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee82() {
        return _regeneratorRuntime().wrap(function _callee82$(_context82) {
          while (1) switch (_context82.prev = _context82.next) {
            case 0:
              _context82.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "TERMS_RENDERER"
              });
            case 2:
              return _context82.abrupt("return", _context82.sent);
            case 3:
            case "end":
              return _context82.stop();
          }
        }, _callee82, this);
      }));
      function termsRenderer() {
        return _termsRenderer.apply(this, arguments);
      }
      return termsRenderer;
    }()
    /**
     * method UPGRADE_INTERFACE_VERSION for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateUpgradeInterfaceVersionRequest
     * @return Promise<PiLicenseTemplateUpgradeInterfaceVersionResponse>
     */
    )
  }, {
    key: "upgradeInterfaceVersion",
    value: (function () {
      var _upgradeInterfaceVersion3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee83() {
        return _regeneratorRuntime().wrap(function _callee83$(_context83) {
          while (1) switch (_context83.prev = _context83.next) {
            case 0:
              _context83.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "UPGRADE_INTERFACE_VERSION"
              });
            case 2:
              return _context83.abrupt("return", _context83.sent);
            case 3:
            case "end":
              return _context83.stop();
          }
        }, _callee83, this);
      }));
      function upgradeInterfaceVersion() {
        return _upgradeInterfaceVersion3.apply(this, arguments);
      }
      return upgradeInterfaceVersion;
    }()
    /**
     * method authority for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateAuthorityRequest
     * @return Promise<PiLicenseTemplateAuthorityResponse>
     */
    )
  }, {
    key: "authority",
    value: (function () {
      var _authority3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee84() {
        return _regeneratorRuntime().wrap(function _callee84$(_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              _context84.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "authority"
              });
            case 2:
              return _context84.abrupt("return", _context84.sent);
            case 3:
            case "end":
              return _context84.stop();
          }
        }, _callee84, this);
      }));
      function authority() {
        return _authority3.apply(this, arguments);
      }
      return authority;
    }()
    /**
     * method exists for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateExistsRequest
     * @return Promise<PiLicenseTemplateExistsResponse>
     */
    )
  }, {
    key: "exists",
    value: (function () {
      var _exists2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee85(request) {
        return _regeneratorRuntime().wrap(function _callee85$(_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              _context85.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "exists",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context85.abrupt("return", _context85.sent);
            case 3:
            case "end":
              return _context85.stop();
          }
        }, _callee85, this);
      }));
      function exists(_x57) {
        return _exists2.apply(this, arguments);
      }
      return exists;
    }()
    /**
     * method getEarlierExpireTime for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetEarlierExpireTimeRequest
     * @return Promise<PiLicenseTemplateGetEarlierExpireTimeResponse>
     */
    )
  }, {
    key: "getEarlierExpireTime",
    value: (function () {
      var _getEarlierExpireTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee86(request) {
        return _regeneratorRuntime().wrap(function _callee86$(_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              _context86.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getEarlierExpireTime",
                args: [request.licenseTermsIds, request.start]
              });
            case 2:
              return _context86.abrupt("return", _context86.sent);
            case 3:
            case "end":
              return _context86.stop();
          }
        }, _callee86, this);
      }));
      function getEarlierExpireTime(_x58) {
        return _getEarlierExpireTime.apply(this, arguments);
      }
      return getEarlierExpireTime;
    }()
    /**
     * method getExpireTime for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetExpireTimeRequest
     * @return Promise<PiLicenseTemplateGetExpireTimeResponse>
     */
    )
  }, {
    key: "getExpireTime",
    value: (function () {
      var _getExpireTime2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee87(request) {
        return _regeneratorRuntime().wrap(function _callee87$(_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              _context87.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getExpireTime",
                args: [request.licenseTermsId, request.start]
              });
            case 2:
              return _context87.abrupt("return", _context87.sent);
            case 3:
            case "end":
              return _context87.stop();
          }
        }, _callee87, this);
      }));
      function getExpireTime(_x59) {
        return _getExpireTime2.apply(this, arguments);
      }
      return getExpireTime;
    }()
    /**
     * method getLicenseTerms for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetLicenseTermsRequest
     * @return Promise<PiLicenseTemplateGetLicenseTermsResponse>
     */
    )
  }, {
    key: "getLicenseTerms",
    value: (function () {
      var _getLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee88(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee88$(_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              _context88.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getLicenseTerms",
                args: [request.selectedLicenseTermsId]
              });
            case 2:
              result = _context88.sent;
              return _context88.abrupt("return", {
                terms: result
              });
            case 4:
            case "end":
              return _context88.stop();
          }
        }, _callee88, this);
      }));
      function getLicenseTerms(_x60) {
        return _getLicenseTerms.apply(this, arguments);
      }
      return getLicenseTerms;
    }()
    /**
     * method getLicenseTermsId for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetLicenseTermsIdRequest
     * @return Promise<PiLicenseTemplateGetLicenseTermsIdResponse>
     */
    )
  }, {
    key: "getLicenseTermsId",
    value: (function () {
      var _getLicenseTermsId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee89(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee89$(_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              _context89.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getLicenseTermsId",
                args: [request.terms]
              });
            case 2:
              result = _context89.sent;
              return _context89.abrupt("return", {
                selectedLicenseTermsId: result
              });
            case 4:
            case "end":
              return _context89.stop();
          }
        }, _callee89, this);
      }));
      function getLicenseTermsId(_x61) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
    /**
     * method getLicenseTermsURI for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetLicenseTermsUriRequest
     * @return Promise<PiLicenseTemplateGetLicenseTermsUriResponse>
     */
    )
  }, {
    key: "getLicenseTermsUri",
    value: (function () {
      var _getLicenseTermsUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee90(request) {
        return _regeneratorRuntime().wrap(function _callee90$(_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              _context90.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getLicenseTermsURI",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context90.abrupt("return", _context90.sent);
            case 3:
            case "end":
              return _context90.stop();
          }
        }, _callee90, this);
      }));
      function getLicenseTermsUri(_x62) {
        return _getLicenseTermsUri.apply(this, arguments);
      }
      return getLicenseTermsUri;
    }()
    /**
     * method getMetadataURI for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetMetadataUriRequest
     * @return Promise<PiLicenseTemplateGetMetadataUriResponse>
     */
    )
  }, {
    key: "getMetadataUri",
    value: (function () {
      var _getMetadataUri = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee91() {
        return _regeneratorRuntime().wrap(function _callee91$(_context91) {
          while (1) switch (_context91.prev = _context91.next) {
            case 0:
              _context91.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getMetadataURI"
              });
            case 2:
              return _context91.abrupt("return", _context91.sent);
            case 3:
            case "end":
              return _context91.stop();
          }
        }, _callee91, this);
      }));
      function getMetadataUri() {
        return _getMetadataUri.apply(this, arguments);
      }
      return getMetadataUri;
    }()
    /**
     * method getRoyaltyPolicy for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateGetRoyaltyPolicyRequest
     * @return Promise<PiLicenseTemplateGetRoyaltyPolicyResponse>
     */
    )
  }, {
    key: "getRoyaltyPolicy",
    value: (function () {
      var _getRoyaltyPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee92(request) {
        var result;
        return _regeneratorRuntime().wrap(function _callee92$(_context92) {
          while (1) switch (_context92.prev = _context92.next) {
            case 0:
              _context92.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "getRoyaltyPolicy",
                args: [request.licenseTermsId]
              });
            case 2:
              result = _context92.sent;
              return _context92.abrupt("return", {
                royaltyPolicy: result[0],
                royaltyData: result[1],
                mintingFee: result[2],
                currency: result[3]
              });
            case 4:
            case "end":
              return _context92.stop();
          }
        }, _callee92, this);
      }));
      function getRoyaltyPolicy(_x63) {
        return _getRoyaltyPolicy.apply(this, arguments);
      }
      return getRoyaltyPolicy;
    }()
    /**
     * method isConsumingScheduledOp for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIsConsumingScheduledOpRequest
     * @return Promise<PiLicenseTemplateIsConsumingScheduledOpResponse>
     */
    )
  }, {
    key: "isConsumingScheduledOp",
    value: (function () {
      var _isConsumingScheduledOp3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee93() {
        return _regeneratorRuntime().wrap(function _callee93$(_context93) {
          while (1) switch (_context93.prev = _context93.next) {
            case 0:
              _context93.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "isConsumingScheduledOp"
              });
            case 2:
              return _context93.abrupt("return", _context93.sent);
            case 3:
            case "end":
              return _context93.stop();
          }
        }, _callee93, this);
      }));
      function isConsumingScheduledOp() {
        return _isConsumingScheduledOp3.apply(this, arguments);
      }
      return isConsumingScheduledOp;
    }()
    /**
     * method isDerivativeApproved for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIsDerivativeApprovedRequest
     * @return Promise<PiLicenseTemplateIsDerivativeApprovedResponse>
     */
    )
  }, {
    key: "isDerivativeApproved",
    value: (function () {
      var _isDerivativeApproved = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee94(request) {
        return _regeneratorRuntime().wrap(function _callee94$(_context94) {
          while (1) switch (_context94.prev = _context94.next) {
            case 0:
              _context94.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "isDerivativeApproved",
                args: [request.parentIpId, request.licenseTermsId, request.childIpId]
              });
            case 2:
              return _context94.abrupt("return", _context94.sent);
            case 3:
            case "end":
              return _context94.stop();
          }
        }, _callee94, this);
      }));
      function isDerivativeApproved(_x64) {
        return _isDerivativeApproved.apply(this, arguments);
      }
      return isDerivativeApproved;
    }()
    /**
     * method isLicenseTransferable for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateIsLicenseTransferableRequest
     * @return Promise<PiLicenseTemplateIsLicenseTransferableResponse>
     */
    )
  }, {
    key: "isLicenseTransferable",
    value: (function () {
      var _isLicenseTransferable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee95(request) {
        return _regeneratorRuntime().wrap(function _callee95$(_context95) {
          while (1) switch (_context95.prev = _context95.next) {
            case 0:
              _context95.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "isLicenseTransferable",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context95.abrupt("return", _context95.sent);
            case 3:
            case "end":
              return _context95.stop();
          }
        }, _callee95, this);
      }));
      function isLicenseTransferable(_x65) {
        return _isLicenseTransferable.apply(this, arguments);
      }
      return isLicenseTransferable;
    }()
    /**
     * method name for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateNameRequest
     * @return Promise<PiLicenseTemplateNameResponse>
     */
    )
  }, {
    key: "name",
    value: (function () {
      var _name2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee96() {
        return _regeneratorRuntime().wrap(function _callee96$(_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              _context96.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "name"
              });
            case 2:
              return _context96.abrupt("return", _context96.sent);
            case 3:
            case "end":
              return _context96.stop();
          }
        }, _callee96, this);
      }));
      function name() {
        return _name2.apply(this, arguments);
      }
      return name;
    }()
    /**
     * method proxiableUUID for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateProxiableUuidRequest
     * @return Promise<PiLicenseTemplateProxiableUuidResponse>
     */
    )
  }, {
    key: "proxiableUuid",
    value: (function () {
      var _proxiableUuid3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee97() {
        return _regeneratorRuntime().wrap(function _callee97$(_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              _context97.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "proxiableUUID"
              });
            case 2:
              return _context97.abrupt("return", _context97.sent);
            case 3:
            case "end":
              return _context97.stop();
          }
        }, _callee97, this);
      }));
      function proxiableUuid() {
        return _proxiableUuid3.apply(this, arguments);
      }
      return proxiableUuid;
    }()
    /**
     * method supportsInterface for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateSupportsInterfaceRequest
     * @return Promise<PiLicenseTemplateSupportsInterfaceResponse>
     */
    )
  }, {
    key: "supportsInterface",
    value: (function () {
      var _supportsInterface2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee98(request) {
        return _regeneratorRuntime().wrap(function _callee98$(_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              _context98.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "supportsInterface",
                args: [request.interfaceId]
              });
            case 2:
              return _context98.abrupt("return", _context98.sent);
            case 3:
            case "end":
              return _context98.stop();
          }
        }, _callee98, this);
      }));
      function supportsInterface(_x66) {
        return _supportsInterface2.apply(this, arguments);
      }
      return supportsInterface;
    }()
    /**
     * method toJson for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateToJsonRequest
     * @return Promise<PiLicenseTemplateToJsonResponse>
     */
    )
  }, {
    key: "toJson",
    value: (function () {
      var _toJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee99(request) {
        return _regeneratorRuntime().wrap(function _callee99$(_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              _context99.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "toJson",
                args: [request.licenseTermsId]
              });
            case 2:
              return _context99.abrupt("return", _context99.sent);
            case 3:
            case "end":
              return _context99.stop();
          }
        }, _callee99, this);
      }));
      function toJson(_x67) {
        return _toJson.apply(this, arguments);
      }
      return toJson;
    }()
    /**
     * method totalRegisteredLicenseTerms for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateTotalRegisteredLicenseTermsRequest
     * @return Promise<PiLicenseTemplateTotalRegisteredLicenseTermsResponse>
     */
    )
  }, {
    key: "totalRegisteredLicenseTerms",
    value: (function () {
      var _totalRegisteredLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee100() {
        return _regeneratorRuntime().wrap(function _callee100$(_context100) {
          while (1) switch (_context100.prev = _context100.next) {
            case 0:
              _context100.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "totalRegisteredLicenseTerms"
              });
            case 2:
              return _context100.abrupt("return", _context100.sent);
            case 3:
            case "end":
              return _context100.stop();
          }
        }, _callee100, this);
      }));
      function totalRegisteredLicenseTerms() {
        return _totalRegisteredLicenseTerms.apply(this, arguments);
      }
      return totalRegisteredLicenseTerms;
    }()
    /**
     * method verifyCompatibleLicenses for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyCompatibleLicensesRequest
     * @return Promise<PiLicenseTemplateVerifyCompatibleLicensesResponse>
     */
    )
  }, {
    key: "verifyCompatibleLicenses",
    value: (function () {
      var _verifyCompatibleLicenses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee101(request) {
        return _regeneratorRuntime().wrap(function _callee101$(_context101) {
          while (1) switch (_context101.prev = _context101.next) {
            case 0:
              _context101.next = 2;
              return this.rpcClient.readContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyCompatibleLicenses",
                args: [request.licenseTermsIds]
              });
            case 2:
              return _context101.abrupt("return", _context101.sent);
            case 3:
            case "end":
              return _context101.stop();
          }
        }, _callee101, this);
      }));
      function verifyCompatibleLicenses(_x68) {
        return _verifyCompatibleLicenses.apply(this, arguments);
      }
      return verifyCompatibleLicenses;
    }())
  }]);
}(PiLicenseTemplateEventClient);

/**
 * contract PILicenseTemplate write method
 */
var PiLicenseTemplateClient = /*#__PURE__*/function (_PiLicenseTemplateRea) {
  function PiLicenseTemplateClient(rpcClient, wallet, address) {
    var _this9;
    _classCallCheck(this, PiLicenseTemplateClient);
    _this9 = _callSuper(this, PiLicenseTemplateClient, [rpcClient, address]);
    _this9.wallet = wallet;
    return _this9;
  }

  /**
   * method initialize for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(PiLicenseTemplateClient, _PiLicenseTemplateRea);
  return _createClass(PiLicenseTemplateClient, [{
    key: "initialize",
    value: (function () {
      var _initialize3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee102(request) {
        var _yield$this$rpcClient35, call;
        return _regeneratorRuntime().wrap(function _callee102$(_context102) {
          while (1) switch (_context102.prev = _context102.next) {
            case 0:
              _context102.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "initialize",
                account: this.wallet.account,
                args: [request.accessManager, request.name, request.metadataURI]
              });
            case 2:
              _yield$this$rpcClient35 = _context102.sent;
              call = _yield$this$rpcClient35.request;
              _context102.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context102.abrupt("return", _context102.sent);
            case 7:
            case "end":
              return _context102.stop();
          }
        }, _callee102, this);
      }));
      function initialize(_x69) {
        return _initialize3.apply(this, arguments);
      }
      return initialize;
    }()
    /**
     * method initialize for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateInitializeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "initializeEncode",
    value: function initializeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "initialize",
          args: [request.accessManager, request.name, request.metadataURI]
        })
      };
    }

    /**
     * method registerLicenseTerms for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateRegisterLicenseTermsRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerLicenseTerms",
    value: (function () {
      var _registerLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee103(request) {
        var _yield$this$rpcClient36, call;
        return _regeneratorRuntime().wrap(function _callee103$(_context103) {
          while (1) switch (_context103.prev = _context103.next) {
            case 0:
              _context103.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "registerLicenseTerms",
                account: this.wallet.account,
                args: [request.terms]
              });
            case 2:
              _yield$this$rpcClient36 = _context103.sent;
              call = _yield$this$rpcClient36.request;
              _context103.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context103.abrupt("return", _context103.sent);
            case 7:
            case "end":
              return _context103.stop();
          }
        }, _callee103, this);
      }));
      function registerLicenseTerms(_x70) {
        return _registerLicenseTerms.apply(this, arguments);
      }
      return registerLicenseTerms;
    }()
    /**
     * method registerLicenseTerms for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateRegisterLicenseTermsRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerLicenseTermsEncode",
    value: function registerLicenseTermsEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "registerLicenseTerms",
          args: [request.terms]
        })
      };
    }

    /**
     * method setApproval for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateSetApprovalRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "setApproval",
    value: (function () {
      var _setApproval = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee104(request) {
        var _yield$this$rpcClient37, call;
        return _regeneratorRuntime().wrap(function _callee104$(_context104) {
          while (1) switch (_context104.prev = _context104.next) {
            case 0:
              _context104.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "setApproval",
                account: this.wallet.account,
                args: [request.parentIpId, request.licenseTermsId, request.childIpId, request.approved]
              });
            case 2:
              _yield$this$rpcClient37 = _context104.sent;
              call = _yield$this$rpcClient37.request;
              _context104.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context104.abrupt("return", _context104.sent);
            case 7:
            case "end":
              return _context104.stop();
          }
        }, _callee104, this);
      }));
      function setApproval(_x71) {
        return _setApproval.apply(this, arguments);
      }
      return setApproval;
    }()
    /**
     * method setApproval for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateSetApprovalRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setApprovalEncode",
    value: function setApprovalEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "setApproval",
          args: [request.parentIpId, request.licenseTermsId, request.childIpId, request.approved]
        })
      };
    }

    /**
     * method setAuthority for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateSetAuthorityRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "setAuthority",
    value: (function () {
      var _setAuthority3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee105(request) {
        var _yield$this$rpcClient38, call;
        return _regeneratorRuntime().wrap(function _callee105$(_context105) {
          while (1) switch (_context105.prev = _context105.next) {
            case 0:
              _context105.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "setAuthority",
                account: this.wallet.account,
                args: [request.newAuthority]
              });
            case 2:
              _yield$this$rpcClient38 = _context105.sent;
              call = _yield$this$rpcClient38.request;
              _context105.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context105.abrupt("return", _context105.sent);
            case 7:
            case "end":
              return _context105.stop();
          }
        }, _callee105, this);
      }));
      function setAuthority(_x72) {
        return _setAuthority3.apply(this, arguments);
      }
      return setAuthority;
    }()
    /**
     * method setAuthority for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateSetAuthorityRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "setAuthorityEncode",
    value: function setAuthorityEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "setAuthority",
          args: [request.newAuthority]
        })
      };
    }

    /**
     * method upgradeToAndCall for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateUpgradeToAndCallRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "upgradeToAndCall",
    value: (function () {
      var _upgradeToAndCall3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee106(request) {
        var _yield$this$rpcClient39, call;
        return _regeneratorRuntime().wrap(function _callee106$(_context106) {
          while (1) switch (_context106.prev = _context106.next) {
            case 0:
              _context106.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "upgradeToAndCall",
                account: this.wallet.account,
                args: [request.newImplementation, request.data]
              });
            case 2:
              _yield$this$rpcClient39 = _context106.sent;
              call = _yield$this$rpcClient39.request;
              _context106.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context106.abrupt("return", _context106.sent);
            case 7:
            case "end":
              return _context106.stop();
          }
        }, _callee106, this);
      }));
      function upgradeToAndCall(_x73) {
        return _upgradeToAndCall3.apply(this, arguments);
      }
      return upgradeToAndCall;
    }()
    /**
     * method upgradeToAndCall for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateUpgradeToAndCallRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "upgradeToAndCallEncode",
    value: function upgradeToAndCallEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "upgradeToAndCall",
          args: [request.newImplementation, request.data]
        })
      };
    }

    /**
     * method verifyMintLicenseToken for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "verifyMintLicenseToken",
    value: (function () {
      var _verifyMintLicenseToken2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee107(request) {
        var _yield$this$rpcClient40, call;
        return _regeneratorRuntime().wrap(function _callee107$(_context107) {
          while (1) switch (_context107.prev = _context107.next) {
            case 0:
              _context107.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyMintLicenseToken",
                account: this.wallet.account,
                args: [request[0], request[1], request[2], request[3]]
              });
            case 2:
              _yield$this$rpcClient40 = _context107.sent;
              call = _yield$this$rpcClient40.request;
              _context107.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context107.abrupt("return", _context107.sent);
            case 7:
            case "end":
              return _context107.stop();
          }
        }, _callee107, this);
      }));
      function verifyMintLicenseToken(_x74) {
        return _verifyMintLicenseToken2.apply(this, arguments);
      }
      return verifyMintLicenseToken;
    }()
    /**
     * method verifyMintLicenseToken for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "verifyMintLicenseTokenEncode",
    value: function verifyMintLicenseTokenEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "verifyMintLicenseToken",
          args: [request[0], request[1], request[2], request[3]]
        })
      };
    }

    /**
     * method verifyRegisterDerivative for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "verifyRegisterDerivative",
    value: (function () {
      var _verifyRegisterDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee108(request) {
        var _yield$this$rpcClient41, call;
        return _regeneratorRuntime().wrap(function _callee108$(_context108) {
          while (1) switch (_context108.prev = _context108.next) {
            case 0:
              _context108.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyRegisterDerivative",
                account: this.wallet.account,
                args: [request.childIpId, request.parentIpId, request.licenseTermsId, request.licensee]
              });
            case 2:
              _yield$this$rpcClient41 = _context108.sent;
              call = _yield$this$rpcClient41.request;
              _context108.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context108.abrupt("return", _context108.sent);
            case 7:
            case "end":
              return _context108.stop();
          }
        }, _callee108, this);
      }));
      function verifyRegisterDerivative(_x75) {
        return _verifyRegisterDerivative.apply(this, arguments);
      }
      return verifyRegisterDerivative;
    }()
    /**
     * method verifyRegisterDerivative for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "verifyRegisterDerivativeEncode",
    value: function verifyRegisterDerivativeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "verifyRegisterDerivative",
          args: [request.childIpId, request.parentIpId, request.licenseTermsId, request.licensee]
        })
      };
    }

    /**
     * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate
     *
     * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "verifyRegisterDerivativeForAllParents",
    value: (function () {
      var _verifyRegisterDerivativeForAllParents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee109(request) {
        var _yield$this$rpcClient42, call;
        return _regeneratorRuntime().wrap(function _callee109$(_context109) {
          while (1) switch (_context109.prev = _context109.next) {
            case 0:
              _context109.next = 2;
              return this.rpcClient.simulateContract({
                abi: piLicenseTemplateAbi,
                address: this.address,
                functionName: "verifyRegisterDerivativeForAllParents",
                account: this.wallet.account,
                args: [request.childIpId, request.parentIpIds, request.licenseTermsIds, request.childIpOwner]
              });
            case 2:
              _yield$this$rpcClient42 = _context109.sent;
              call = _yield$this$rpcClient42.request;
              _context109.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context109.abrupt("return", _context109.sent);
            case 7:
            case "end":
              return _context109.stop();
          }
        }, _callee109, this);
      }));
      function verifyRegisterDerivativeForAllParents(_x76) {
        return _verifyRegisterDerivativeForAllParents.apply(this, arguments);
      }
      return verifyRegisterDerivativeForAllParents;
    }()
    /**
     * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate with only encode
     *
     * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "verifyRegisterDerivativeForAllParentsEncode",
    value: function verifyRegisterDerivativeForAllParentsEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: piLicenseTemplateAbi,
          functionName: "verifyRegisterDerivativeForAllParents",
          args: [request.childIpId, request.parentIpIds, request.licenseTermsIds, request.childIpOwner]
        })
      };
    }
  }]);
}(PiLicenseTemplateReadOnlyClient);

// Contract RoyaltyModule =============================================================

/**
 * RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
 *
 * @param royaltyPolicy address
 */

/**
 * RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
 *
 * @param token address
 */

/**
 * RoyaltyModulePayRoyaltyOnBehalfRequest
 *
 * @param receiverIpId address
 * @param payerIpId address
 * @param token address
 * @param amount uint256
 */

/**
 * contract RoyaltyModule readonly method
 */
var RoyaltyModuleReadOnlyClient = /*#__PURE__*/function () {
  function RoyaltyModuleReadOnlyClient(rpcClient, address) {
    var _rpcClient$chain12;
    _classCallCheck(this, RoyaltyModuleReadOnlyClient);
    this.address = address || getAddress(royaltyModuleAddress, (_rpcClient$chain12 = rpcClient.chain) === null || _rpcClient$chain12 === void 0 ? void 0 : _rpcClient$chain12.id);
    this.rpcClient = rpcClient;
  }

  /**
   * method isWhitelistedRoyaltyPolicy for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
   * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyPolicyResponse>
   */
  return _createClass(RoyaltyModuleReadOnlyClient, [{
    key: "isWhitelistedRoyaltyPolicy",
    value: (function () {
      var _isWhitelistedRoyaltyPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee110(request) {
        return _regeneratorRuntime().wrap(function _callee110$(_context110) {
          while (1) switch (_context110.prev = _context110.next) {
            case 0:
              _context110.next = 2;
              return this.rpcClient.readContract({
                abi: royaltyModuleAbi,
                address: this.address,
                functionName: "isWhitelistedRoyaltyPolicy",
                args: [request.royaltyPolicy]
              });
            case 2:
              return _context110.abrupt("return", _context110.sent);
            case 3:
            case "end":
              return _context110.stop();
          }
        }, _callee110, this);
      }));
      function isWhitelistedRoyaltyPolicy(_x77) {
        return _isWhitelistedRoyaltyPolicy.apply(this, arguments);
      }
      return isWhitelistedRoyaltyPolicy;
    }()
    /**
     * method isWhitelistedRoyaltyToken for contract RoyaltyModule
     *
     * @param request RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
     * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyTokenResponse>
     */
    )
  }, {
    key: "isWhitelistedRoyaltyToken",
    value: (function () {
      var _isWhitelistedRoyaltyToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee111(request) {
        return _regeneratorRuntime().wrap(function _callee111$(_context111) {
          while (1) switch (_context111.prev = _context111.next) {
            case 0:
              _context111.next = 2;
              return this.rpcClient.readContract({
                abi: royaltyModuleAbi,
                address: this.address,
                functionName: "isWhitelistedRoyaltyToken",
                args: [request.token]
              });
            case 2:
              return _context111.abrupt("return", _context111.sent);
            case 3:
            case "end":
              return _context111.stop();
          }
        }, _callee111, this);
      }));
      function isWhitelistedRoyaltyToken(_x78) {
        return _isWhitelistedRoyaltyToken.apply(this, arguments);
      }
      return isWhitelistedRoyaltyToken;
    }())
  }]);
}();

/**
 * contract RoyaltyModule write method
 */
var RoyaltyModuleClient = /*#__PURE__*/function (_RoyaltyModuleReadOnl) {
  function RoyaltyModuleClient(rpcClient, wallet, address) {
    var _this10;
    _classCallCheck(this, RoyaltyModuleClient);
    _this10 = _callSuper(this, RoyaltyModuleClient, [rpcClient, address]);
    _this10.wallet = wallet;
    return _this10;
  }

  /**
   * method payRoyaltyOnBehalf for contract RoyaltyModule
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(RoyaltyModuleClient, _RoyaltyModuleReadOnl);
  return _createClass(RoyaltyModuleClient, [{
    key: "payRoyaltyOnBehalf",
    value: (function () {
      var _payRoyaltyOnBehalf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee112(request) {
        var _yield$this$rpcClient43, call;
        return _regeneratorRuntime().wrap(function _callee112$(_context112) {
          while (1) switch (_context112.prev = _context112.next) {
            case 0:
              _context112.next = 2;
              return this.rpcClient.simulateContract({
                abi: royaltyModuleAbi,
                address: this.address,
                functionName: "payRoyaltyOnBehalf",
                account: this.wallet.account,
                args: [request.receiverIpId, request.payerIpId, request.token, request.amount]
              });
            case 2:
              _yield$this$rpcClient43 = _context112.sent;
              call = _yield$this$rpcClient43.request;
              _context112.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context112.abrupt("return", _context112.sent);
            case 7:
            case "end":
              return _context112.stop();
          }
        }, _callee112, this);
      }));
      function payRoyaltyOnBehalf(_x79) {
        return _payRoyaltyOnBehalf.apply(this, arguments);
      }
      return payRoyaltyOnBehalf;
    }()
    /**
     * method payRoyaltyOnBehalf for contract RoyaltyModule with only encode
     *
     * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "payRoyaltyOnBehalfEncode",
    value: function payRoyaltyOnBehalfEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: royaltyModuleAbi,
          functionName: "payRoyaltyOnBehalf",
          args: [request.receiverIpId, request.payerIpId, request.token, request.amount]
        })
      };
    }
  }]);
}(RoyaltyModuleReadOnlyClient);

// Contract RoyaltyPolicyLAP =============================================================

/**
 * RoyaltyPolicyLapGetRoyaltyDataRequest
 *
 * @param ipId address
 */

/**
 * RoyaltyPolicyLapGetRoyaltyDataResponse
 *
 * @param 0 bool
 * @param 1 address
 * @param 2 uint32
 */

/**
 * RoyaltyPolicyLapOnRoyaltyPaymentRequest
 *
 * @param caller address
 * @param ipId address
 * @param token address
 * @param amount uint256
 */

/**
 * contract RoyaltyPolicyLAP readonly method
 */
var RoyaltyPolicyLapReadOnlyClient = /*#__PURE__*/function () {
  function RoyaltyPolicyLapReadOnlyClient(rpcClient, address) {
    var _rpcClient$chain13;
    _classCallCheck(this, RoyaltyPolicyLapReadOnlyClient);
    this.address = address || getAddress(royaltyPolicyLapAddress, (_rpcClient$chain13 = rpcClient.chain) === null || _rpcClient$chain13 === void 0 ? void 0 : _rpcClient$chain13.id);
    this.rpcClient = rpcClient;
  }

  /**
   * method getRoyaltyData for contract RoyaltyPolicyLAP
   *
   * @param request RoyaltyPolicyLapGetRoyaltyDataRequest
   * @return Promise<RoyaltyPolicyLapGetRoyaltyDataResponse>
   */
  return _createClass(RoyaltyPolicyLapReadOnlyClient, [{
    key: "getRoyaltyData",
    value: (function () {
      var _getRoyaltyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee113(request) {
        return _regeneratorRuntime().wrap(function _callee113$(_context113) {
          while (1) switch (_context113.prev = _context113.next) {
            case 0:
              _context113.next = 2;
              return this.rpcClient.readContract({
                abi: royaltyPolicyLapAbi,
                address: this.address,
                functionName: "getRoyaltyData",
                args: [request.ipId]
              });
            case 2:
              return _context113.abrupt("return", _context113.sent);
            case 3:
            case "end":
              return _context113.stop();
          }
        }, _callee113, this);
      }));
      function getRoyaltyData(_x80) {
        return _getRoyaltyData.apply(this, arguments);
      }
      return getRoyaltyData;
    }())
  }]);
}();

/**
 * contract RoyaltyPolicyLAP write method
 */
var RoyaltyPolicyLapClient = /*#__PURE__*/function (_RoyaltyPolicyLapRead) {
  function RoyaltyPolicyLapClient(rpcClient, wallet, address) {
    var _this11;
    _classCallCheck(this, RoyaltyPolicyLapClient);
    _this11 = _callSuper(this, RoyaltyPolicyLapClient, [rpcClient, address]);
    _this11.wallet = wallet;
    return _this11;
  }

  /**
   * method onRoyaltyPayment for contract RoyaltyPolicyLAP
   *
   * @param request RoyaltyPolicyLapOnRoyaltyPaymentRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(RoyaltyPolicyLapClient, _RoyaltyPolicyLapRead);
  return _createClass(RoyaltyPolicyLapClient, [{
    key: "onRoyaltyPayment",
    value: (function () {
      var _onRoyaltyPayment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee114(request) {
        var _yield$this$rpcClient44, call;
        return _regeneratorRuntime().wrap(function _callee114$(_context114) {
          while (1) switch (_context114.prev = _context114.next) {
            case 0:
              _context114.next = 2;
              return this.rpcClient.simulateContract({
                abi: royaltyPolicyLapAbi,
                address: this.address,
                functionName: "onRoyaltyPayment",
                account: this.wallet.account,
                args: [request.caller, request.ipId, request.token, request.amount]
              });
            case 2:
              _yield$this$rpcClient44 = _context114.sent;
              call = _yield$this$rpcClient44.request;
              _context114.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context114.abrupt("return", _context114.sent);
            case 7:
            case "end":
              return _context114.stop();
          }
        }, _callee114, this);
      }));
      function onRoyaltyPayment(_x81) {
        return _onRoyaltyPayment.apply(this, arguments);
      }
      return onRoyaltyPayment;
    }()
    /**
     * method onRoyaltyPayment for contract RoyaltyPolicyLAP with only encode
     *
     * @param request RoyaltyPolicyLapOnRoyaltyPaymentRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "onRoyaltyPaymentEncode",
    value: function onRoyaltyPaymentEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: royaltyPolicyLapAbi,
          functionName: "onRoyaltyPayment",
          args: [request.caller, request.ipId, request.token, request.amount]
        })
      };
    }
  }]);
}(RoyaltyPolicyLapReadOnlyClient);

// Contract SPG =============================================================

/**
 * SpgCollectionCreatedEvent
 *
 * @param nftContract address
 */

/**
 * SpgCreateCollectionRequest
 *
 * @param name string
 * @param symbol string
 * @param maxSupply uint32
 * @param mintFee uint256
 * @param mintFeeToken address
 * @param owner address
 */

/**
 * SpgMintAndRegisterIpRequest
 *
 * @param nftContract address
 * @param recipient address
 * @param ipMetadata tuple
 */

/**
 * SpgMintAndRegisterIpAndAttachPilTermsRequest
 *
 * @param nftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param terms tuple
 */

/**
 * SpgMintAndRegisterIpAndMakeDerivativeRequest
 *
 * @param nftContract address
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param recipient address
 */

/**
 * SpgMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param nftContract address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param ipMetadata tuple
 * @param recipient address
 */

/**
 * SpgRegisterIpRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param sigMetadata tuple
 */

/**
 * SpgRegisterIpAndAttachPilTermsRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param terms tuple
 * @param sigMetadata tuple
 * @param sigAttach tuple
 */

/**
 * SpgRegisterIpAndMakeDerivativeRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param sigMetadata tuple
 * @param sigRegister tuple
 */

/**
 * SpgRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param ipMetadata tuple
 * @param sigMetadata tuple
 * @param sigRegister tuple
 */

/**
 * SpgRegisterPilTermsAndAttachRequest
 *
 * @param ipId address
 * @param terms tuple
 */

/**
 * contract SPG event
 */
var SpgEventClient = /*#__PURE__*/function () {
  function SpgEventClient(rpcClient, address) {
    var _rpcClient$chain14;
    _classCallCheck(this, SpgEventClient);
    this.address = address || getAddress(spgAddress, (_rpcClient$chain14 = rpcClient.chain) === null || _rpcClient$chain14 === void 0 ? void 0 : _rpcClient$chain14.id);
    this.rpcClient = rpcClient;
  }

  /**
   * event CollectionCreated for contract SPG
   */
  return _createClass(SpgEventClient, [{
    key: "watchCollectionCreatedEvent",
    value: function watchCollectionCreatedEvent(_onLogs31) {
      return this.rpcClient.watchContractEvent({
        abi: spgAbi,
        address: this.address,
        eventName: "CollectionCreated",
        onLogs: function onLogs(evs) {
          evs.forEach(function (it) {
            return _onLogs31(it.transactionHash, it.args);
          });
        }
      });
    }

    /**
     * parse tx receipt event CollectionCreated for contract SPG
     */
  }, {
    key: "parseTxCollectionCreatedEvent",
    value: function parseTxCollectionCreatedEvent(txReceipt) {
      var targetLogs = [];
      var _iterator31 = _createForOfIteratorHelper(txReceipt.logs),
        _step31;
      try {
        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
          var log = _step31.value;
          try {
            var event = decodeEventLog({
              abi: spgAbi,
              eventName: "CollectionCreated",
              data: log.data,
              topics: log.topics
            });
            if (event.eventName === "CollectionCreated") {
              targetLogs.push(event.args);
            }
          } catch (e) {
            /* empty */
          }
        }
      } catch (err) {
        _iterator31.e(err);
      } finally {
        _iterator31.f();
      }
      return targetLogs;
    }
  }]);
}();

/**
 * contract SPG write method
 */
var SpgClient = /*#__PURE__*/function (_SpgEventClient) {
  function SpgClient(rpcClient, wallet, address) {
    var _this12;
    _classCallCheck(this, SpgClient);
    _this12 = _callSuper(this, SpgClient, [rpcClient, address]);
    _this12.wallet = wallet;
    return _this12;
  }

  /**
   * method createCollection for contract SPG
   *
   * @param request SpgCreateCollectionRequest
   * @return Promise<WriteContractReturnType>
   */
  _inherits(SpgClient, _SpgEventClient);
  return _createClass(SpgClient, [{
    key: "createCollection",
    value: (function () {
      var _createCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee115(request) {
        var _yield$this$rpcClient45, call;
        return _regeneratorRuntime().wrap(function _callee115$(_context115) {
          while (1) switch (_context115.prev = _context115.next) {
            case 0:
              _context115.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "createCollection",
                account: this.wallet.account,
                args: [request.name, request.symbol, request.maxSupply, request.mintFee, request.mintFeeToken, request.owner]
              });
            case 2:
              _yield$this$rpcClient45 = _context115.sent;
              call = _yield$this$rpcClient45.request;
              _context115.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context115.abrupt("return", _context115.sent);
            case 7:
            case "end":
              return _context115.stop();
          }
        }, _callee115, this);
      }));
      function createCollection(_x82) {
        return _createCollection.apply(this, arguments);
      }
      return createCollection;
    }()
    /**
     * method createCollection for contract SPG with only encode
     *
     * @param request SpgCreateCollectionRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "createCollectionEncode",
    value: function createCollectionEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "createCollection",
          args: [request.name, request.symbol, request.maxSupply, request.mintFee, request.mintFeeToken, request.owner]
        })
      };
    }

    /**
     * method mintAndRegisterIp for contract SPG
     *
     * @param request SpgMintAndRegisterIpRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "mintAndRegisterIp",
    value: (function () {
      var _mintAndRegisterIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee116(request) {
        var _yield$this$rpcClient46, call;
        return _regeneratorRuntime().wrap(function _callee116$(_context116) {
          while (1) switch (_context116.prev = _context116.next) {
            case 0:
              _context116.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIp",
                account: this.wallet.account,
                args: [request.nftContract, request.recipient, request.ipMetadata]
              });
            case 2:
              _yield$this$rpcClient46 = _context116.sent;
              call = _yield$this$rpcClient46.request;
              _context116.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context116.abrupt("return", _context116.sent);
            case 7:
            case "end":
              return _context116.stop();
          }
        }, _callee116, this);
      }));
      function mintAndRegisterIp(_x83) {
        return _mintAndRegisterIp.apply(this, arguments);
      }
      return mintAndRegisterIp;
    }()
    /**
     * method mintAndRegisterIp for contract SPG with only encode
     *
     * @param request SpgMintAndRegisterIpRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "mintAndRegisterIpEncode",
    value: function mintAndRegisterIpEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "mintAndRegisterIp",
          args: [request.nftContract, request.recipient, request.ipMetadata]
        })
      };
    }

    /**
     * method mintAndRegisterIpAndAttachPILTerms for contract SPG
     *
     * @param request SpgMintAndRegisterIpAndAttachPilTermsRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "mintAndRegisterIpAndAttachPilTerms",
    value: (function () {
      var _mintAndRegisterIpAndAttachPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee117(request) {
        var _yield$this$rpcClient47, call;
        return _regeneratorRuntime().wrap(function _callee117$(_context117) {
          while (1) switch (_context117.prev = _context117.next) {
            case 0:
              _context117.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIpAndAttachPILTerms",
                account: this.wallet.account,
                args: [request.nftContract, request.recipient, request.ipMetadata, request.terms]
              });
            case 2:
              _yield$this$rpcClient47 = _context117.sent;
              call = _yield$this$rpcClient47.request;
              _context117.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context117.abrupt("return", _context117.sent);
            case 7:
            case "end":
              return _context117.stop();
          }
        }, _callee117, this);
      }));
      function mintAndRegisterIpAndAttachPilTerms(_x84) {
        return _mintAndRegisterIpAndAttachPilTerms.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachPilTerms;
    }()
    /**
     * method mintAndRegisterIpAndAttachPILTerms for contract SPG with only encode
     *
     * @param request SpgMintAndRegisterIpAndAttachPilTermsRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachPilTermsEncode",
    value: function mintAndRegisterIpAndAttachPilTermsEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "mintAndRegisterIpAndAttachPILTerms",
          args: [request.nftContract, request.recipient, request.ipMetadata, request.terms]
        })
      };
    }

    /**
     * method mintAndRegisterIpAndMakeDerivative for contract SPG
     *
     * @param request SpgMintAndRegisterIpAndMakeDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "mintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee118(request) {
        var _yield$this$rpcClient48, call;
        return _regeneratorRuntime().wrap(function _callee118$(_context118) {
          while (1) switch (_context118.prev = _context118.next) {
            case 0:
              _context118.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIpAndMakeDerivative",
                account: this.wallet.account,
                args: [request.nftContract, request.derivData, request.ipMetadata, request.recipient]
              });
            case 2:
              _yield$this$rpcClient48 = _context118.sent;
              call = _yield$this$rpcClient48.request;
              _context118.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context118.abrupt("return", _context118.sent);
            case 7:
            case "end":
              return _context118.stop();
          }
        }, _callee118, this);
      }));
      function mintAndRegisterIpAndMakeDerivative(_x85) {
        return _mintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * method mintAndRegisterIpAndMakeDerivative for contract SPG with only encode
     *
     * @param request SpgMintAndRegisterIpAndMakeDerivativeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeEncode",
    value: function mintAndRegisterIpAndMakeDerivativeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "mintAndRegisterIpAndMakeDerivative",
          args: [request.nftContract, request.derivData, request.ipMetadata, request.recipient]
        })
      };
    }

    /**
     * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract SPG
     *
     * @param request SpgMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee119(request) {
        var _yield$this$rpcClient49, call;
        return _regeneratorRuntime().wrap(function _callee119$(_context119) {
          while (1) switch (_context119.prev = _context119.next) {
            case 0:
              _context119.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
                account: this.wallet.account,
                args: [request.nftContract, request.licenseTokenIds, request.royaltyContext, request.ipMetadata, request.recipient]
              });
            case 2:
              _yield$this$rpcClient49 = _context119.sent;
              call = _yield$this$rpcClient49.request;
              _context119.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context119.abrupt("return", _context119.sent);
            case 7:
            case "end":
              return _context119.stop();
          }
        }, _callee119, this);
      }));
      function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x86) {
        return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract SPG with only encode
     *
     * @param request SpgMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode",
    value: function mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
          args: [request.nftContract, request.licenseTokenIds, request.royaltyContext, request.ipMetadata, request.recipient]
        })
      };
    }

    /**
     * method registerIp for contract SPG
     *
     * @param request SpgRegisterIpRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerIp",
    value: (function () {
      var _registerIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee120(request) {
        var _yield$this$rpcClient50, call;
        return _regeneratorRuntime().wrap(function _callee120$(_context120) {
          while (1) switch (_context120.prev = _context120.next) {
            case 0:
              _context120.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerIp",
                account: this.wallet.account,
                args: [request.nftContract, request.tokenId, request.ipMetadata, request.sigMetadata]
              });
            case 2:
              _yield$this$rpcClient50 = _context120.sent;
              call = _yield$this$rpcClient50.request;
              _context120.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context120.abrupt("return", _context120.sent);
            case 7:
            case "end":
              return _context120.stop();
          }
        }, _callee120, this);
      }));
      function registerIp(_x87) {
        return _registerIp.apply(this, arguments);
      }
      return registerIp;
    }()
    /**
     * method registerIp for contract SPG with only encode
     *
     * @param request SpgRegisterIpRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerIpEncode",
    value: function registerIpEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "registerIp",
          args: [request.nftContract, request.tokenId, request.ipMetadata, request.sigMetadata]
        })
      };
    }

    /**
     * method registerIpAndAttachPILTerms for contract SPG
     *
     * @param request SpgRegisterIpAndAttachPilTermsRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerIpAndAttachPilTerms",
    value: (function () {
      var _registerIpAndAttachPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee121(request) {
        var _yield$this$rpcClient51, call;
        return _regeneratorRuntime().wrap(function _callee121$(_context121) {
          while (1) switch (_context121.prev = _context121.next) {
            case 0:
              _context121.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerIpAndAttachPILTerms",
                account: this.wallet.account,
                args: [request.nftContract, request.tokenId, request.ipMetadata, request.terms, request.sigMetadata, request.sigAttach]
              });
            case 2:
              _yield$this$rpcClient51 = _context121.sent;
              call = _yield$this$rpcClient51.request;
              _context121.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context121.abrupt("return", _context121.sent);
            case 7:
            case "end":
              return _context121.stop();
          }
        }, _callee121, this);
      }));
      function registerIpAndAttachPilTerms(_x88) {
        return _registerIpAndAttachPilTerms.apply(this, arguments);
      }
      return registerIpAndAttachPilTerms;
    }()
    /**
     * method registerIpAndAttachPILTerms for contract SPG with only encode
     *
     * @param request SpgRegisterIpAndAttachPilTermsRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerIpAndAttachPilTermsEncode",
    value: function registerIpAndAttachPilTermsEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "registerIpAndAttachPILTerms",
          args: [request.nftContract, request.tokenId, request.ipMetadata, request.terms, request.sigMetadata, request.sigAttach]
        })
      };
    }

    /**
     * method registerIpAndMakeDerivative for contract SPG
     *
     * @param request SpgRegisterIpAndMakeDerivativeRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerIpAndMakeDerivative",
    value: (function () {
      var _registerIpAndMakeDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee122(request) {
        var _yield$this$rpcClient52, call;
        return _regeneratorRuntime().wrap(function _callee122$(_context122) {
          while (1) switch (_context122.prev = _context122.next) {
            case 0:
              _context122.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerIpAndMakeDerivative",
                account: this.wallet.account,
                args: [request.nftContract, request.tokenId, request.derivData, request.ipMetadata, request.sigMetadata, request.sigRegister]
              });
            case 2:
              _yield$this$rpcClient52 = _context122.sent;
              call = _yield$this$rpcClient52.request;
              _context122.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context122.abrupt("return", _context122.sent);
            case 7:
            case "end":
              return _context122.stop();
          }
        }, _callee122, this);
      }));
      function registerIpAndMakeDerivative(_x89) {
        return _registerIpAndMakeDerivative.apply(this, arguments);
      }
      return registerIpAndMakeDerivative;
    }()
    /**
     * method registerIpAndMakeDerivative for contract SPG with only encode
     *
     * @param request SpgRegisterIpAndMakeDerivativeRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerIpAndMakeDerivativeEncode",
    value: function registerIpAndMakeDerivativeEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "registerIpAndMakeDerivative",
          args: [request.nftContract, request.tokenId, request.derivData, request.ipMetadata, request.sigMetadata, request.sigRegister]
        })
      };
    }

    /**
     * method registerIpAndMakeDerivativeWithLicenseTokens for contract SPG
     *
     * @param request SpgRegisterIpAndMakeDerivativeWithLicenseTokensRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _registerIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee123(request) {
        var _yield$this$rpcClient53, call;
        return _regeneratorRuntime().wrap(function _callee123$(_context123) {
          while (1) switch (_context123.prev = _context123.next) {
            case 0:
              _context123.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerIpAndMakeDerivativeWithLicenseTokens",
                account: this.wallet.account,
                args: [request.nftContract, request.tokenId, request.licenseTokenIds, request.royaltyContext, request.ipMetadata, request.sigMetadata, request.sigRegister]
              });
            case 2:
              _yield$this$rpcClient53 = _context123.sent;
              call = _yield$this$rpcClient53.request;
              _context123.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context123.abrupt("return", _context123.sent);
            case 7:
            case "end":
              return _context123.stop();
          }
        }, _callee123, this);
      }));
      function registerIpAndMakeDerivativeWithLicenseTokens(_x90) {
        return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * method registerIpAndMakeDerivativeWithLicenseTokens for contract SPG with only encode
     *
     * @param request SpgRegisterIpAndMakeDerivativeWithLicenseTokensRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerIpAndMakeDerivativeWithLicenseTokensEncode",
    value: function registerIpAndMakeDerivativeWithLicenseTokensEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "registerIpAndMakeDerivativeWithLicenseTokens",
          args: [request.nftContract, request.tokenId, request.licenseTokenIds, request.royaltyContext, request.ipMetadata, request.sigMetadata, request.sigRegister]
        })
      };
    }

    /**
     * method registerPILTermsAndAttach for contract SPG
     *
     * @param request SpgRegisterPilTermsAndAttachRequest
     * @return Promise<WriteContractReturnType>
     */
  }, {
    key: "registerPilTermsAndAttach",
    value: (function () {
      var _registerPilTermsAndAttach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee124(request) {
        var _yield$this$rpcClient54, call;
        return _regeneratorRuntime().wrap(function _callee124$(_context124) {
          while (1) switch (_context124.prev = _context124.next) {
            case 0:
              _context124.next = 2;
              return this.rpcClient.simulateContract({
                abi: spgAbi,
                address: this.address,
                functionName: "registerPILTermsAndAttach",
                account: this.wallet.account,
                args: [request.ipId, request.terms]
              });
            case 2:
              _yield$this$rpcClient54 = _context124.sent;
              call = _yield$this$rpcClient54.request;
              _context124.next = 6;
              return this.wallet.writeContract(call);
            case 6:
              return _context124.abrupt("return", _context124.sent);
            case 7:
            case "end":
              return _context124.stop();
          }
        }, _callee124, this);
      }));
      function registerPilTermsAndAttach(_x91) {
        return _registerPilTermsAndAttach.apply(this, arguments);
      }
      return registerPilTermsAndAttach;
    }()
    /**
     * method registerPILTermsAndAttach for contract SPG with only encode
     *
     * @param request SpgRegisterPilTermsAndAttachRequest
     * @return EncodedTxData
     */
    )
  }, {
    key: "registerPilTermsAndAttachEncode",
    value: function registerPilTermsAndAttachEncode(request) {
      return {
        to: this.address,
        data: encodeFunctionData({
          abi: spgAbi,
          functionName: "registerPILTermsAndAttach",
          args: [request.ipId, request.terms]
        })
      };
    }
  }]);
}(SpgEventClient);

/**
 * This structure defines the terms for a Programmable IP License (PIL). These terms can be attached to IP Assets. The legal document of the PIL can be found in this repository.
 * @type LicenseTerms
 **/

var PIL_TYPE = /*#__PURE__*/function (PIL_TYPE) {
  PIL_TYPE[PIL_TYPE["NON_COMMERCIAL_REMIX"] = 0] = "NON_COMMERCIAL_REMIX";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_USE"] = 1] = "COMMERCIAL_USE";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_REMIX"] = 2] = "COMMERCIAL_REMIX";
  return PIL_TYPE;
}({});

function getLicenseTermByType(type, term) {
  var licenseTerms = {
    transferable: true,
    royaltyPolicy: zeroAddress,
    defaultMintingFee: BigInt(0),
    expiration: BigInt(0),
    commercialUse: false,
    commercialAttribution: false,
    commercializerChecker: zeroAddress,
    commercializerCheckerData: zeroAddress,
    commercialRevShare: 0,
    commercialRevCeiling: BigInt(0),
    derivativesAllowed: true,
    derivativesAttribution: true,
    derivativesApproval: false,
    derivativesReciprocal: true,
    derivativeRevCeiling: BigInt(0),
    currency: zeroAddress,
    uri: ""
  };
  if (type === PIL_TYPE.NON_COMMERCIAL_REMIX) {
    licenseTerms.commercializerCheckerData = "0x";
    return licenseTerms;
  } else if (type === PIL_TYPE.COMMERCIAL_USE) {
    if (!term || term.defaultMintingFee === undefined || term.currency === undefined) {
      throw new Error("MintingFee currency are required for commercial use PIL.");
    }
    licenseTerms.royaltyPolicy = getAddress$2(term.royaltyPolicyLAPAddress);
    licenseTerms.defaultMintingFee = BigInt(term.defaultMintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.derivativesReciprocal = false;
    licenseTerms.currency = getAddress$2(term.currency);
    return licenseTerms;
  } else {
    if (!term || term.defaultMintingFee === undefined || term.currency === undefined || term.commercialRevShare === undefined) {
      throw new Error("MintingFee, currency and commercialRevShare are required for commercial remix PIL.");
    }
    if (term.commercialRevShare < 0 || term.commercialRevShare > 100) {
      throw new Error("CommercialRevShare should be between 0 and 100.");
    }
    licenseTerms.royaltyPolicy = getAddress$2(term.royaltyPolicyLAPAddress);
    licenseTerms.defaultMintingFee = BigInt(term.defaultMintingFee);
    licenseTerms.commercialUse = true;
    licenseTerms.commercialAttribution = true;
    licenseTerms.commercialRevShare = term.commercialRevShare / 100 * 100000000;
    licenseTerms.derivativesReciprocal = true;
    licenseTerms.currency = getAddress$2(term.currency);
    return licenseTerms;
  }
}

var AddressZero = "0x0000000000000000000000000000000000000000";
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
var defaultFunctionSelector = "0x00000000";

/**
 * Get the signature for setting permissions.
 * @param param - The parameter object containing necessary data to get the signature.
 * @param param.ipId - The IP ID.
 * @param param.deadline - The deadline.
 * @param param.nonce - The nonce.
 * @param param.wallet - The wallet client.
 * @param param.chainId - The chain ID.
 * @param param.permissions - The permissions.
 * @param param.permissionFunc - The permission function,default function is setPermission.
 * @returns A Promise that resolves to the signature.
 */
var getPermissionSignature = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(param) {
    var ipId, deadline, state, wallet, chainId, permissions, permissionFunc, permissionFunction, accessAddress, data, nonce;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          ipId = param.ipId, deadline = param.deadline, state = param.state, wallet = param.wallet, chainId = param.chainId, permissions = param.permissions, permissionFunc = param.permissionFunc;
          if (wallet.signTypedData) {
            _context.next = 3;
            break;
          }
          throw new Error("The wallet client does not support signTypedData, please try again.");
        case 3:
          if (wallet.account) {
            _context.next = 5;
            break;
          }
          throw new Error("The wallet client does not have an account, please try again.");
        case 5:
          permissionFunction = permissionFunc ? permissionFunc : "setPermission";
          accessAddress = accessControllerAddress[Number(chainId)];
          data = encodeFunctionData({
            abi: accessControllerAbi,
            functionName: permissionFunc ? permissionFunc : "setPermission",
            args: permissionFunction === "setPermission" ? [getAddress$1(permissions[0].ipId, "permissions[0].ipId"), getAddress$1(permissions[0].signer, "permissions[0].signer"), getAddress$1(permissions[0].to, "permissions[0].to"), permissions[0].func ? toFunctionSelector(permissions[0].func) : defaultFunctionSelector, permissions[0].permission] : [permissions.map(function (item, index) {
              return {
                ipAccount: getAddress$1(item.ipId, "permissions[".concat(index, "].ipId")),
                signer: getAddress$1(item.signer, "permissions[".concat(index, "].signer")),
                to: getAddress$1(item.to, "permissions[".concat(index, "].to")),
                func: item.func ? toFunctionSelector(item.func) : defaultFunctionSelector,
                permission: item.permission
              };
            })]
          });
          nonce = keccak256(encodeAbiParameters([{
            name: "",
            type: "bytes32"
          }, {
            name: "",
            type: "bytes"
          }], [state, encodeFunctionData({
            abi: ipAccountImplAbi,
            functionName: "execute",
            args: [accessAddress, 0n, data]
          })]));
          _context.next = 11;
          return wallet.signTypedData({
            account: wallet.account,
            domain: {
              name: "Story Protocol IP Account",
              version: "1",
              chainId: Number(chainId),
              verifyingContract: getAddress$1(ipId, "ipId")
            },
            types: {
              Execute: [{
                name: "to",
                type: "address"
              }, {
                name: "value",
                type: "uint256"
              }, {
                name: "data",
                type: "bytes"
              }, {
                name: "nonce",
                type: "bytes32"
              }, {
                name: "deadline",
                type: "uint256"
              }]
            },
            primaryType: "Execute",
            message: {
              to: getAddress$1(accessControllerAddress[Number(chainId)], "accessControllerAddress"),
              value: BigInt(0),
              data: data,
              nonce: nonce,
              deadline: BigInt(deadline)
            }
          });
        case 11:
          return _context.abrupt("return", _context.sent);
        case 12:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getPermissionSignature(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getDeadline = function getDeadline(deadline) {
  if (deadline && (isNaN(Number(deadline)) || BigInt(deadline) < 0n)) {
    throw new Error("Invalid deadline value.");
  }
  var timestamp = BigInt(Date.now());
  return deadline ? timestamp + BigInt(deadline) : timestamp + 1000n;
};

/**
 * Permission level
 * @enum {number}
 **/
var AccessPermission = /*#__PURE__*/function (AccessPermission) {
  AccessPermission[AccessPermission["ABSTAIN"] = 0] = "ABSTAIN";
  AccessPermission[AccessPermission["ALLOW"] = 1] = "ALLOW";
  AccessPermission[AccessPermission["DENY"] = 2] = "DENY";
  return AccessPermission;
}({});

var _excluded = ["title", "description", "ipType", "relationships", "createdAt", "watermarkImg", "creators", "media", "attributes", "app", "tags", "robotTerms"];
var IPAssetClient = /*#__PURE__*/function () {
  function IPAssetClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, IPAssetClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.royaltyPolicyLAPClient = new RoyaltyPolicyLapClient(rpcClient, wallet);
    this.accessControllerClient = new AccessControllerClient(rpcClient, wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(rpcClient, wallet);
    this.spgClient = new SpgClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
  }

  /**
   * Create a new `IpCreator` object with the specified details.
   * @param params - The parameters required to create the `IpCreator` object.
   *   @param params.name The name of the creator.
   *   @param params.address The wallet address of the creator.
   *   @param params.description [Optional] A description of the creator.
   *   @param params.image [Optional] The URL or path to an image representing the creator.
   *   @param params.socialMedia [Optional] An array of social media profiles associated with the creator.
   *     @param params.socialMedia[].platform The name of the social media platform.
   *     @param params.socialMedia[].url The URL to the creator's profile on the platform.
   *  @param params.contributionPercent The percentage of contribution by the creator, must add up to 100.
   *  @param params.role [Optional] The role of the creator in relation to the IP.
   * @returns An `IpCreator` object containing the provided details.
   */
  return _createClass(IPAssetClient, [{
    key: "generateCreatorMetadata",
    value: function generateCreatorMetadata(param) {
      var name = param.name,
        address = param.address,
        _param$description = param.description,
        description = _param$description === void 0 ? "" : _param$description,
        _param$image = param.image,
        image = _param$image === void 0 ? "" : _param$image,
        _param$socialMedia = param.socialMedia,
        socialMedia = _param$socialMedia === void 0 ? [] : _param$socialMedia,
        contributionPercent = param.contributionPercent,
        _param$role = param.role,
        role = _param$role === void 0 ? "" : _param$role;
      return {
        name: name,
        address: address,
        description: description,
        image: image,
        socialMedia: socialMedia,
        contributionPercent: contributionPercent,
        role: role
      };
    }

    /**
     * Create a new `IpMetadata` object with the specified details.
     * @param params - The parameters required to create the `IpMetadata` object.
     *   @param params.title [Optional] The title of the IP.
     *   @param params.description [Optional] A description of the IP.
     *   @param params.ipType [Optional] The type of the IP asset (e.g., "character", "chapter").
     *   @param params.relationships [Optional] An array of relationships between this IP and its parent IPs.
     *     @param params.relationships[].ipId The ID of the parent IP.
     *     @param params.relationships[].type The type of relationship (e.g., "APPEARS_IN").
     *   @param params.createdAt [Optional] The creation date and time of the IP in ISO 8601 format.
     *   @param params.watermarkImg [Optional] The URL or path to an image used as a watermark for the IP.
     *   @param params.creators [Optional] An array of creators associated with the IP.
     *     @param params.creators[].name The name of the creator.
     *     @param params.creators[].address The address of the creator.
     *     @param params.creators[].description [Optional] A description of the creator.
     *     @param params.creators[].image [Optional] The URL or path to an image representing the creator.
     *     @param params.creators[].socialMedia [Optional] An array of social media profiles for the creator.
     *     @param params.creators[].socialMedia[].platform The social media platform name.
     *     @param params.creators[].socialMedia[].url The URL to the creator's profile.
     *     @param params.creators[].role [Optional] The role of the creator in relation to the IP.
     *     @param params.creators[].contributionPercent The percentage of contribution by the creator.
     *   @param params.media [Optional] An array of media related to the IP.
     *     @param params.media[].name The name of the media.
     *     @param params.media[].url The URL to the media.
     *     @param params.media[].mimeType The MIME type of the media.
     *   @param params.attributes [Optional] An array of key-value pairs providing additional metadata.
     *     @param params.attributes[].key The key for the attribute.
     *     @param params.attributes[].value The value for the attribute, can be a string or number.
     *   @param params.app [Optional] Information about the application associated with the IP.
     *     @param params.app.id The ID of the application.
     *     @param params.app.name The name of the application.
     *     @param params.app.website The website URL of the application.
     *   @param params.tags [Optional] An array of tags associated with the IP.
     *   @param params.robotTerms [Optional] Robot terms for the IP, specifying access rules.
     *     @param params.robotTerms.userAgent The user agent for which the rules apply.
     *     @param params.robotTerms.allow The rules allowing access.
     *   @param params.additionalProperties [Optional] Any additional key-value pairs to include in the metadata.
     * @returns An `IpMetadata` object containing the provided details and any additional properties.
     */
  }, {
    key: "generateIpMetadata",
    value: function generateIpMetadata(param) {
      var _param$title = param.title,
        title = _param$title === void 0 ? "" : _param$title,
        _param$description2 = param.description,
        description = _param$description2 === void 0 ? "" : _param$description2,
        _param$ipType = param.ipType,
        ipType = _param$ipType === void 0 ? "" : _param$ipType,
        _param$relationships = param.relationships,
        relationships = _param$relationships === void 0 ? [] : _param$relationships,
        _param$createdAt = param.createdAt,
        createdAt = _param$createdAt === void 0 ? "" : _param$createdAt,
        _param$watermarkImg = param.watermarkImg,
        watermarkImg = _param$watermarkImg === void 0 ? "" : _param$watermarkImg,
        _param$creators = param.creators,
        creators = _param$creators === void 0 ? [] : _param$creators,
        _param$media = param.media,
        media = _param$media === void 0 ? [] : _param$media,
        _param$attributes = param.attributes,
        attributes = _param$attributes === void 0 ? [] : _param$attributes,
        app = param.app,
        _param$tags = param.tags,
        tags = _param$tags === void 0 ? [] : _param$tags,
        robotTerms = param.robotTerms,
        additionalProperties = _objectWithoutProperties(param, _excluded);
      return _objectSpread2({
        title: title,
        description: description,
        ipType: ipType,
        relationships: relationships,
        createdAt: createdAt,
        watermarkImg: watermarkImg,
        creators: creators,
        media: media,
        attributes: attributes,
        app: app,
        tags: tags,
        robotTerms: robotTerms
      }, additionalProperties);
    }

    /**
     * Registers an NFT as IP, creating a corresponding IP record.
     * @param request - The request object that contains all data needed to register IP.
     *   @param request.nftContract The address of the NFT.
     *   @param request.tokenId The token identifier of the NFT.
     *   @param request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *   @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *   @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *   @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *   @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.deadline [Optional] The deadline for the signature in milliseconds, default is 1000ms.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID if waitForTxn is set to true.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, resolverAddr, metadataProviderAddress, metadata)
     */
  }, {
    key: "register",
    value: (function () {
      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$ipMetadata, _request$ipMetadata2, _request$ipMetadata3, _request$ipMetadata4, _request$txOptions, tokenId, ipIdAddress, isRegistered, object, _request$txOptions2, txHash, calculatedDeadline, signature, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context.next = 4;
              return this.getIpIdAddress(request.nftContract, tokenId);
            case 4:
              ipIdAddress = _context.sent;
              _context.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context.sent;
              if (!isRegistered) {
                _context.next = 10;
                break;
              }
              return _context.abrupt("return", {
                ipId: ipIdAddress
              });
            case 10:
              object = {
                tokenId: tokenId,
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                ipMetadata: {
                  ipMetadataURI: ((_request$ipMetadata = request.ipMetadata) === null || _request$ipMetadata === void 0 ? void 0 : _request$ipMetadata.ipMetadataURI) || "",
                  ipMetadataHash: ((_request$ipMetadata2 = request.ipMetadata) === null || _request$ipMetadata2 === void 0 ? void 0 : _request$ipMetadata2.ipMetadataHash) || zeroHash,
                  nftMetadataURI: ((_request$ipMetadata3 = request.ipMetadata) === null || _request$ipMetadata3 === void 0 ? void 0 : _request$ipMetadata3.nftMetadataURI) || "",
                  nftMetadataHash: ((_request$ipMetadata4 = request.ipMetadata) === null || _request$ipMetadata4 === void 0 ? void 0 : _request$ipMetadata4.nftMetadataHash) || zeroHash
                },
                sigMetadata: {
                  signer: zeroAddress,
                  deadline: BigInt(0),
                  signature: zeroHash
                }
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 19;
                break;
              }
              if (!request.ipMetadata) {
                _context.next = 16;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.spgClient.registerIpEncode(object)
              });
            case 16:
              return _context.abrupt("return", {
                encodedTxData: this.ipAssetRegistryClient.registerEncode({
                  tokenContract: object.nftContract,
                  tokenId: object.tokenId,
                  chainid: chain[this.chainId]
                })
              });
            case 17:
              _context.next = 42;
              break;
            case 19:
              if (!request.ipMetadata) {
                _context.next = 30;
                break;
              }
              calculatedDeadline = getDeadline(request.deadline);
              _context.next = 23;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.spgClient.address, "spgAddress"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: "function setAll(address,string,bytes32,bytes32)"
                }]
              });
            case 23:
              signature = _context.sent;
              object.sigMetadata = {
                signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                deadline: calculatedDeadline,
                signature: signature
              };
              _context.next = 27;
              return this.spgClient.registerIp(object);
            case 27:
              txHash = _context.sent;
              _context.next = 33;
              break;
            case 30:
              _context.next = 32;
              return this.ipAssetRegistryClient.register({
                tokenContract: object.nftContract,
                tokenId: object.tokenId,
                chainid: chain[this.chainId]
              });
            case 32:
              txHash = _context.sent;
            case 33:
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 41;
                break;
              }
              _context.next = 36;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 36:
              txReceipt = _context.sent;
              targetLogs = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                ipId: targetLogs[0].ipId
              });
            case 41:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 42:
              _context.next = 47;
              break;
            case 44:
              _context.prev = 44;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register IP");
            case 47:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 44]]);
      }));
      function register(_x) {
        return _register.apply(this, arguments);
      }
      return register;
    }()
    /**
     * Registers a derivative directly with parent IP's license terms, without needing license tokens,
     * and attaches the license terms of the parent IPs to the derivative IP.
     * The license terms must be attached to the parent IP before calling this function.
     * All IPs attached default license terms by default.
     * The derivative IP owner must be the caller or an authorized operator.
     * @param request - The request object that contains all data needed to register derivative IP.
     *   @param request.childIpId The derivative IP ID.
     *   @param request.parentIpIds The parent IP IDs.
     *   @param request.licenseTermsIds The IDs of the license terms that the parent IP supports.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "registerDerivative",
    value: (function () {
      var _registerDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, isChildIpIdRegistered, _iterator, _step, parentId, isParentIpIdRegistered, i, isAttachedLicenseTerms, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return this.isRegistered(request.childIpId);
            case 3:
              isChildIpIdRegistered = _context2.sent;
              if (isChildIpIdRegistered) {
                _context2.next = 6;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 6:
              _iterator = _createForOfIteratorHelper(request.parentIpIds);
              _context2.prev = 7;
              _iterator.s();
            case 9:
              if ((_step = _iterator.n()).done) {
                _context2.next = 18;
                break;
              }
              parentId = _step.value;
              _context2.next = 13;
              return this.isRegistered(getAddress$1(parentId, "request.parentIpIds"));
            case 13:
              isParentIpIdRegistered = _context2.sent;
              if (isParentIpIdRegistered) {
                _context2.next = 16;
                break;
              }
              throw new Error("The parent IP with id ".concat(parentId, " is not registered."));
            case 16:
              _context2.next = 9;
              break;
            case 18:
              _context2.next = 23;
              break;
            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](7);
              _iterator.e(_context2.t0);
            case 23:
              _context2.prev = 23;
              _iterator.f();
              return _context2.finish(23);
            case 26:
              if (!(request.parentIpIds.length !== request.licenseTermsIds.length)) {
                _context2.next = 28;
                break;
              }
              throw new Error("Parent IP IDs and License terms IDs must be provided in pairs.");
            case 28:
              i = 0;
            case 29:
              if (!(i < request.parentIpIds.length)) {
                _context2.next = 38;
                break;
              }
              _context2.next = 32;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: getAddress$1(request.parentIpIds[i], "request.parentIpIds"),
                licenseTemplate: request.licenseTemplate && getAddress$1(request.licenseTemplate, "request.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: BigInt(request.licenseTermsIds[i])
              });
            case 32:
              isAttachedLicenseTerms = _context2.sent;
              if (isAttachedLicenseTerms) {
                _context2.next = 35;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsIds[i], " must be attached to the parent ipId ").concat(request.parentIpIds[i], " before registering derivative."));
            case 35:
              i++;
              _context2.next = 29;
              break;
            case 38:
              req = {
                childIpId: request.childIpId,
                parentIpIds: request.parentIpIds,
                licenseTermsIds: request.licenseTermsIds.map(function (id) {
                  return BigInt(id);
                }),
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                royaltyContext: zeroAddress
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 43;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.licensingModuleClient.registerDerivativeEncode(req)
              });
            case 43:
              _context2.next = 45;
              return this.licensingModuleClient.registerDerivative(req);
            case 45:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 52;
                break;
              }
              _context2.next = 49;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 49:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 52:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 53:
              _context2.next = 58;
              break;
            case 55:
              _context2.prev = 55;
              _context2.t1 = _context2["catch"](0);
              handleError(_context2.t1, "Failed to register derivative");
            case 58:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 55], [7, 20, 23, 26]]);
      }));
      function registerDerivative(_x2) {
        return _registerDerivative.apply(this, arguments);
      }
      return registerDerivative;
    }()
    /**
     * Registers a derivative with license tokens.
     * the derivative IP is registered with license tokens minted from the parent IP's license terms.
     * the license terms of the parent IPs issued with license tokens are attached to the derivative IP.
     * the caller must be the derivative IP owner or an authorized operator.
     * @param request - The request object that contains all data needed to register derivative license tokens.
     *   @param request.childIpId The derivative IP ID.
     *   @param request.licenseTokenIds The IDs of the license tokens.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "registerDerivativeWithLicenseTokens",
    value: (function () {
      var _registerDerivativeWithLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, isChildIpIdRegistered, _iterator2, _step2, licenseTokenId, tokenOwnerAddress, req, _request$txOptions6, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.isRegistered(request.childIpId);
            case 3:
              isChildIpIdRegistered = _context3.sent;
              if (isChildIpIdRegistered) {
                _context3.next = 6;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 6:
              request.licenseTokenIds = request.licenseTokenIds.map(function (id) {
                return BigInt(id);
              });
              _iterator2 = _createForOfIteratorHelper(request.licenseTokenIds);
              _context3.prev = 8;
              _iterator2.s();
            case 10:
              if ((_step2 = _iterator2.n()).done) {
                _context3.next = 19;
                break;
              }
              licenseTokenId = _step2.value;
              _context3.next = 14;
              return this.licenseTokenReadOnlyClient.ownerOf({
                tokenId: licenseTokenId
              });
            case 14:
              tokenOwnerAddress = _context3.sent;
              if (tokenOwnerAddress) {
                _context3.next = 17;
                break;
              }
              throw new Error("License token id ".concat(licenseTokenId, " must be owned by the caller."));
            case 17:
              _context3.next = 10;
              break;
            case 19:
              _context3.next = 24;
              break;
            case 21:
              _context3.prev = 21;
              _context3.t0 = _context3["catch"](8);
              _iterator2.e(_context3.t0);
            case 24:
              _context3.prev = 24;
              _iterator2.f();
              return _context3.finish(24);
            case 27:
              req = {
                childIpId: getAddress$1(request.childIpId, "request.childIpId"),
                licenseTokenIds: request.licenseTokenIds,
                royaltyContext: zeroAddress
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 32;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.licensingModuleClient.registerDerivativeWithLicenseTokensEncode(req)
              });
            case 32:
              _context3.next = 34;
              return this.licensingModuleClient.registerDerivativeWithLicenseTokens(req);
            case 34:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 41;
                break;
              }
              _context3.next = 38;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 38:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 41:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 42:
              _context3.next = 47;
              break;
            case 44:
              _context3.prev = 44;
              _context3.t1 = _context3["catch"](0);
              handleError(_context3.t1, "Failed to register derivative with license tokens");
            case 47:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 44], [8, 21, 24, 27]]);
      }));
      function registerDerivativeWithLicenseTokens(_x3) {
        return _registerDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerDerivativeWithLicenseTokens;
    }()
    /**
     * Mint an NFT from a collection and register it as an IP.
     * @param request - The request object that contains all data needed to mint and register ip.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.pilType The type of the PIL.
     *   @param request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *   @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *   @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *   @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *   @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.recipient [Optional] The address of the recipient of the minted NFT.
     *   @param request.mintingFee [Optional] The fee to be paid when minting a license.
     *   @param request.commercialRevShare [Optional] Percentage of revenue that must be shared with the licensor.
     *   @param request.currency [Optional] The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID, Token ID, License Terms Id if waitForTxn is set to true.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "mintAndRegisterIpAssetWithPilTerms",
    value: (function () {
      var _mintAndRegisterIpAssetWithPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$ipMetadata5, _request$ipMetadata6, _request$ipMetadata7, _request$ipMetadata8, _request$txOptions7, licenseTerm, object, _request$txOptions8, txHash, txReceipt, iPRegisteredLog, licenseTermsId;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              if (!(request.pilType === undefined || request.pilType === null)) {
                _context4.next = 3;
                break;
              }
              throw new Error("PIL type is required.");
            case 3:
              licenseTerm = getLicenseTermByType(request.pilType, {
                defaultMintingFee: request.mintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address,
                commercialRevShare: request.commercialRevShare
              });
              object = {
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                recipient: request.recipient && getAddress$1(request.recipient, "request.recipient") || this.wallet.account.address,
                terms: licenseTerm,
                ipMetadata: {
                  ipMetadataURI: ((_request$ipMetadata5 = request.ipMetadata) === null || _request$ipMetadata5 === void 0 ? void 0 : _request$ipMetadata5.ipMetadataURI) || "",
                  ipMetadataHash: ((_request$ipMetadata6 = request.ipMetadata) === null || _request$ipMetadata6 === void 0 ? void 0 : _request$ipMetadata6.ipMetadataHash) || zeroHash,
                  nftMetadataURI: ((_request$ipMetadata7 = request.ipMetadata) === null || _request$ipMetadata7 === void 0 ? void 0 : _request$ipMetadata7.nftMetadataURI) || "",
                  nftMetadataHash: ((_request$ipMetadata8 = request.ipMetadata) === null || _request$ipMetadata8 === void 0 ? void 0 : _request$ipMetadata8.nftMetadataHash) || zeroHash
                }
              };
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 9;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.spgClient.mintAndRegisterIpAndAttachPilTermsEncode(object)
              });
            case 9:
              _context4.next = 11;
              return this.spgClient.mintAndRegisterIpAndAttachPilTerms(object);
            case 11:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 21;
                break;
              }
              _context4.next = 15;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 15:
              txReceipt = _context4.sent;
              iPRegisteredLog = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt)[0];
              _context4.next = 19;
              return this.getLicenseTermsId(txReceipt);
            case 19:
              licenseTermsId = _context4.sent;
              return _context4.abrupt("return", {
                txHash: txHash,
                ipId: iPRegisteredLog.ipId,
                licenseTermsId: licenseTermsId,
                tokenId: iPRegisteredLog.tokenId
              });
            case 21:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 22:
              _context4.next = 27;
              break;
            case 24:
              _context4.prev = 24;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to mint and register IP and attach PIL terms");
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 24]]);
      }));
      function mintAndRegisterIpAssetWithPilTerms(_x4) {
        return _mintAndRegisterIpAssetWithPilTerms.apply(this, arguments);
      }
      return mintAndRegisterIpAssetWithPilTerms;
    }()
    /**
     * Register a given NFT as an IP and attach Programmable IP License Terms.R.
     * @param request - The request object that contains all data needed to mint and register ip.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param request.pilType The type of the PIL.
     *   @param request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *   @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *   @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *   @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *   @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.deadline [Optional] The deadline for the signature in milliseconds, default is 1000ms.
     *   @param request.mintingFee [Optional] The fee to be paid when minting a license.
     *   @param request.commercialRevShare [Optional] Percentage of revenue that must be shared with the licensor.
     *   @param request.currency [Optional] The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID, License Terms Id if waitForTxn is set to true.
     * @emits LicenseTermsAttached (caller, ipId, licenseTemplate, licenseTermsId)
     */
    )
  }, {
    key: "registerIpAndAttachPilTerms",
    value: (function () {
      var _registerIpAndAttachPilTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$ipMetadata9, _request$ipMetadata10, _request$ipMetadata11, _request$ipMetadata12, _request$txOptions9, ipIdAddress, isRegistered, licenseTerm, calculatedDeadline, sigAttachSignature, object, sigMetadataSignature, _request$txOptions10, txHash, txReceipt, ipRegisterEvent, licenseTermsId;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              if (!(request.pilType === undefined || request.pilType === null)) {
                _context5.next = 3;
                break;
              }
              throw new Error("PIL type is required.");
            case 3:
              request.tokenId = BigInt(request.tokenId);
              _context5.next = 6;
              return this.getIpIdAddress(request.nftContract, request.tokenId);
            case 6:
              ipIdAddress = _context5.sent;
              _context5.next = 9;
              return this.isRegistered(ipIdAddress);
            case 9:
              isRegistered = _context5.sent;
              if (!isRegistered) {
                _context5.next = 12;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 12:
              licenseTerm = getLicenseTermByType(request.pilType, {
                defaultMintingFee: request.mintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address,
                commercialRevShare: request.commercialRevShare
              });
              calculatedDeadline = getDeadline(request.deadline);
              _context5.next = 16;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: this.getSigSignatureState({
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.spgClient.address, "spgAddress"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: "function setAll(address,string,bytes32,bytes32)"
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.spgClient.address, "spgAddress"),
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: "function attachLicenseTerms(address,address,uint256)"
                }]
              });
            case 16:
              sigAttachSignature = _context5.sent;
              object = {
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                tokenId: request.tokenId,
                terms: licenseTerm,
                ipMetadata: {
                  ipMetadataURI: ((_request$ipMetadata9 = request.ipMetadata) === null || _request$ipMetadata9 === void 0 ? void 0 : _request$ipMetadata9.ipMetadataURI) || "",
                  ipMetadataHash: ((_request$ipMetadata10 = request.ipMetadata) === null || _request$ipMetadata10 === void 0 ? void 0 : _request$ipMetadata10.ipMetadataHash) || zeroHash,
                  nftMetadataURI: ((_request$ipMetadata11 = request.ipMetadata) === null || _request$ipMetadata11 === void 0 ? void 0 : _request$ipMetadata11.nftMetadataURI) || "",
                  nftMetadataHash: ((_request$ipMetadata12 = request.ipMetadata) === null || _request$ipMetadata12 === void 0 ? void 0 : _request$ipMetadata12.nftMetadataHash) || zeroHash
                },
                sigMetadata: {
                  signer: zeroAddress,
                  deadline: BigInt(0),
                  signature: zeroHash
                },
                sigAttach: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: sigAttachSignature
                }
              };
              _context5.next = 20;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.spgClient.address, "spgAddress"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: "function setAll(address,string,bytes32,bytes32)"
                }]
              });
            case 20:
              sigMetadataSignature = _context5.sent;
              object.sigMetadata = {
                signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                deadline: calculatedDeadline,
                signature: sigMetadataSignature
              };
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 26;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: this.spgClient.registerIpAndAttachPilTermsEncode(object)
              });
            case 26:
              _context5.next = 28;
              return this.spgClient.registerIpAndAttachPilTerms(object);
            case 28:
              txHash = _context5.sent;
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.waitForTransaction)) {
                _context5.next = 38;
                break;
              }
              _context5.next = 32;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 32:
              txReceipt = _context5.sent;
              ipRegisterEvent = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt);
              _context5.next = 36;
              return this.getLicenseTermsId(txReceipt);
            case 36:
              licenseTermsId = _context5.sent;
              return _context5.abrupt("return", {
                txHash: txHash,
                licenseTermsId: licenseTermsId,
                ipId: ipRegisterEvent[0].ipId
              });
            case 38:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 39:
              _context5.next = 44;
              break;
            case 41:
              _context5.prev = 41;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to register IP and attach PIL terms");
            case 44:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 41]]);
      }));
      function registerIpAndAttachPilTerms(_x5) {
        return _registerIpAndAttachPilTerms.apply(this, arguments);
      }
      return registerIpAndAttachPilTerms;
    }()
    /**
     * Register the given NFT as a derivative IP with metadata without using license tokens.
     * @param request - The request object that contains all data needed to register derivative IP.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.tokenId The ID of the NFT.
     *   @param request.derivData The derivative data to be used for registerDerivative.
     *   @param request.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *   @param request.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking.
     *   @param request.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *   @param request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *   @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *   @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *   @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *   @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.
     *   @param request.deadline [Optional] The deadline for the signature in milliseconds,default is 1000ms.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID if waitForTxn is set to true.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "registerDerivativeIp",
    value: (function () {
      var _registerDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var _request$ipMetadata13, _request$ipMetadata14, _request$ipMetadata15, _request$ipMetadata16, _request$txOptions11, tokenId, ipIdAddress, isRegistered, i, isAttachedLicenseTerms, calculatedDeadline, sigRegisterSignature, object, sigMetadataSignature, _request$txOptions12, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              tokenId = BigInt(request.tokenId);
              _context6.next = 4;
              return this.getIpIdAddress(request.nftContract, tokenId);
            case 4:
              ipIdAddress = _context6.sent;
              _context6.next = 7;
              return this.isRegistered(ipIdAddress);
            case 7:
              isRegistered = _context6.sent;
              if (!isRegistered) {
                _context6.next = 10;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 10:
              if (!(request.derivData.parentIpIds.length !== request.derivData.licenseTermsIds.length)) {
                _context6.next = 12;
                break;
              }
              throw new Error("Parent IP IDs and License terms IDs must be provided in pairs.");
            case 12:
              i = 0;
            case 13:
              if (!(i < request.derivData.parentIpIds.length)) {
                _context6.next = 22;
                break;
              }
              _context6.next = 16;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: getAddress$1(request.derivData.parentIpIds[i], "request.derivData.parentIpIds"),
                licenseTemplate: request.derivData.licenseTemplate && getAddress$1(request.derivData.licenseTemplate, "request.derivData.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: BigInt(request.derivData.licenseTermsIds[i])
              });
            case 16:
              isAttachedLicenseTerms = _context6.sent;
              if (isAttachedLicenseTerms) {
                _context6.next = 19;
                break;
              }
              throw new Error("License terms id ".concat(request.derivData.licenseTermsIds[i], " must be attached to the parent ipId ").concat(request.derivData.parentIpIds[i], " before registering derivative."));
            case 19:
              i++;
              _context6.next = 13;
              break;
            case 22:
              calculatedDeadline = getDeadline(request.deadline);
              _context6.next = 25;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: this.getSigSignatureState({
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.spgClient.address, "spgAddress"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: "function setAll(address,string,bytes32,bytes32)"
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.spgClient.address, "spgAddress"),
                  to: getAddress$1(this.licensingModuleClient.address, "licensingModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: "function registerDerivative(address,address[],uint256[],address,bytes)"
                }]
              });
            case 25:
              sigRegisterSignature = _context6.sent;
              object = {
                nftContract: getAddress$1(request.nftContract, "request.nftContract"),
                tokenId: BigInt(request.tokenId),
                derivData: {
                  parentIpIds: request.derivData.parentIpIds.map(function (id) {
                    return getAddress$1(id, "request.derivData.parentIpIds");
                  }),
                  licenseTermsIds: request.derivData.licenseTermsIds.map(function (id) {
                    return BigInt(id);
                  }),
                  licenseTemplate: request.derivData.licenseTemplate && getAddress$1(request.derivData.licenseTemplate, "request.derivData.licenseTemplate") || this.licenseTemplateClient.address,
                  royaltyContext: zeroAddress
                },
                sigRegister: {
                  signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                  deadline: calculatedDeadline,
                  signature: sigRegisterSignature
                },
                ipMetadata: {
                  ipMetadataURI: ((_request$ipMetadata13 = request.ipMetadata) === null || _request$ipMetadata13 === void 0 ? void 0 : _request$ipMetadata13.ipMetadataURI) || "",
                  ipMetadataHash: ((_request$ipMetadata14 = request.ipMetadata) === null || _request$ipMetadata14 === void 0 ? void 0 : _request$ipMetadata14.ipMetadataHash) || zeroHash,
                  nftMetadataURI: ((_request$ipMetadata15 = request.ipMetadata) === null || _request$ipMetadata15 === void 0 ? void 0 : _request$ipMetadata15.nftMetadataURI) || "",
                  nftMetadataHash: ((_request$ipMetadata16 = request.ipMetadata) === null || _request$ipMetadata16 === void 0 ? void 0 : _request$ipMetadata16.nftMetadataHash) || zeroHash
                },
                sigMetadata: {
                  signer: zeroAddress,
                  deadline: BigInt(0),
                  signature: zeroHash
                }
              };
              _context6.next = 29;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: chain[this.chainId],
                permissions: [{
                  ipId: ipIdAddress,
                  signer: getAddress$1(this.spgClient.address, "spgAddress"),
                  to: getAddress$1(this.coreMetadataModuleClient.address, "coreMetadataModuleAddress"),
                  permission: AccessPermission.ALLOW,
                  func: "function setAll(address,string,bytes32,bytes32)"
                }]
              });
            case 29:
              sigMetadataSignature = _context6.sent;
              object.sigMetadata = {
                signer: getAddress$1(this.wallet.account.address, "wallet.account.address"),
                deadline: calculatedDeadline,
                signature: sigMetadataSignature
              };
              if (!((_request$txOptions11 = request.txOptions) !== null && _request$txOptions11 !== void 0 && _request$txOptions11.encodedTxDataOnly)) {
                _context6.next = 35;
                break;
              }
              return _context6.abrupt("return", {
                encodedTxData: this.spgClient.registerIpAndMakeDerivativeEncode(object)
              });
            case 35:
              _context6.next = 37;
              return this.spgClient.registerIpAndMakeDerivative(object);
            case 37:
              txHash = _context6.sent;
              if (!((_request$txOptions12 = request.txOptions) !== null && _request$txOptions12 !== void 0 && _request$txOptions12.waitForTransaction)) {
                _context6.next = 44;
                break;
              }
              _context6.next = 41;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 41:
              receipt = _context6.sent;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context6.abrupt("return", {
                txHash: txHash,
                ipId: log.ipId
              });
            case 44:
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 45:
              _context6.next = 50;
              break;
            case 47:
              _context6.prev = 47;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to register derivative IP");
            case 50:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 47]]);
      }));
      function registerDerivativeIp(_x6) {
        return _registerDerivativeIp.apply(this, arguments);
      }
      return registerDerivativeIp;
    }()
    /**
     * Mint an NFT from a collection and register it as a derivative IP without license tokens.
     * @param request - The request object that contains all data needed to mint and register ip and make derivative.
     *   @param request.nftContract The address of the NFT collection.
     *   @param request.derivData The derivative data to be used for registerDerivative.
     *   @param request.derivData.parentIpIds The IDs of the parent IPs to link the registered derivative IP.
     *   @param request.derivData.licenseTermsIds The IDs of the license terms to be used for the linking.
     *   @param request.derivData.licenseTemplate [Optional] The address of the license template to be used for the linking.
     *   @param request.ipMetadata - [Optional] The desired metadata for the newly minted NFT and newly registered IP.
     *   @param request.ipMetadata.ipMetadataURI [Optional] The URI of the metadata for the IP.
     *   @param request.ipMetadata.ipMetadataHash [Optional] The hash of the metadata for the IP.
     *   @param request.ipMetadata.nftMetadataURI [Optional] The URI of the metadata for the NFT.
     *   @param request.ipMetadata.nftMetadataHash [Optional] The hash of the metadata for the IP NFT.*
     *   @param request.recipient [Optional] The address of the recipient of the minted NFT.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID if waitForTxn is set to true.
     * @emits IPRegistered (ipId, chainId, tokenContract, tokenId, name, uri, registrationDate)
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivative = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {
        var _request$ipMetadata17, _request$ipMetadata18, _request$ipMetadata19, _request$ipMetadata20, _request$txOptions13, i, isAttachedLicenseTerms, object, _request$txOptions14, txHash, receipt, log;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              if (!(request.derivData.parentIpIds.length !== request.derivData.licenseTermsIds.length)) {
                _context7.next = 3;
                break;
              }
              throw new Error("Parent IP IDs and License terms IDs must be provided in pairs.");
            case 3:
              i = 0;
            case 4:
              if (!(i < request.derivData.parentIpIds.length)) {
                _context7.next = 13;
                break;
              }
              _context7.next = 7;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: getAddress$1(request.derivData.parentIpIds[i], "request.derivData.parentIpIds"),
                licenseTemplate: request.derivData.licenseTemplate && getAddress$1(request.derivData.licenseTemplate, "request.derivData.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: BigInt(request.derivData.licenseTermsIds[i])
              });
            case 7:
              isAttachedLicenseTerms = _context7.sent;
              if (isAttachedLicenseTerms) {
                _context7.next = 10;
                break;
              }
              throw new Error("License terms id ".concat(request.derivData.licenseTermsIds[i], " must be attached to the parent ipId ").concat(request.derivData.parentIpIds[i], " before registering derivative."));
            case 10:
              i++;
              _context7.next = 4;
              break;
            case 13:
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                derivData: _objectSpread2(_objectSpread2({}, request.derivData), {}, {
                  royaltyContext: zeroAddress,
                  licenseTemplate: request.derivData.licenseTemplate || this.licenseTemplateClient.address,
                  licenseTermsIds: request.derivData.licenseTermsIds.map(function (id) {
                    return BigInt(id);
                  })
                }),
                ipMetadata: {
                  ipMetadataURI: ((_request$ipMetadata17 = request.ipMetadata) === null || _request$ipMetadata17 === void 0 ? void 0 : _request$ipMetadata17.ipMetadataURI) || "",
                  ipMetadataHash: ((_request$ipMetadata18 = request.ipMetadata) === null || _request$ipMetadata18 === void 0 ? void 0 : _request$ipMetadata18.ipMetadataHash) || zeroHash,
                  nftMetadataURI: ((_request$ipMetadata19 = request.ipMetadata) === null || _request$ipMetadata19 === void 0 ? void 0 : _request$ipMetadata19.nftMetadataURI) || "",
                  nftMetadataHash: ((_request$ipMetadata20 = request.ipMetadata) === null || _request$ipMetadata20 === void 0 ? void 0 : _request$ipMetadata20.nftMetadataHash) || zeroHash
                },
                recipient: request.recipient && getAddress$1(request.recipient, "request.recipient") || this.wallet.account.address
              });
              if (!((_request$txOptions13 = request.txOptions) !== null && _request$txOptions13 !== void 0 && _request$txOptions13.encodedTxDataOnly)) {
                _context7.next = 18;
                break;
              }
              return _context7.abrupt("return", {
                encodedTxData: this.spgClient.mintAndRegisterIpAndMakeDerivativeEncode(object)
              });
            case 18:
              _context7.next = 20;
              return this.spgClient.mintAndRegisterIpAndMakeDerivative(object);
            case 20:
              txHash = _context7.sent;
              if (!((_request$txOptions14 = request.txOptions) !== null && _request$txOptions14 !== void 0 && _request$txOptions14.waitForTransaction)) {
                _context7.next = 27;
                break;
              }
              _context7.next = 24;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 24:
              receipt = _context7.sent;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context7.abrupt("return", {
                txHash: txHash,
                childIpId: log.ipId
              });
            case 27:
              return _context7.abrupt("return", {
                txHash: txHash
              });
            case 28:
              _context7.next = 33;
              break;
            case 30:
              _context7.prev = 30;
              _context7.t0 = _context7["catch"](0);
              handleError(_context7.t0, "Failed to mint and register IP and make derivative");
            case 33:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 30]]);
      }));
      function mintAndRegisterIpAndMakeDerivative(_x7) {
        return _mintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivative;
    }())
  }, {
    key: "getIpIdAddress",
    value: function () {
      var _getIpIdAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(nftContract, tokenId) {
        var ipId;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.ipAssetRegistryClient.ipId({
                chainId: chain[this.chainId],
                tokenContract: getAddress$1(nftContract, "nftContract"),
                tokenId: BigInt(tokenId)
              });
            case 2:
              ipId = _context8.sent;
              return _context8.abrupt("return", ipId);
            case 4:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getIpIdAddress(_x8, _x9) {
        return _getIpIdAddress.apply(this, arguments);
      }
      return getIpIdAddress;
    }()
  }, {
    key: "isRegistered",
    value: function () {
      var _isRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(ipId) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(ipId, "ipId")
              });
            case 2:
              return _context9.abrupt("return", _context9.sent);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function isRegistered(_x10) {
        return _isRegistered.apply(this, arguments);
      }
      return isRegistered;
    }()
  }, {
    key: "getSigSignatureState",
    value: function getSigSignatureState(permission) {
      var data = encodeFunctionData({
        abi: accessControllerAbi,
        functionName: "setPermission",
        args: [getAddress$1(permission.ipId, "permission.ipId"), getAddress$1(permission.signer, "permission.signer"), getAddress$1(permission.to, "permission.to"), toFunctionSelector(permission.func), permission.permission]
      });
      var sigAttachState = keccak256(encodeAbiParameters([{
        name: "",
        type: "bytes32"
      }, {
        name: "",
        type: "bytes"
      }], [toHex(0, {
        size: 32
      }), encodeFunctionData({
        abi: ipAccountImplAbi,
        functionName: "execute",
        args: [this.accessControllerClient.address, 0n, data]
      })]));
      return sigAttachState;
    }
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(txReceipt) {
        var licensingModuleLicenseTermsAttachedEvent, licenseTermsId, defaultLicenseTerms;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              licensingModuleLicenseTermsAttachedEvent = this.licensingModuleClient.parseTxLicenseTermsAttachedEvent(txReceipt);
              licenseTermsId = licensingModuleLicenseTermsAttachedEvent.length >= 1 && licensingModuleLicenseTermsAttachedEvent[0].licenseTermsId;
              if (!(licenseTermsId === false)) {
                _context10.next = 7;
                break;
              }
              _context10.next = 5;
              return this.licenseRegistryReadOnlyClient.getDefaultLicenseTerms();
            case 5:
              defaultLicenseTerms = _context10.sent;
              licenseTermsId = defaultLicenseTerms.licenseTermsId;
            case 7:
              return _context10.abrupt("return", licenseTermsId);
            case 8:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getLicenseTermsId(_x11) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }]);
}();

var PermissionClient = /*#__PURE__*/function () {
  function PermissionClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, PermissionClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.accessControllerClient = new AccessControllerClient(this.rpcClient, this.wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(this.rpcClient, this.wallet);
    this.spgClient = new SpgClient(this.rpcClient, this.wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(this.rpcClient, this.wallet);
  }

  /**
   * Sets the permission for a specific function call
   * Each policy is represented as a mapping from an IP account address to a signer address to a recipient
   * address to a function selector to a permission level. The permission level can be 0 (ABSTAIN), 1 (ALLOW), or
   * 2 (DENY).
   * By default, all policies are set to 0 (ABSTAIN), which means that the permission is not set.
   * The owner of ipAccount by default has all permission.
   * address(0) => wildcard
   * bytes4(0) => wildcard
   * Specific permission overrides wildcard permission.
   * @param request - The request object containing necessary data to set `permission`.
   *   @param request.ipId The IP ID that grants the permission for `signer`.
   *   @param request.signer The address that can call `to` on behalf of the `ipAccount`.
   *   @param request.to The address that can be called by the `signer` (currently only modules can be `to`).
   *   @param request.permission The new permission level.
   *   @param request.func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to an object containing the transaction hash.
   * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
   */
  return _createClass(PermissionClient, [{
    key: "setPermission",
    value: (function () {
      var _setPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, req, _request$txOptions2, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.checkIsRegistered(request.ipId);
            case 3:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                to: request.to,
                func: request.func ? toFunctionSelector(request.func) : defaultFunctionSelector,
                permission: request.permission
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.accessControllerClient.setPermissionEncode(req)
              });
            case 8:
              _context.next = 10;
              return this.accessControllerClient.setPermission(req);
            case 10:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 17;
                break;
              }
              _context.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              return _context.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 17:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context.next = 23;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to set permissions");
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 20]]);
      }));
      function setPermission(_x) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }()
    /**
     * Specific permission overrides wildcard permission with signature.
     * @param request - The request object containing necessary data to set permissions.
     *   @param request.ipId The IP ID that grants the permission for `signer`
     *   @param request.signer The address that can call `to` on behalf of the `ipAccount`
     *   @param request.to The address that can be called by the `signer` (currently only modules can be `to`)
     *   @param request.permission The new permission level.
     *   @param request.func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
     *   @param request.deadline [Optional] The deadline for the signature in milliseconds, default is 1000ms.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "createSetPermissionSignature",
    value: (function () {
      var _createSetPermissionSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, ipId, signer, to, txOptions, func, permission, deadline, ipAccountClient, data, _yield$ipAccountClien, state, calculatedDeadline, signature, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              ipId = request.ipId, signer = request.signer, to = request.to, txOptions = request.txOptions, func = request.func, permission = request.permission, deadline = request.deadline;
              _context2.next = 4;
              return this.checkIsRegistered(ipId);
            case 4:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setPermission",
                args: [ipId, getAddress$1(signer, "request.signer"), getAddress$1(to, "request.to"), func ? toFunctionSelector(func) : defaultFunctionSelector, permission]
              });
              _context2.next = 8;
              return ipAccountClient.state();
            case 8:
              _yield$ipAccountClien = _context2.sent;
              state = _yield$ipAccountClien.result;
              calculatedDeadline = getDeadline(deadline);
              _context2.next = 13;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: [{
                  ipId: ipId,
                  signer: signer,
                  to: to,
                  permission: permission,
                  func: func
                }],
                chainId: chain[this.chainId],
                wallet: this.wallet
              });
            case 13:
              signature = _context2.sent;
              req = {
                to: getAddress$1(this.accessControllerClient.address, "accessControllerClientAddress"),
                value: BigInt(0),
                data: data,
                signer: signer,
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 19;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 19:
              _context2.next = 21;
              return ipAccountClient.executeWithSig(req);
            case 21:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 28;
                break;
              }
              _context2.next = 25;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 25:
              return _context2.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 28:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 29:
              _context2.next = 34;
              break;
            case 31:
              _context2.prev = 31;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to create set permission signature");
            case 34:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 31]]);
      }));
      function createSetPermissionSignature(_x2) {
        return _createSetPermissionSignature.apply(this, arguments);
      }
      return createSetPermissionSignature;
    }()
    /**
     * Sets permission to a signer for all functions across all modules.
     * @param request - The request object containing necessary data to set all permissions.
     *   @param request.ipId The IP ID that grants the permission for `signer`
     *   @param request.signer The address of the signer receiving the permissions.
     *   @param request.permission The new permission.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "setAllPermissions",
    value: (function () {
      var _setAllPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, req, _request$txOptions6, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.checkIsRegistered(request.ipId);
            case 3:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                permission: request.permission
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 8;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.accessControllerClient.setAllPermissionsEncode(req)
              });
            case 8:
              _context3.next = 10;
              return this.accessControllerClient.setAllPermissions(req);
            case 10:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 17;
                break;
              }
              _context3.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              return _context3.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 17:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context3.next = 23;
              break;
            case 20:
              _context3.prev = 20;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to set all permissions");
            case 23:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 20]]);
      }));
      function setAllPermissions(_x3) {
        return _setAllPermissions.apply(this, arguments);
      }
      return setAllPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction.
     * @param request - The request object containing necessary data to set all permissions.
     * @param {Array} request.permissions - An array of `Permission` structure, each representing the permission to be set.
     *   @param request.permissions[].ipId The IP ID that grants the permission for `signer`.
     *   @param request.permissions[].signer The address that can call `to` on behalf of the `ipAccount`.
     *   @param request.permissions[].to The address that can be called by the `signer` (currently only modules can be `to`).
     *   @param request.permissions[].permission The new permission level.
     *   @param request.permissions[].func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
     *   @param request.deadline [Optional] The deadline for the signature in milliseconds, default is 1000ms.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "setBatchPermissions",
    value: (function () {
      var _setBatchPermissions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, permissions, txOptions, _iterator, _step, permission, req, _request$txOptions8, txHash;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              permissions = request.permissions, txOptions = request.txOptions;
              _iterator = _createForOfIteratorHelper(permissions);
              _context4.prev = 3;
              _iterator.s();
            case 5:
              if ((_step = _iterator.n()).done) {
                _context4.next = 11;
                break;
              }
              permission = _step.value;
              _context4.next = 9;
              return this.checkIsRegistered(permission.ipId);
            case 9:
              _context4.next = 5;
              break;
            case 11:
              _context4.next = 16;
              break;
            case 13:
              _context4.prev = 13;
              _context4.t0 = _context4["catch"](3);
              _iterator.e(_context4.t0);
            case 16:
              _context4.prev = 16;
              _iterator.f();
              return _context4.finish(16);
            case 19:
              req = {
                permissions: permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })
              };
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 24;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.accessControllerClient.setBatchPermissionsEncode(req)
              });
            case 24:
              _context4.next = 26;
              return this.accessControllerClient.setBatchPermissions(req);
            case 26:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 33;
                break;
              }
              _context4.next = 30;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 30:
              return _context4.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 33:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 34:
              _context4.next = 39;
              break;
            case 36:
              _context4.prev = 36;
              _context4.t1 = _context4["catch"](0);
              handleError(_context4.t1, "Failed to set batch permissions");
            case 39:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 36], [3, 13, 16, 19]]);
      }));
      function setBatchPermissions(_x4) {
        return _setBatchPermissions.apply(this, arguments);
      }
      return setBatchPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction with signature.
     * @param request - The request object containing necessary data to set permissions.
     *   @param request.ipId The IP ID that grants the permission for `signer`
     *   @param {Array} request.permissions - An array of `Permission` structure, each representing the permission to be set.
     *   @param request.permissions[].ipId The IP ID that grants the permission for `signer`.
     *   @param request.permissions[].signer The address that can call `to` on behalf of the `ipAccount`.
     *   @param request.permissions[].to The address that can be called by the `signer` (currently only modules can be `to`).
     *   @param request.permissions[].permission The new permission level.
     *   @param request.permissions[].func [Optional] The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
     */
    )
  }, {
    key: "createBatchPermissionSignature",
    value: (function () {
      var _createBatchPermissionSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, permissions, deadline, ipId, txOptions, _iterator2, _step2, permission, ipAccountClient, data, _yield$ipAccountClien2, state, calculatedDeadline, signature, req, _request$txOptions10, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              permissions = request.permissions, deadline = request.deadline, ipId = request.ipId, txOptions = request.txOptions;
              _iterator2 = _createForOfIteratorHelper(permissions);
              _context5.prev = 3;
              _iterator2.s();
            case 5:
              if ((_step2 = _iterator2.n()).done) {
                _context5.next = 11;
                break;
              }
              permission = _step2.value;
              _context5.next = 9;
              return this.checkIsRegistered(permission.ipId);
            case 9:
              _context5.next = 5;
              break;
            case 11:
              _context5.next = 16;
              break;
            case 13:
              _context5.prev = 13;
              _context5.t0 = _context5["catch"](3);
              _iterator2.e(_context5.t0);
            case 16:
              _context5.prev = 16;
              _iterator2.f();
              return _context5.finish(16);
            case 19:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setBatchPermissions",
                args: [permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })]
              });
              _context5.next = 23;
              return ipAccountClient.state();
            case 23:
              _yield$ipAccountClien2 = _context5.sent;
              state = _yield$ipAccountClien2.result;
              calculatedDeadline = getDeadline(deadline);
              _context5.next = 28;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: permissions,
                chainId: chain[this.chainId],
                wallet: this.wallet,
                permissionFunc: "setBatchPermissions"
              });
            case 28:
              signature = _context5.sent;
              req = {
                to: getAddress$1(this.accessControllerClient.address, "accessControllerAddress"),
                value: BigInt(0),
                data: data,
                signer: getAddress$1(this.wallet.account.address, "walletAccountAddress"),
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 34;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 34:
              _context5.next = 36;
              return ipAccountClient.executeWithSig(req);
            case 36:
              txHash = _context5.sent;
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.waitForTransaction)) {
                _context5.next = 43;
                break;
              }
              _context5.next = 40;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 40:
              return _context5.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 43:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 44:
              _context5.next = 49;
              break;
            case 46:
              _context5.prev = 46;
              _context5.t1 = _context5["catch"](0);
              handleError(_context5.t1, "Failed to create batch permission signature");
            case 49:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 46], [3, 13, 16, 19]]);
      }));
      function createBatchPermissionSignature(_x5) {
        return _createBatchPermissionSignature.apply(this, arguments);
      }
      return createBatchPermissionSignature;
    }())
  }, {
    key: "checkIsRegistered",
    value: function () {
      var _checkIsRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(ipId) {
        var isRegistered;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(ipId, "ipId")
              });
            case 2:
              isRegistered = _context6.sent;
              if (isRegistered) {
                _context6.next = 5;
                break;
              }
              throw new Error("IP id with ".concat(ipId, " is not registered."));
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function checkIsRegistered(_x6) {
        return _checkIsRegistered.apply(this, arguments);
      }
      return checkIsRegistered;
    }()
  }]);
}();

var LicenseClient = /*#__PURE__*/function () {
  function LicenseClient(rpcClient, wallet) {
    _classCallCheck(this, LicenseClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.licenseRegistryClient = new LicenseRegistryEventClient(rpcClient);
    this.piLicenseTemplateReadOnlyClient = new PiLicenseTemplateReadOnlyClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.royaltyPolicyLAPClient = new RoyaltyPolicyLapClient(rpcClient, wallet);
    this.royaltyModuleReadOnlyClient = new RoyaltyModuleReadOnlyClient(rpcClient);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }
  /**
   * Registers new license terms and return the ID of the newly registered license terms.
   * @param request - The request object that contains all data needed to register a license term.
   *   @param request.transferable Indicates whether the license is transferable or not.
   *   @param request.royaltyPolicy The address of the royalty policy contract which required to StoryProtocol in advance.
   *   @param request.mintingFee The fee to be paid when minting a license.
   *   @param request.expiration The expiration period of the license.
   *   @param request.commercialUse Indicates whether the work can be used commercially or not.
   *   @param request.commercialAttribution Whether attribution is required when reproducing the work commercially or not.
   *   @param request.commercializerChecker Commercializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
   *   @param request.commercializerCheckerData The data to be passed to the commercializer checker contract.
   *   @param request.commercialRevShare Percentage of revenue that must be shared with the licensor.
   *   @param request.commercialRevCeiling The maximum revenue that can be generated from the commercial use of the work.
   *   @param request.derivativesAllowed Indicates whether the licensee can create derivatives of his work or not.
   *   @param request.derivativesAttribution Indicates whether attribution is required for derivatives of the work or not.
   *   @param request.derivativesApproval Indicates whether the licensor must approve derivatives of the work before they can be linked to the licensor IP ID or not.
   *   @param request.derivativesReciprocal Indicates whether the licensee must license derivatives of the work under the same terms or not.
   *   @param request.derivativeRevCeiling The maximum revenue that can be generated from the derivative use of the work.
   *   @param request.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
   *   @param request.uri The URI of the license terms, which can be used to fetch the offchain license terms.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to an object containing the optional transaction hash, optional transaction encodedTxData and optional license terms Id.
   * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
   */
  return _createClass(LicenseClient, [{
    key: "registerPILTerms",
    value: (function () {
      var _registerPILTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, royaltyPolicy, currency, isWhitelistedArbitrationPolicy, isWhitelistedRoyaltyToken, object, licenseTermsId, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              royaltyPolicy = request.royaltyPolicy, currency = request.currency;
              if (!(getAddress$1(royaltyPolicy, "request.royaltyPolicy") !== zeroAddress)) {
                _context.next = 8;
                break;
              }
              _context.next = 5;
              return this.royaltyModuleReadOnlyClient.isWhitelistedRoyaltyPolicy({
                royaltyPolicy: royaltyPolicy
              });
            case 5:
              isWhitelistedArbitrationPolicy = _context.sent;
              if (isWhitelistedArbitrationPolicy) {
                _context.next = 8;
                break;
              }
              throw new Error("The royalty policy is not whitelisted.");
            case 8:
              if (!(getAddress$1(currency, "request.currency") !== zeroAddress)) {
                _context.next = 14;
                break;
              }
              _context.next = 11;
              return this.royaltyModuleReadOnlyClient.isWhitelistedRoyaltyToken({
                token: currency
              });
            case 11:
              isWhitelistedRoyaltyToken = _context.sent;
              if (isWhitelistedRoyaltyToken) {
                _context.next = 14;
                break;
              }
              throw new Error("The currency token is not whitelisted.");
            case 14:
              if (!(royaltyPolicy !== zeroAddress && currency === zeroAddress)) {
                _context.next = 16;
                break;
              }
              throw new Error("Royalty policy requires currency token.");
            case 16:
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                defaultMintingFee: BigInt(request.defaultMintingFee),
                expiration: BigInt(request.expiration),
                commercialRevCeiling: BigInt(request.commercialRevCeiling),
                derivativeRevCeiling: BigInt(request.derivativeRevCeiling)
              });
              this.verifyCommercialUse(object);
              this.verifyDerivatives(object);
              if (!(object.commercialRevShare < 0 || object.commercialRevShare > 100)) {
                _context.next = 23;
                break;
              }
              throw new Error("CommercialRevShare should be between 0 and 100.");
            case 23:
              object.commercialRevShare = object.commercialRevShare / 100 * 100000000;
            case 24:
              _context.next = 26;
              return this.getLicenseTermsId(object);
            case 26:
              licenseTermsId = _context.sent;
              if (!(licenseTermsId !== 0n)) {
                _context.next = 29;
                break;
              }
              return _context.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 29:
              if (!(request !== null && request !== void 0 && (_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 33;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: object
                })
              });
            case 33:
              _context.next = 35;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: object
              });
            case 35:
              txHash = _context.sent;
              if (!(request !== null && request !== void 0 && (_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 44;
                break;
              }
              _context.next = 39;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 39:
              txReceipt = _context.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 44:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 45:
              _context.next = 50;
              break;
            case 47:
              _context.prev = 47;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register license terms");
            case 50:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 47]]);
      }));
      function registerPILTerms(_x) {
        return _registerPILTerms.apply(this, arguments);
      }
      return registerPILTerms;
    }()
    /**
     * Convenient function to register a PIL non commercial social remix license to the registry
     * @param request - [Optional] The request object that contains all data needed to register a PIL non commercial social remix license.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the optional transaction hash and optional license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerNonComSocialRemixingPIL",
    value: (function () {
      var _registerNonComSocialRemixingPIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, licenseTerms, licenseTermsId, _request$txOptions4, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.NON_COMMERCIAL_REMIX);
              _context2.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context2.sent;
              if (!(licenseTermsId !== 0n)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!(request !== null && request !== void 0 && (_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 11;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context2.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context2.sent;
              if (!(request !== null && request !== void 0 && (_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 22;
                break;
              }
              _context2.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context2.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context2.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context2.next = 28;
              break;
            case 25:
              _context2.prev = 25;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to register non commercial social remixing PIL");
            case 28:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 25]]);
      }));
      function registerNonComSocialRemixingPIL(_x2) {
        return _registerNonComSocialRemixingPIL.apply(this, arguments);
      }
      return registerNonComSocialRemixingPIL;
    }()
    /**
     * Convenient function to register a PIL commercial use license to the registry.
     * @param request - The request object that contains all data needed to register a PIL commercial use license.
     *   @param request.defaultMintingFee The fee to be paid when minting a license.
     *   @param request.currency The ERC20 token to be used to pay the minting fee and the token must be registered in story protocol.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the optional transaction hash and optional license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerCommercialUsePIL",
    value: (function () {
      var _registerCommercialUsePIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, licenseTerms, licenseTermsId, _request$txOptions6, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_USE, {
                defaultMintingFee: request.defaultMintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address
              });
              _context3.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context3.sent;
              if (!(licenseTermsId !== 0n)) {
                _context3.next = 7;
                break;
              }
              return _context3.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 11;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context3.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 22;
                break;
              }
              _context3.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context3.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context3.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context3.next = 28;
              break;
            case 25:
              _context3.prev = 25;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to register commercial use PIL");
            case 28:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 25]]);
      }));
      function registerCommercialUsePIL(_x3) {
        return _registerCommercialUsePIL.apply(this, arguments);
      }
      return registerCommercialUsePIL;
    }()
    /**
     * Convenient function to register a PIL commercial Remix license to the registry.
     * @param request - The request object that contains all data needed to register license.
     *   @param request.defaultMintingFee The fee to be paid when minting a license.
     *   @param request.commercialRevShare Percentage of revenue that must be shared with the licensor.
     *   @param request.currency The ERC20 token to be used to pay the minting fee. the token must be registered in story protocol.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the optional transaction hash and optional license terms Id.
     * @emits LicenseTermsRegistered (licenseTermsId, licenseTemplate, licenseTerms);
     */
    )
  }, {
    key: "registerCommercialRemixPIL",
    value: (function () {
      var _registerCommercialRemixPIL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, licenseTerms, licenseTermsId, _request$txOptions8, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              licenseTerms = getLicenseTermByType(PIL_TYPE.COMMERCIAL_REMIX, {
                defaultMintingFee: request.defaultMintingFee,
                currency: request.currency,
                royaltyPolicyLAPAddress: this.royaltyPolicyLAPClient.address,
                commercialRevShare: request.commercialRevShare
              });
              _context4.next = 4;
              return this.getLicenseTermsId(licenseTerms);
            case 4:
              licenseTermsId = _context4.sent;
              if (!(licenseTermsId !== 0n)) {
                _context4.next = 7;
                break;
              }
              return _context4.abrupt("return", {
                licenseTermsId: licenseTermsId
              });
            case 7:
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context4.next = 11;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 11:
              _context4.next = 13;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 13:
              txHash = _context4.sent;
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.waitForTransaction)) {
                _context4.next = 22;
                break;
              }
              _context4.next = 17;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 17:
              txReceipt = _context4.sent;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(txReceipt);
              return _context4.abrupt("return", {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 22:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 23:
              _context4.next = 28;
              break;
            case 25:
              _context4.prev = 25;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to register commercial remix PIL");
            case 28:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 25]]);
      }));
      function registerCommercialRemixPIL(_x4) {
        return _registerCommercialRemixPIL.apply(this, arguments);
      }
      return registerCommercialRemixPIL;
    }()
    /**
     * Attaches license terms to an IP.
     * @param request - The request object that contains all data needed to attach license terms.
     *   @param request.ipId The address of the IP to which the license terms are attached.
     *   @param request.licenseTemplate The address of the license template.
     *   @param request.licenseTermsId The ID of the license terms.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "attachLicenseTerms",
    value: (function () {
      var _attachLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions9, isRegistered, isExisted, isAttachedLicenseTerms, req, _request$txOptions10, txHash;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              request.licenseTermsId = BigInt(request.licenseTermsId);
              _context5.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.ipId, "request.ipId")
              });
            case 4:
              isRegistered = _context5.sent;
              if (isRegistered) {
                _context5.next = 7;
                break;
              }
              throw new Error("The IP with id ".concat(request.ipId, " is not registered."));
            case 7:
              _context5.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: request.licenseTermsId
              });
            case 9:
              isExisted = _context5.sent;
              if (isExisted) {
                _context5.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              _context5.next = 14;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate && getAddress$1(request.licenseTemplate, "request.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              });
            case 14:
              isAttachedLicenseTerms = _context5.sent;
              if (!isAttachedLicenseTerms) {
                _context5.next = 17;
                break;
              }
              return _context5.abrupt("return", {
                txHash: "",
                success: false
              });
            case 17:
              req = {
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              };
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context5.next = 22;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: this.licensingModuleClient.attachLicenseTermsEncode(req)
              });
            case 22:
              _context5.next = 24;
              return this.licensingModuleClient.attachLicenseTerms(req);
            case 24:
              txHash = _context5.sent;
              if (!((_request$txOptions10 = request.txOptions) !== null && _request$txOptions10 !== void 0 && _request$txOptions10.waitForTransaction)) {
                _context5.next = 31;
                break;
              }
              _context5.next = 28;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 28:
              return _context5.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 31:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 32:
              _context5.next = 37;
              break;
            case 34:
              _context5.prev = 34;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to attach license terms");
            case 37:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 34]]);
      }));
      function attachLicenseTerms(_x5) {
        return _attachLicenseTerms.apply(this, arguments);
      }
      return attachLicenseTerms;
    }()
    /**
     * Mints license tokens for the license terms attached to an IP.
     * The license tokens are minted to the receiver.
     * The license terms must be attached to the IP before calling this function.
     * But it can mint license token of default license terms without attaching the default license terms,
     * since it is attached to all IPs by default.
     * IP owners can mint license tokens for their IPs for arbitrary license terms
     * without attaching the license terms to IP.
     * It might require the caller pay the minting fee, depending on the license terms or configured by the iP owner.
     * The minting fee is paid in the minting fee token specified in the license terms or configured by the IP owner.
     * IP owners can configure the minting fee of their IPs or
     * configure the minting fee module to determine the minting fee.
     * @param request - The request object that contains all data needed to mint license tokens.
     *   @param request.licensorIpId The licensor IP ID.
     *   @param request.licenseTemplate The address of the license template.
     *   @param request.licenseTermsId The ID of the license terms within the license template.
     *   @param request.amount The amount of license tokens to mint.
     *   @param request.receiver The address of the receiver.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional license token IDs if waitForTxn is set to true.
     * @emits LicenseTokensMinted (msg.sender, licensorIpId, licenseTemplate, licenseTermsId, amount, receiver, startLicenseTokenId);
     */
    )
  }, {
    key: "mintLicenseTokens",
    value: (function () {
      var _mintLicenseTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {
        var _request$txOptions11, isLicenseIpIdRegistered, isExisted, isAttachedLicenseTerms, amount, req, _request$txOptions12, txHash, txReceipt, targetLogs, startLicenseTokenId, licenseTokenIds, i;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              request.licenseTermsId = BigInt(request.licenseTermsId);
              _context6.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.licensorIpId, "request.licensorIpId")
              });
            case 4:
              isLicenseIpIdRegistered = _context6.sent;
              if (isLicenseIpIdRegistered) {
                _context6.next = 7;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 7:
              _context6.next = 9;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: request.licenseTermsId
              });
            case 9:
              isExisted = _context6.sent;
              if (isExisted) {
                _context6.next = 12;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 12:
              _context6.next = 14;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.licensorIpId,
                licenseTemplate: request.licenseTemplate && getAddress$1(request.licenseTemplate, "request.licenseTemplate") || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              });
            case 14:
              isAttachedLicenseTerms = _context6.sent;
              if (isAttachedLicenseTerms) {
                _context6.next = 17;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " is not attached to the IP with id ").concat(request.licensorIpId, "."));
            case 17:
              amount = BigInt(request.amount || 1);
              req = {
                licensorIpId: request.licensorIpId,
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId,
                amount: amount,
                receiver: request.receiver && getAddress$1(request.receiver, "request.receiver") || this.wallet.account.address,
                royaltyContext: zeroAddress
              };
              if (!((_request$txOptions11 = request.txOptions) !== null && _request$txOptions11 !== void 0 && _request$txOptions11.encodedTxDataOnly)) {
                _context6.next = 23;
                break;
              }
              return _context6.abrupt("return", {
                encodedTxData: this.licensingModuleClient.mintLicenseTokensEncode(req)
              });
            case 23:
              _context6.next = 25;
              return this.licensingModuleClient.mintLicenseTokens(req);
            case 25:
              txHash = _context6.sent;
              if (!((_request$txOptions12 = request.txOptions) !== null && _request$txOptions12 !== void 0 && _request$txOptions12.waitForTransaction)) {
                _context6.next = 37;
                break;
              }
              _context6.next = 29;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 29:
              txReceipt = _context6.sent;
              targetLogs = this.licensingModuleClient.parseTxLicenseTokensMintedEvent(txReceipt);
              startLicenseTokenId = targetLogs[0].startLicenseTokenId;
              licenseTokenIds = [];
              for (i = 0; i < amount; i++) {
                licenseTokenIds.push(startLicenseTokenId + BigInt(i));
              }
              return _context6.abrupt("return", {
                txHash: txHash,
                licenseTokenIds: licenseTokenIds
              });
            case 37:
              return _context6.abrupt("return", {
                txHash: txHash
              });
            case 38:
              _context6.next = 43;
              break;
            case 40:
              _context6.prev = 40;
              _context6.t0 = _context6["catch"](0);
              handleError(_context6.t0, "Failed to mint license tokens");
            case 43:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[0, 40]]);
      }));
      function mintLicenseTokens(_x6) {
        return _mintLicenseTokens.apply(this, arguments);
      }
      return mintLicenseTokens;
    }()
    /**
     * Gets license terms of the given ID.
     * @param selectedLicenseTermsId The ID of the license terms.
     * @returns A Promise that resolves to an object containing the PILTerms associate with the given ID.
     */
    )
  }, {
    key: "getLicenseTerms",
    value: (function () {
      var _getLicenseTerms = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(selectedLicenseTermsId) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return this.piLicenseTemplateReadOnlyClient.getLicenseTerms({
                selectedLicenseTermsId: BigInt(selectedLicenseTermsId)
              });
            case 3:
              return _context7.abrupt("return", _context7.sent);
            case 6:
              _context7.prev = 6;
              _context7.t0 = _context7["catch"](0);
              handleError(_context7.t0, "Failed to get license terms");
            case 9:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[0, 6]]);
      }));
      function getLicenseTerms(_x7) {
        return _getLicenseTerms.apply(this, arguments);
      }
      return getLicenseTerms;
    }())
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {
        var licenseRes;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: request
              });
            case 2:
              licenseRes = _context8.sent;
              return _context8.abrupt("return", licenseRes.selectedLicenseTermsId);
            case 4:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getLicenseTermsId(_x8) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }, {
    key: "verifyCommercialUse",
    value: function verifyCommercialUse(terms) {
      if (!terms.commercialUse) {
        if (terms.commercialAttribution) {
          throw new Error("Cannot add commercial attribution when commercial use is disabled.");
        }
        if (terms.commercializerChecker !== zeroAddress) {
          throw new Error("Cannot add commercializerChecker when commercial use is disabled.");
        }
        if (terms.commercialRevShare > 0) {
          throw new Error("Cannot add commercial revenue share when commercial use is disabled.");
        }
        if (terms.commercialRevCeiling > 0) {
          throw new Error("Cannot add commercial revenue ceiling when commercial use is disabled.");
        }
        if (terms.derivativeRevCeiling > 0) {
          throw new Error("Cannot add derivative revenue ceiling share when commercial use is disabled.");
        }
        if (terms.royaltyPolicy !== zeroAddress) {
          throw new Error("Cannot add commercial royalty policy when commercial use is disabled.");
        }
      } else {
        if (terms.royaltyPolicy === zeroAddress) {
          throw new Error("Royalty policy is required when commercial use is enabled.");
        }
      }
    }
  }, {
    key: "verifyDerivatives",
    value: function verifyDerivatives(terms) {
      if (!terms.derivativesAllowed) {
        if (terms.derivativesAttribution) {
          throw new Error("Cannot add derivative attribution when derivative use is disabled.");
        }
        if (terms.derivativesApproval) {
          throw new Error("Cannot add derivative approval when derivative use is disabled.");
        }
        if (terms.derivativesReciprocal) {
          throw new Error("Cannot add derivative reciprocal when derivative use is disabled.");
        }
        if (terms.derivativeRevCeiling > 0) {
          throw new Error("Cannot add derivative revenue ceiling when derivative use is disabled.");
        }
      }
    }
  }]);
}();

var DisputeClient = /*#__PURE__*/function () {
  function DisputeClient(rpcClient, wallet) {
    _classCallCheck(this, DisputeClient);
    this.rpcClient = rpcClient;
    this.disputeModuleClient = new DisputeModuleClient(rpcClient, wallet);
  }

  /**
   * Raises a dispute on a given ipId
   * @param request - The request object containing necessary data to raise a dispute.
   *   @param request.targetIpId - The IP ID that is the target of the dispute.
   *   @param request.arbitrationPolicy - The address of the arbitration policy.
   *   @param request.linkToDisputeEvidence - The link to the dispute evidence.
   *   @param request.targetTag - The target tag of the dispute.
   *   @param request.calldata - Optional calldata to initialize the policy.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to a RaiseDisputeResponse containing the transaction hash.
   * @throws `NotRegisteredIpId` if targetIpId is not registered in the IPA Registry.
   * @throws `NotWhitelistedDisputeTag` if targetTag is not whitelisted.
   * @throws `ZeroLinkToDisputeEvidence` if linkToDisputeEvidence is empty
   * @calls raiseDispute(address _targetIpId, string memory _linkToDisputeEvidence, bytes32 _targetTag, bytes calldata _data) external nonReentrant returns (uint256) {
   * @emits DisputeRaised (disputeId_, targetIpId, msg.sender, arbitrationPolicy, linkToDisputeEvidence, targetTag, calldata);
   */
  return _createClass(DisputeClient, [{
    key: "raiseDispute",
    value: (function () {
      var _raiseDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, req, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              req = {
                targetIpId: getAddress$1(request.targetIpId, "request.targetIpId"),
                linkToDisputeEvidence: request.linkToDisputeEvidence,
                targetTag: stringToHex(request.targetTag, {
                  size: 32
                }),
                data: request.calldata || "0x"
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.disputeModuleClient.raiseDisputeEncode(req)
              });
            case 6:
              _context.next = 8;
              return this.disputeModuleClient.raiseDispute(req);
            case 8:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 15;
                break;
              }
              _context.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              txReceipt = _context.sent;
              targetLogs = this.disputeModuleClient.parseTxDisputeRaisedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                disputeId: targetLogs[0].disputeId
              });
            case 15:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context.next = 21;
              break;
            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to raise dispute");
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 18]]);
      }));
      function raiseDispute(_x) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * Cancels an ongoing dispute
     * @param request - The request object containing details to cancel the dispute.
     *   @param request.disputeId The ID of the dispute to be cancelled.
     *   @param request.calldata Optional additional data used in the cancellation process.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a CancelDisputeResponse containing the transaction hash.
     * @throws NotInDisputeState, if the currentTag of the Dispute is not being disputed
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @throws error if the Dispute's ArbitrationPolicy contract is not valid
     * @calls cancelDispute(uint256 _disputeId, bytes calldata _data) external nonReentrant {
     * @emits DisputeCancelled (_disputeId, _data);
     */
    )
  }, {
    key: "cancelDispute",
    value: (function () {
      var _cancelDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              req = {
                disputeId: BigInt(request.disputeId),
                data: request.calldata ? request.calldata : "0x"
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 6;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.disputeModuleClient.cancelDisputeEncode(req)
              });
            case 6:
              _context2.next = 8;
              return this.disputeModuleClient.cancelDispute(req);
            case 8:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 12;
                break;
              }
              _context2.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 13:
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to cancel dispute");
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 15]]);
      }));
      function cancelDispute(_x2) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * Resolves a dispute after it has been judged
     * @param request - The request object containing details to resolve the dispute.
     *   @param request.disputeId The ID of the dispute to be resolved.
     *   @param request.data The data to resolve the dispute.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to a ResolveDisputeResponse.
     * @throws NotAbleToResolve, if currentTag is still in dispute (i.e still needs a judgement to be set)
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @emits DisputeResolved (_disputeId)
     */
    )
  }, {
    key: "resolveDispute",
    value: (function () {
      var _resolveDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions5, req, _request$txOptions6, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              req = {
                disputeId: BigInt(request.disputeId),
                data: request.data
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context3.next = 6;
                break;
              }
              return _context3.abrupt("return", {
                encodedTxData: this.disputeModuleClient.resolveDisputeEncode(req)
              });
            case 6:
              _context3.next = 8;
              return this.disputeModuleClient.resolveDispute(req);
            case 8:
              txHash = _context3.sent;
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.waitForTransaction)) {
                _context3.next = 12;
                break;
              }
              _context3.next = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 13:
              _context3.next = 18;
              break;
            case 15:
              _context3.prev = 15;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to resolve dispute");
            case 18:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 15]]);
      }));
      function resolveDispute(_x3) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }())
  }]);
}();

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var IPAccountClient = /*#__PURE__*/function () {
  function IPAccountClient(rpcClient, wallet) {
    _classCallCheck(this, IPAccountClient);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
  }

  /** Executes a transaction from the IP Account.
   * @param request - The request object containing necessary data to execute IP Account a transaction.
   *   @param request.ipId The Ip Id to get ip account.
   *   @param request.to The recipient of the transaction.
   *   @param request.value The amount of Ether to send.
   *   @param request.accountAddress The ipId to send.
   *   @param request.data The data to send along with the transaction.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns Tx hash for the transaction.
   */
  return _createClass(IPAccountClient, [{
    key: "execute",
    value: (function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, ipAccountClient, req, _request$txOptions2, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(request.ipId, "request.ipId"));
              req = {
                to: request.to,
                value: BigInt(0),
                data: request.data
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: ipAccountClient.executeEncode(_objectSpread2(_objectSpread2({}, req), {}, {
                  operation: 0
                }))
              });
            case 7:
              _context.next = 9;
              return ipAccountClient.execute(_objectSpread2(_objectSpread2({}, req), {}, {
                operation: 0
              }));
            case 9:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 13;
                break;
              }
              _context.next = 13;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 13:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context.next = 19;
              break;
            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to execute the IP Account transaction");
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 16]]);
      }));
      function execute(_x) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /** Executes a transaction from the IP Account.
     * @param request - The request object containing necessary data to execute IP Account a transaction.
     *   @param request.ipId The Ip Id to get ip account.
     *   @param request.to The recipient of the transaction.
     *   @param request.value The amount of Ether to send.
     *   @param request.data The data to send along with the transaction.
     *   @param request.signer The signer of the transaction.
     *   @param request.deadline The deadline of the transaction signature.
     *   @param request.signature The signature of the transaction, EIP-712 encoded.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns Tx hash for the transaction.
     */
    )
  }, {
    key: "executeWithSig",
    value: (function () {
      var _executeWithSig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, ipAccountClient, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(request.ipId, "request.ipId"));
              req = {
                to: getAddress$1(request.to, "request.to"),
                value: BigInt(0),
                data: request.data,
                signer: getAddress$1(request.signer, "request.signer"),
                deadline: BigInt(request.deadline),
                signature: request.signature
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 7:
              _context2.next = 9;
              return ipAccountClient.executeWithSig(req);
            case 9:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 13;
                break;
              }
              _context2.next = 13;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 13:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context2.next = 19;
              break;
            case 16:
              _context2.prev = 16;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to execute with signature for the IP Account transaction");
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 16]]);
      }));
      function executeWithSig(_x2) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }()
    /** Returns the IPAccount's internal nonce for transaction ordering.
     * @param ipId The IP ID
     * @returns A Promise that resolves to the IP Account's nonce.
     */
    )
  }, {
    key: "getIpAccountNonce",
    value: (function () {
      var _getIpAccountNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ipId) {
        var ipAccount, _yield$ipAccount$stat, state;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(ipId, "ipId"));
              _context3.next = 4;
              return ipAccount.state();
            case 4:
              _yield$ipAccount$stat = _context3.sent;
              state = _yield$ipAccount$stat.result;
              return _context3.abrupt("return", state);
            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to get the IP Account nonce");
            case 12:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 9]]);
      }));
      function getIpAccountNonce(_x3) {
        return _getIpAccountNonce.apply(this, arguments);
      }
      return getIpAccountNonce;
    }()
    /**
     * Returns the identifier of the non-fungible token which owns the account
     * @returns A Promise that resolves to an object containing the chain ID, token contract address, and token ID.
     */
    )
  }, {
    key: "getToken",
    value: (function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ipId) {
        var ipAccount, _yield$ipAccount$toke, _yield$ipAccount$toke2, chainId, tokenContract, tokenId;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, getAddress$1(ipId, "ipId"));
              _context4.next = 4;
              return ipAccount.token();
            case 4:
              _yield$ipAccount$toke = _context4.sent;
              _yield$ipAccount$toke2 = _slicedToArray(_yield$ipAccount$toke, 3);
              chainId = _yield$ipAccount$toke2[0];
              tokenContract = _yield$ipAccount$toke2[1];
              tokenId = _yield$ipAccount$toke2[2];
              return _context4.abrupt("return", {
                chainId: chainId,
                tokenContract: tokenContract,
                tokenId: tokenId
              });
            case 12:
              _context4.prev = 12;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to get the token");
            case 15:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 12]]);
      }));
      function getToken(_x4) {
        return _getToken.apply(this, arguments);
      }
      return getToken;
    }())
  }]);
}();

var RoyaltyClient = /*#__PURE__*/function () {
  function RoyaltyClient(rpcClient, wallet) {
    _classCallCheck(this, RoyaltyClient);
    this.royaltyPolicyLapClient = new RoyaltyPolicyLapClient(rpcClient, wallet);
    this.royaltyModuleClient = new RoyaltyModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.ipAccountClient = new IPAccountClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * Allows ancestors to claim the royalty tokens and any accrued revenue tokens
   * @param request - The request object that contains all data needed to collect royalty tokens.
   *   @param request.parentIpId The ip id of the ancestor to whom the royalty tokens belong to.
   *   @param request.royaltyVaultIpId The id of the royalty vault.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to an object containing the transaction hash and optional the amount of royalty tokens collected if waitForTxn is set to true.
   * @emits RoyaltyTokensCollected (ancestorIpId, royaltyTokensCollected)
   */
  return _createClass(RoyaltyClient, [{
    key: "collectRoyaltyTokens",
    value: (function () {
      var _collectRoyaltyTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, isParentIpIdRegistered, proxyAddress, ipRoyaltyVault, req, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(request.parentIpId, "request.parentIpId")
              });
            case 3:
              isParentIpIdRegistered = _context.sent;
              if (isParentIpIdRegistered) {
                _context.next = 6;
                break;
              }
              throw new Error("The parent IP with id ".concat(request.parentIpId, " is not registered."));
            case 6:
              _context.next = 8;
              return this.getRoyaltyVaultAddress(getAddress$1(request.royaltyVaultIpId, "request.royaltyVaultIpId"));
            case 8:
              proxyAddress = _context.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              req = {
                ancestorIpId: request.parentIpId
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 15;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: ipRoyaltyVault.collectRoyaltyTokensEncode(req)
              });
            case 15:
              _context.next = 17;
              return ipRoyaltyVault.collectRoyaltyTokens(req);
            case 17:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 26;
                break;
              }
              _context.next = 21;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 21:
              txReceipt = _context.sent;
              targetLogs = ipRoyaltyVault.parseTxRoyaltyTokensCollectedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                royaltyTokensCollected: targetLogs[0].royaltyTokensCollected
              });
            case 26:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 27:
              _context.next = 32;
              break;
            case 29:
              _context.prev = 29;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to collect royalty tokens");
            case 32:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 29]]);
      }));
      function collectRoyaltyTokens(_x) {
        return _collectRoyaltyTokens.apply(this, arguments);
      }
      return collectRoyaltyTokens;
    }()
    /**
     * Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.
     * @param request - The request object that contains all data needed to pay royalty on behalf.
     *   @param request.receiverIpId The ipId that receives the royalties.
     *   @param request.payerIpId The ID of the IP asset that pays the royalties.
     *   @param request.token The token to use to pay the royalties.
     *   @param request.amount The amount to pay.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash.
     */
    )
  }, {
    key: "payRoyaltyOnBehalf",
    value: (function () {
      var _payRoyaltyOnBehalf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions3, receiverIpId, payerIpId, token, amount, isReceiverRegistered, isPayerRegistered, req, _request$txOptions4, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              receiverIpId = request.receiverIpId, payerIpId = request.payerIpId, token = request.token, amount = request.amount;
              _context2.next = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(receiverIpId, "request.receiverIpId")
              });
            case 4:
              isReceiverRegistered = _context2.sent;
              if (isReceiverRegistered) {
                _context2.next = 7;
                break;
              }
              throw new Error("The receiver IP with id ".concat(receiverIpId, " is not registered."));
            case 7:
              if (!(getAddress$1(payerIpId, "request.payerIpId") && payerIpId !== zeroAddress)) {
                _context2.next = 13;
                break;
              }
              _context2.next = 10;
              return this.ipAssetRegistryClient.isRegistered({
                id: payerIpId
              });
            case 10:
              isPayerRegistered = _context2.sent;
              if (isPayerRegistered) {
                _context2.next = 13;
                break;
              }
              throw new Error("The payer IP with id ".concat(request.payerIpId, " is not registered."));
            case 13:
              req = {
                receiverIpId: receiverIpId,
                payerIpId: payerIpId,
                token: getAddress$1(token, "request.token"),
                amount: BigInt(amount)
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context2.next = 18;
                break;
              }
              return _context2.abrupt("return", {
                encodedTxData: this.royaltyModuleClient.payRoyaltyOnBehalfEncode(req)
              });
            case 18:
              _context2.next = 20;
              return this.royaltyModuleClient.payRoyaltyOnBehalf(req);
            case 20:
              txHash = _context2.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context2.next = 27;
                break;
              }
              _context2.next = 24;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 24:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 27:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 28:
              _context2.next = 33;
              break;
            case 30:
              _context2.prev = 30;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to pay royalty on behalf");
            case 33:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 30]]);
      }));
      function payRoyaltyOnBehalf(_x2) {
        return _payRoyaltyOnBehalf.apply(this, arguments);
      }
      return payRoyaltyOnBehalf;
    }()
    /**
     * Calculates the amount of revenue token claimable by a token holder at certain snapshot.
     * @param request - The request object that contains all data needed to claim Revenue.
     *   @param request.royaltyVaultIpId The id of the royalty vault.
     *   @param request.account The address of the token holder.
     *   @param request.snapshotId The snapshot id.
     *   @param request.token The revenue token to claim.
     * @returns A Promise that contains the amount of revenue token claimable
     */
    )
  }, {
    key: "claimableRevenue",
    value: (function () {
      var _claimableRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var proxyAddress, ipRoyaltyVault;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.getRoyaltyVaultAddress(getAddress$1(request.royaltyVaultIpId, "request.royaltyVaultIpId"));
            case 3:
              proxyAddress = _context3.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              _context3.next = 7;
              return ipRoyaltyVault.claimableRevenue({
                account: getAddress$1(request.account, "request.account"),
                snapshotId: BigInt(request.snapshotId),
                token: getAddress$1(request.token, "request.token")
              });
            case 7:
              return _context3.abrupt("return", _context3.sent);
            case 10:
              _context3.prev = 10;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to calculate claimable revenue");
            case 13:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 10]]);
      }));
      function claimableRevenue(_x3) {
        return _claimableRevenue.apply(this, arguments);
      }
      return claimableRevenue;
    }()
    /**
     * Allows token holders to claim by a list of snapshot ids based on the token balance at certain snapshot
     * @param request - The request object that contains all data needed to claim revenue.
     *   @param request.snapshotIds The list of snapshot ids.
     *   @param request.royaltyVaultIpId The id of the royalty vault.
     *   @param request.token The revenue token to claim.
     *   @param request.account [Optional] The ipId to send.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional claimableToken if waitForTxn is set to true.
     * @emits RevenueTokenClaimed (claimer, token, amount).
     */
    )
  }, {
    key: "claimRevenue",
    value: (function () {
      var _claimRevenue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _request$txOptions7, proxyAddress, ipRoyaltyVault, txHash, _request$txOptions5, iPAccountExecuteResponse, _request$txOptions6, req, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return this.getRoyaltyVaultAddress(getAddress$1(request.royaltyVaultIpId, "request.royaltyVaultIpId"));
            case 3:
              proxyAddress = _context4.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              request.snapshotIds = request.snapshotIds.map(function (item) {
                return BigInt(item);
              });
              if (!request.account) {
                _context4.next = 15;
                break;
              }
              _context4.next = 9;
              return this.ipAccountClient.execute({
                to: proxyAddress,
                value: 0,
                ipId: getAddress$1(request.account, "request.account"),
                txOptions: request.txOptions,
                data: encodeFunctionData({
                  abi: ipRoyaltyVaultImplAbi,
                  functionName: "claimRevenueBySnapshotBatch",
                  args: [request.snapshotIds, request.token]
                })
              });
            case 9:
              iPAccountExecuteResponse = _context4.sent;
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context4.next = 12;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: iPAccountExecuteResponse.encodedTxData
              });
            case 12:
              txHash = iPAccountExecuteResponse.txHash;
              _context4.next = 23;
              break;
            case 15:
              req = {
                snapshotIds: request.snapshotIds,
                token: getAddress$1(request.token, "request.token")
              };
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.encodedTxDataOnly)) {
                _context4.next = 20;
                break;
              }
              return _context4.abrupt("return", {
                encodedTxData: ipRoyaltyVault.claimRevenueBySnapshotBatchEncode(req)
              });
            case 20:
              _context4.next = 22;
              return ipRoyaltyVault.claimRevenueBySnapshotBatch(req);
            case 22:
              txHash = _context4.sent;
            case 23:
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.waitForTransaction)) {
                _context4.next = 31;
                break;
              }
              _context4.next = 26;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 26:
              txReceipt = _context4.sent;
              targetLogs = ipRoyaltyVault.parseTxRevenueTokenClaimedEvent(txReceipt);
              return _context4.abrupt("return", {
                txHash: txHash,
                claimableToken: targetLogs[0].amount
              });
            case 31:
              return _context4.abrupt("return", {
                txHash: txHash
              });
            case 32:
              _context4.next = 37;
              break;
            case 34:
              _context4.prev = 34;
              _context4.t0 = _context4["catch"](0);
              handleError(_context4.t0, "Failed to claim revenue");
            case 37:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0, 34]]);
      }));
      function claimRevenue(_x4) {
        return _claimRevenue.apply(this, arguments);
      }
      return claimRevenue;
    }()
    /**
     * Snapshots the claimable revenue and royalty token amounts.
     * @param request - The request object that contains all data needed to snapshot.
     *   @param request.royaltyVaultIpId The id of the royalty vault.
     *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
     * @returns A Promise that resolves to an object containing the transaction hash and optional snapshotId if waitForTxn is set to true.
     * @emits SnapshotCompleted (snapshotId, snapshotTimestamp, unclaimedTokens).
     */
    )
  }, {
    key: "snapshot",
    value: (function () {
      var _snapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions8, proxyAddress, ipRoyaltyVault, _request$txOptions9, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return this.getRoyaltyVaultAddress(getAddress$1(request.royaltyVaultIpId, "request.royaltyVaultIpId"));
            case 3:
              proxyAddress = _context5.sent;
              ipRoyaltyVault = new IpRoyaltyVaultImplClient(this.rpcClient, this.wallet, proxyAddress);
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.encodedTxDataOnly)) {
                _context5.next = 9;
                break;
              }
              return _context5.abrupt("return", {
                encodedTxData: ipRoyaltyVault.snapshotEncode()
              });
            case 9:
              _context5.next = 11;
              return ipRoyaltyVault.snapshot();
            case 11:
              txHash = _context5.sent;
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.waitForTransaction)) {
                _context5.next = 20;
                break;
              }
              _context5.next = 15;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 15:
              txReceipt = _context5.sent;
              targetLogs = ipRoyaltyVault.parseTxSnapshotCompletedEvent(txReceipt);
              return _context5.abrupt("return", {
                txHash: txHash,
                snapshotId: targetLogs[0].snapshotId
              });
            case 20:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 21:
              _context5.next = 26;
              break;
            case 23:
              _context5.prev = 23;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to snapshot");
            case 26:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 23]]);
      }));
      function snapshot(_x5) {
        return _snapshot.apply(this, arguments);
      }
      return snapshot;
    }()
    /**
     * Get the royalty vault proxy address of given royaltyVaultIpId.
     * @param royaltyVaultIpId the id of the royalty vault.
     * @returns A Promise that resolves to an object containing the royalty vault address.
     */
    )
  }, {
    key: "getRoyaltyVaultAddress",
    value: (function () {
      var _getRoyaltyVaultAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(royaltyVaultIpId) {
        var isRoyaltyVaultIpIdRegistered, data;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: getAddress$1(royaltyVaultIpId, "royaltyVaultIpId")
              });
            case 2:
              isRoyaltyVaultIpIdRegistered = _context6.sent;
              if (isRoyaltyVaultIpIdRegistered) {
                _context6.next = 5;
                break;
              }
              throw new Error("The royalty vault IP with id ".concat(royaltyVaultIpId, " is not registered."));
            case 5:
              _context6.next = 7;
              return this.royaltyPolicyLapClient.getRoyaltyData({
                ipId: royaltyVaultIpId
              });
            case 7:
              data = _context6.sent;
              if (!(!data[1] || data[1] === "0x")) {
                _context6.next = 10;
                break;
              }
              throw new Error("The royalty vault IP with id ".concat(royaltyVaultIpId, " address is not set."));
            case 10:
              return _context6.abrupt("return", data[1]);
            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getRoyaltyVaultAddress(_x6) {
        return _getRoyaltyVaultAddress.apply(this, arguments);
      }
      return getRoyaltyVaultAddress;
    }())
  }]);
}();

var NftClient = /*#__PURE__*/function () {
  function NftClient(rpcClient, wallet) {
    _classCallCheck(this, NftClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.spgClient = new SpgClient(rpcClient, wallet);
  }

  /**
   * Creates a new SPG NFT Collection.
   * @param request - The request object containing necessary data to create a SPG NFT Collection.
   *   @param request.name - The name of the collection.
   * 	 @param request.symbol - The symbol of the collection.
   * 	 @param request.maxSupply - The maximum supply of the collection.
   * 	 @param request.mintFee - The cost to mint a token.
   * 	 @param request.mintFeeToken - The token to mint.
   * 	 @param request.owner - The owner of the collection.
   *   @param request.txOptions - [Optional] transaction. This extends `WaitForTransactionReceiptParameters` from the Viem library, excluding the `hash` property.
   * @returns A Promise that resolves to a CreateNFTCollectionResponse containing the transaction hash and collection address.
   * @emits CollectionCreated (nftContract);
   */
  return _createClass(NftClient, [{
    key: "createNFTCollection",
    value: (function () {
      var _createNFTCollection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$maxSupply, _request$mintFee, _request$mintFeeToken, _request$txOptions, req, _request$txOptions2, txHash, txReceipt, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              if (!(request.mintFee !== undefined && (request.mintFee < 0n || !isAddress(request.mintFeeToken || "")))) {
                _context.next = 3;
                break;
              }
              throw new Error("Invalid mint fee token address, mint fee is greater than 0.");
            case 3:
              req = {
                name: request.name,
                symbol: request.symbol,
                maxSupply: (_request$maxSupply = request.maxSupply) !== null && _request$maxSupply !== void 0 ? _request$maxSupply : Number(maxUint32),
                mintFee: (_request$mintFee = request.mintFee) !== null && _request$mintFee !== void 0 ? _request$mintFee : 0n,
                mintFeeToken: (_request$mintFeeToken = request.mintFeeToken) !== null && _request$mintFeeToken !== void 0 ? _request$mintFeeToken : zeroAddress,
                owner: request.owner && getAddress$1(request.owner, "request.owner") || this.wallet.account.address
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", {
                encodedTxData: this.spgClient.createCollectionEncode(req)
              });
            case 8:
              _context.next = 10;
              return this.spgClient.createCollection(req);
            case 10:
              txHash = _context.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context.next = 17;
                break;
              }
              _context.next = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              txReceipt = _context.sent;
              targetLogs = this.spgClient.parseTxCollectionCreatedEvent(txReceipt);
              return _context.abrupt("return", {
                txHash: txHash,
                nftContract: targetLogs[0].nftContract
              });
            case 17:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 18:
              _context.next = 23;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to create a SPG NFT collection");
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 20]]);
      }));
      function createNFTCollection(_x) {
        return _createNFTCollection.apply(this, arguments);
      }
      return createNFTCollection;
    }())
  }]);
}();

if (typeof process !== "undefined") {
  dotenv.config();
}
/**
 * The StoryClient is the main entry point for the SDK.
 */
var StoryClient = /*#__PURE__*/function () {
  /**
   * @param config - the configuration for the SDK client
   */
  function StoryClient(config) {
    _classCallCheck(this, StoryClient);
    _defineProperty(this, "_ipAsset", null);
    _defineProperty(this, "_permission", null);
    _defineProperty(this, "_license", null);
    _defineProperty(this, "_dispute", null);
    _defineProperty(this, "_ipAccount", null);
    _defineProperty(this, "_royalty", null);
    _defineProperty(this, "_nftClient", null);
    this.config = _objectSpread2(_objectSpread2({}, config), {}, {
      chainId: config.chainId || "iliad"
    });
    if (!this.config.transport) {
      throw new Error("transport is null, please pass in a valid RPC Provider URL as the transport.");
    }
    var clientConfig = {
      chain: chainStringToViemChain(this.config.chainId),
      transport: this.config.transport
    };
    this.rpcClient = createPublicClient(clientConfig);
    if (this.config.wallet) {
      this.wallet = this.config.wallet;
    } else if (this.config.account) {
      var account = this.config.account;
      this.wallet = createWalletClient(_objectSpread2(_objectSpread2({}, clientConfig), {}, {
        account: account
      }));
    } else {
      throw new Error("must specify a wallet or account");
    }
  }

  /**
   * Factory method for creating a SDK client with a signer.
   *
   * @param config StoryClient - the configuration for a new SDK client
   */
  return _createClass(StoryClient, [{
    key: "ipAsset",
    get:
    /**
     * Getter for the ip asset client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAssetClient instance
     */
    function get() {
      if (this._ipAsset === null) {
        this._ipAsset = new IPAssetClient(this.rpcClient, this.wallet, this.config.chainId);
      }
      return this._ipAsset;
    }

    /**
     * Getter for the permission client. The client is lazily created when
     * this method is called.
     *
     * @returns the PermissionClient instance
     */
  }, {
    key: "permission",
    get: function get() {
      if (this._permission === null) {
        this._permission = new PermissionClient(this.rpcClient, this.wallet, this.config.chainId);
      }
      return this._permission;
    }

    /**
     * Getter for the license client. The client is lazily created when
     * this method is called.
     *
     * @returns the LicenseClient instance
     */
  }, {
    key: "license",
    get: function get() {
      if (this._license === null) {
        this._license = new LicenseClient(this.rpcClient, this.wallet);
      }
      return this._license;
    }

    /**
     * Getter for the dispute client. The client is lazily created when
     * this method is called.
     *
     * @returns the DisputeClient instance
     */
  }, {
    key: "dispute",
    get: function get() {
      if (this._dispute === null) {
        this._dispute = new DisputeClient(this.rpcClient, this.wallet);
      }
      return this._dispute;
    }

    /**
     * Getter for the ip account client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAccountClient instance
     */
  }, {
    key: "ipAccount",
    get: function get() {
      if (this._ipAccount === null) {
        this._ipAccount = new IPAccountClient(this.rpcClient, this.wallet);
      }
      return this._ipAccount;
    }

    /**
     * Getter for the royalty client. The client is lazily created when
     * this method is called.
     *
     * @returns the RoyaltyClient instance
     */
  }, {
    key: "royalty",
    get: function get() {
      if (this._royalty === null) {
        this._royalty = new RoyaltyClient(this.rpcClient, this.wallet);
      }
      return this._royalty;
    }

    /**
     * Getter for the NFT client. The client is lazily created when
     * this method is called.
     *
     * @returns the NftClient instance
     */
  }, {
    key: "nftClient",
    get: function get() {
      if (this._nftClient === null) {
        this._nftClient = new NftClient(this.rpcClient, this.wallet);
      }
      return this._nftClient;
    }
  }], [{
    key: "newClient",
    value: function newClient(config) {
      return new StoryClient(config);
    }

    /**
     * Factory method for creating a SDK client with a signer.
     *
     * @param config WalletClientConfig - the configuration for a new SDK client
     */
  }, {
    key: "newClientUseWallet",
    value: function newClientUseWallet(config) {
      return new StoryClient({
        chainId: config.chainId,
        transport: config.transport,
        wallet: config.wallet
      });
    }

    /**
     * Factory method for creating a SDK client with a signer.
     *
     * @param config UseAccountStoryConfig - the configuration for a new SDK client
     */
  }, {
    key: "newClientUseAccount",
    value: function newClientUseAccount(config) {
      return new StoryClient({
        account: config.account,
        chainId: config.chainId,
        transport: config.transport
      });
    }
  }]);
}();

export { AccessPermission, AddressZero, DisputeClient, HashZero, IPAccountClient, IPAssetClient, LicenseClient, NftClient, PIL_TYPE, PermissionClient, RoyaltyClient, StoryClient, getPermissionSignature, iliad };
