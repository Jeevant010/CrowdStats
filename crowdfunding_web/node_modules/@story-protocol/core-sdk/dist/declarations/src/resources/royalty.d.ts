import { Address, Hex, PublicClient } from "viem";
import { IpAssetRegistryClient, IpRoyaltyVaultImplEventClient, IpRoyaltyVaultImplReadOnlyClient, Multicall3Client, RoyaltyModuleClient, RoyaltyWorkflowsClient, SimpleWalletClient, WrappedIpClient } from "../abi/generated.js";
import { ChainIds } from "../types/config.js";
import { TransactionResponse } from "../types/options.js";
import { BatchClaimAllRevenueRequest, BatchClaimAllRevenueResponse, ClaimableRevenueRequest, ClaimableRevenueResponse, ClaimAllRevenueRequest, ClaimAllRevenueResponse, PayRoyaltyOnBehalfRequest, PayRoyaltyOnBehalfResponse, TransferToVaultRequest } from "../types/resources/royalty.js";
export declare class RoyaltyClient {
    royaltyModuleClient: RoyaltyModuleClient;
    ipAssetRegistryClient: IpAssetRegistryClient;
    ipRoyaltyVaultImplReadOnlyClient: IpRoyaltyVaultImplReadOnlyClient;
    ipRoyaltyVaultImplEventClient: IpRoyaltyVaultImplEventClient;
    royaltyWorkflowsClient: RoyaltyWorkflowsClient;
    multicall3Client: Multicall3Client;
    wrappedIpClient: WrappedIpClient;
    private readonly rpcClient;
    private readonly wallet;
    private readonly walletAddress;
    private readonly chainId;
    constructor(rpcClient: PublicClient, wallet: SimpleWalletClient, chainId: ChainIds);
    /**
     * Claims all revenue from the child IPs of an ancestor IP, then transfer
     * all claimed tokens to the wallet if the wallet owns the IP or is the claimer.
     * If claimed token is WIP, it will also be converted back to IP.
     *
     * @remarks
     * Even if there are no child IPs, you must still populate {@link ClaimAllRevenueRequest.currencyTokens} with
     * the token addresses you wish to claim. This is required for the claim operation to know which
     * token balances to process.
     */
    claimAllRevenue(req: ClaimAllRevenueRequest): Promise<ClaimAllRevenueResponse>;
    /**
     * Automatically batch claims all revenue from the child IPs of multiple ancestor IPs.
     * if multicall is disabled, it will call @link{claimAllRevenue} for each ancestor IP.
     * Then transfer all claimed tokens to the wallet if the wallet owns the IP or is the claimer.
     * If claimed token is WIP, it will also be converted back to IP.
     *
     * @remarks
     * Even if there are no child IPs, you must still populate `currencyTokens` in each ancestor IP
     * with the token addresses you wish to claim. This is required for the claim operation to know which
     * token balances to process.
     */
    batchClaimAllRevenue(request: BatchClaimAllRevenueRequest): Promise<BatchClaimAllRevenueResponse>;
    /**
     * Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.
     */
    payRoyaltyOnBehalf(request: PayRoyaltyOnBehalfRequest): Promise<PayRoyaltyOnBehalfResponse>;
    /**
     * Get total amount of revenue token claimable by a royalty token holder.
     * Returns the amount of revenue token claimable by the claimer.
     */
    claimableRevenue(request: ClaimableRevenueRequest): Promise<ClaimableRevenueResponse>;
    /**
     * Get the royalty vault proxy address of given ip id of the royalty vault.
     */
    getRoyaltyVaultAddress(ipId: Hex): Promise<Address>;
    /**
     * Transfers to vault an amount of revenue tokens claimable via a royalty policy.
     */
    transferToVault({ txOptions, ipId, royaltyPolicy, ancestorIpId, token, }: TransferToVaultRequest): Promise<TransactionResponse>;
    private transferClaimedTokensFromIpToWallet;
    private getClaimerInfo;
    /**
     * Unwraps WIP tokens back to their underlying IP tokens. Only accepts a single WIP token entry
     * in the claimed tokens array. Throws an error if multiple WIP tokens are found.
     */
    private unwrapWipTokens;
}
//# sourceMappingURL=royalty.d.ts.map